{"pages":[{"title":"","text":"Arduino Arduino 시작하기, RGB LED, PWM Arduino 스위치, PULL DOWN, PULL UP Arduino TM1637 모듈 사용하기 Arduino, 온도측정(DS18b20) Arduino, 온도 및 습도 측정(DHT22) Arduino, 1602LCD (I2C) Arduino, 서보모터 Arduino, 스텝모터 Arduino, IR 리모컨 Arduino, 키패드 사용하기 Arduino, Piezo Buzzer 7 Segment (FND) 사용하기 1602 LCD Display, 조도, 초음파, 온습도센서 Processing 기초 Arduino, Bluetooth 페어링 Bluetooth Serial Controller 앱 Blynk에 센서값 출력하기 Arduino, Bluetooth, Blynk Arduino, 라인트레이서, L298N Arduino, DC모터 4WD 자동차 만들기 (TB6612FNG) Arduino, 4WD Bluetooth ESP32 ESP32-WROOM-32D DevkitC V4 ESP32 시작하기, LED, PWM ESP32 ADC ESP32, DS18b20 온도 측정, PLX-DAQ 데이터 로깅 ESP32, OLED, 비트맵 이미지, 한글, 센서 데이터 출력하기 ESP32 서보모터 ESP32 스텝모터 ESP32 nRF24L01 무선통신, 조이스틱, 서보모터 제어 ESP32 DC모터 제어 ESP32 RC카 ESP32 BLE, Blynk Button ESP32 BLE, Blynk Slider (PWM) ESP32 BLE, Blynk Gauge ESP32 AP mode &amp; Websocket ESP32 OpenWeatherMap에서 실시간 날씨 정보 받기 Science Experiment STEM, 중력 가속도 측정 STEM, 방사능 측정 가이거 계수기 STEM, Solar Tracker STEM, 전자기파 검출기 STEM, 알코올 램프 안전 손잡이 받침대 ESP32, DS18b20 온도 측정, PLX-DAQ 데이터 로깅 Blynk, IoT Arduino, Bluetooth 시리얼 통신 Blynk에 센서값 출력하기 Arduino, Bluetooth, Blynk ESP32 BLE, Blynk Button ESP32 BLE, Blynk Slider (PWM) ESP32 BLE, Blynk Gauge Drone 드론의 비행 원리 RC, LineTracer Arduino, 라인트레이서, L298N Arduino, DC모터 4WD 자동차 만들기 (TB6612FNG) Arduino, 4WD Bluetooth ESP32 RC Car Excel, Office 엑셀, 빈셀 채우기 엑셀, 사진으로 vlookup 효과 구현하기 엑셀, 다중조건 랭킹 구하기 엑셀, 데이터 유효성 검사의 목록 구성시 동적으로 범위 설정하기 Do It Yourself 역삼투압 정수기 만들기 연수기 만들기 hexo를 이용하여 Github 블로그 만들기","link":"/index.html"}],"posts":[{"title":"4WD Bluetooth","text":"4WD Bluetooth지금까지 배운 RC카, 블루투스 모듈 사용법, 컨트롤러 사용법을 종합하여 Bluetooth로 조종하는 4WD를 만들어 보겠습니다. IR리모트를 사용한 RC카를 베이스로 하여 IR수신부를 빼고, 블루투스 모듈인 HC-06만 연결하면 됩니다. schematic Bluetooth Serial Controller 설정여기서는 4WD를 블루투스로 조종하기 위한 콘트롤러를 만들어 봅니다. 먼저 Bluetooth Serial Controller를 실행시키세요. (블루투스 페어링이나 앱 설치방법은 이전의 글을 참고하세요.) 아래화면은 TERMINAL Mode인 상태입니다. 여기서 스페너 모양 아이콘을 눌러 PREFERCE로 진입하세요. PREFERENCE 화면에서 아무곳이나 누른 뒤, 위로 스크롤하여 9 BUTTON MODE를 활성화 시키고, TERMINAL MODE를 꺼주세요. 그러면 이런 화면이 나타납니다. 이제 각각의 버튼을 정의해보겠습니다. 다시 스페너 모양 아이콘을 눌러 PREFERENCE로 들어간 뒤, BUTTON-Name을 선택합니다. button2, button4, button5, button6, button8을 각각 누른 뒤, 각 버튼 별로 ‘전진’, ‘왼쪽’, ‘정지’, ‘오른쪽’, ‘후진’이라고 이름을 붙여줍니다. 다시 PREFERENCE에서 Command를 누르세요. Command에서 정의해주는 값이 제일 중요한데요. 각 버튼을 누를때, 아두이노로 전달되는 값을 정의해주는 것이기 때문입니다. button2, button4, button5, button6, button8을 각각 누른 뒤, 각 버튼 별로 ‘F’, ‘L’, ‘O’, ‘R’, ‘B’이라고 입력값을 넣어주세요. 이 값은 스케치 작성시 사용해야 하므로 꼭 기억해두어야 합니다. 이제 Visibility로 갑니다. 여기서는 필요없는 버튼을 지워줄 수 있어요. 실제 사용되는 버튼에만 체크하고, 나머지 버튼은 체크 해제합니다. 그러면, 아래와 같은 멋진 블루투스 컨트롤러가 나타납니다. 이 상태에서 돋보기 모양 아이콘을 눌러 HC-06에 접속해 봅니다. 여기서부터는 블루투스 페어링 과정에서 설명했던 부분과 똑같습니다. 모듈ID인 SKS100을 누르면 페어링을 시도하고요. 만일 페어링할 모듈이 나타나지 않으면, Scan for devices로 모듈을 찾아 페어링을 해봅니다. 페어링을 시도하는 중이네요. 페어링 완료! 이제 컨트롤러 사용을 위한 모든 준비과정이 완료되었습니다. 4WD 블루투스 초음파센서 자동차위 회로에 초음파 센서 하나만 덧붙여봅니다. 50cm 이내에 물체가 접근하면 후진했다가 정지하도록 되어있습니다. (실제로는 50cm보다 훨씬 짧은 거리내에서 후진을 시작하네요.) schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//Initialize Bluetooth#include &lt;SoftwareSerial.h&gt;SoftwareSerial BTSerial(7, 3); // HC-06 TX,RX// Initialize TB6612FNG Motor driveint STBY = 10; // STBY pin on TB6612FNG. Must be HIGH to enable motorint A_PWM = 5; // Left motor speed control using analogWrite() function. Value between 0 - 255int A_IN1 = 9; // Left motor - LOW should go forwardint A_IN2 = 8; // Left motor - HIGH should go forwardint B_PWM = 6; // Right motor speed control using analogWrite() function. Value between 0 - 255int B_IN1 = 11; // Right motor - LOW should go forwardint B_IN2 = 12; // Right motor - HIGH should go forwardint L_MaxSpeed = 255; //set motor speed to max speedint R_MaxSpeed = 255; //set motor speed to max speedint L_TurnSpeed = 128; //set motor speed to max speedint R_TurnSpeed = 128; //set motor speed to max speedint LR_Direct = 0; //for Direction (0:clockwise, 1:count-clockwise)// Initialize Ultrasonic Sensor#define TRIG 2#define ECHO 4char val;long val_distance;void setup() { pinMode(A_PWM, OUTPUT); // Motor pinMode(A_IN1, OUTPUT); pinMode(A_IN2, OUTPUT); pinMode(B_PWM, OUTPUT); pinMode(B_IN1, OUTPUT); pinMode(B_IN2, OUTPUT); pinMode(STBY, OUTPUT); pinMode(TRIG, OUTPUT); // Ultrasonic Sensor pinMode(ECHO, INPUT); Serial.begin(9600); BTSerial.begin(9600); // Start Bluetooth while (!BTSerial.available()) { // 처음 입력이 있을때까지 stop(); // 정지 }}void loop() { distance(); // 거리 측정 Serial.println(val_distance); // 거리 출력 if (BTSerial.available()) { // Check for Bluetooth input val = BTSerial.read(); // 입력값 val에 저장 Serial.println(val); // 입력값 출력 } if (val_distance &gt; 50) { // 거리가 50cm 이상이면 입력값 실행 parseCommand(val); // parse the input } else { // 거리가 50cm 이내이면 stop(); delay(20); b_stop(); // 거리가 50cm 이상이 될 때까지 후진 후, 정지 } delay(50);}void parseCommand(char input) { switch (input) { case 'F': go_forward(); break; case 'B': go_backward(); break; case 'L': if(LR_Direct==0) { go_f_left(); } else if(LR_Direct==1) { go_b_left(); } break; case 'R': if(LR_Direct==0) { go_f_right(); } else if(LR_Direct==1) { go_b_right(); } break; case 'O': stop(); break; } delay(50);}void distance() { digitalWrite(TRIG, LOW); // Start Ultrasonic sensor delayMicroseconds(2); digitalWrite(TRIG, HIGH); delayMicroseconds(10); digitalWrite(TRIG, LOW); val_distance = pulseIn(ECHO, HIGH) / 58.2; // 거리 측정} // Move specific motor at speed and direction// motor: A(Left) -&gt; 0, B(Right) -&gt; 1// speed: 0 is off, and 255 is full speed// direction: 0 clockwise, 1 counter-clockwisevoid move(int motorLR, int speed, boolean inPin1, boolean inPin2) { digitalWrite(STBY, HIGH); // Disable Standby if (motorLR == 0) { analogWrite(A_PWM, speed); digitalWrite(A_IN1, inPin1); digitalWrite(A_IN2, inPin2); } if (motorLR == 1) { analogWrite(B_PWM, speed); digitalWrite(B_IN1, inPin1); digitalWrite(B_IN2, inPin2); }}void go_forward() { Serial.println(&quot;F&quot;); move(0, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) move(1, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) LR_Direct = 0; // Forward delay(100);}void go_backward() { Serial.println(&quot;B&quot;); move(0, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) move(1, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) LR_Direct = 1; // Backward delay(100);}void go_f_left() { Serial.println(&quot;F_L&quot;); move(0, L_TurnSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) move(1, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) delay(100);}void go_b_left() { Serial.println(&quot;B_R&quot;); move(0, L_TurnSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) move(1, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) delay(100);}void go_f_right() { Serial.println(&quot;F_R&quot;); move(0, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) move(1, R_TurnSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) delay(100);}void go_b_right() { Serial.println(&quot;B_R&quot;); move(0, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) move(1, R_TurnSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) delay(100);}void b_stop() { Serial.println(&quot;B_STOP&quot;); while (val_distance &lt; 50) { // 거리가 50cm 이내인 경우 반복 go_backward(); // 후진 delay(100); distance(); // 거리를 다시 측정 delay(10); } while (!BTSerial.available()) { // 입력이 없으면 stop(); // 정지상태 유지 } LR_Direct = 0; // 앞으로 갈 준비}void stop() { Serial.println(&quot;STOP&quot;); digitalWrite(STBY, LOW); // Enable Standby}","link":"/2019/10/30/4WD-Bluetooth/"},{"title":"Arduino, 1602 LCD (I2C)","text":"1602 LCD (I2C)schematic 1602 LCD SDA SCL VCC GND Arduino A4 A5 5V GND 라이브러리 설치하기스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리 Wire : 기본 내장 라이브러리 LiquidCrystal I2C (by Frank de Brabander) 검색하여 설치 sketch1234567891011121314151617181920212223242526272829303132333435// I2C 1602 LCD (연결핀을 바꿀 수 없음)// VCC-5V / GND-GND / SDA-A4 / SCL-A5#include &lt;Wire.h&gt;#include &lt;LiquidCrystal_I2C.h&gt;// i2c address 는 칩에 따라 0x20~0x27 혹은 0x3F값을 가짐LiquidCrystal_I2C lcd(0x27, 16, 2); void setup() { lcd.init(); // lcd 초기화 lcd.backlight(); lcd.print(&quot;I Love Steam!!&quot;); // LCD창에 메시지 출력 delay(1000);}void loop() { // 문자열의 길이 13개를 왼쪽으로 스크롤 for(int pCount = 0; pCount &lt; 13; pCount++) { lcd.scrollDisplayLeft(); // 왼쪽으로 스크롤 delay(700); } // 문자열 길이 13열 + 기본 16열 = 29개 위치를 오른쪽으로 스크롤 for(int pCount = 0; pCount &lt; 29; pCount++) { lcd.scrollDisplayRight(); // 오른쪽으로 스크롤 delay(700); } // 왼쪽으로 16개 위치 스크롤하여 처음 위치로 이동 for(int pCount = 0; pCount &lt; 16; pCount++) { lcd.scrollDisplayLeft(); // 왼쪽으로 스크롤 delay(700); } delay(1000);} 주의사항 I2C 모듈에 점퍼선을 뺏다가 다시 끼우는 경우, 정상적인 상황에서도 LCD가 작동하지 않는 경우가 있음 (주로 첫번째라인에 ■■■■■■■■■■■■■■■■ 형태로 출력되는 오류가 발생됨) 이런 경우에는 배선을 모두 완료한 상태에서 스케치 업로드를 다시 하면 대부분 해결됨 여러 가지 문자열 출력해보기 첫 번째 행에 I Love Steam!! 두 번째 행에 본인의 영문이름을 써서 스크롤 해보기 두 번째 행에 출력하는 방법 : lcd.setCursor(0,1); 1602 LCD에 DS18b20 온도센서 값 출력하기schematic sketch12345678910111213141516171819202122232425262728293031323334353637383940414243// DS18b20 Temperature Sensor#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 2OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);float celciusTemperature;// I2C 1602 LCD (연결핀을 바꿀 수 없음)// VCC-5V / GND-GND / SDA-A4 / SCL-A5#include &lt;Wire.h&gt;#include &lt;LiquidCrystal_I2C.h&gt;// i2c address 는 칩에 따라 0x27, 0x3F값을 가짐LiquidCrystal_I2C lcd(0x27, 16, 2); void setup() { Serial.begin(9600); Serial.println(&quot;DallasTemperature IC Control&quot;); // Start up the Temperature Sensor library sensors.begin(); // lcd 초기화 lcd.init(); lcd.backlight();}void loop() { sensors.requestTemperatures(); celciusTemperature = sensors.getTempCByIndex(0); Serial.print(&quot;Temperature is: &quot;); Serial.println(celciusTemperature); lcd.setCursor(0, 0); lcd.print(&quot;Temperature : &quot;); lcd.setCursor(0, 1); lcd.print(celciusTemperature); lcd.print(&quot;*C&quot;); delay(2000);}","link":"/2018/09/02/Arduino-1602-LCD-I2C/"},{"title":"1602 LCD, 조도, 초음파, 온습도","text":"1602 LCD 중에서 (I2C 모듈이 추가되어 있지 않은) 가장 기본적인 형태, 즉 1602 LCD만 있는 상태에서의 출력방법을 알아보겠습니다. schematic schematic : 백라이트 밝기 조절 추가백라이트를 사용하지 않으면 너무 어두워서 글자가 잘 보이지 않는다. 적당한 밝기의 백라이트 사용을 위해 LCD 3번핀을 3.3㏀ 거쳐서 GND로 연결(혹은 1㏀ 3개를 직렬연결) 하거나, 아래 회로와 같이 가변 저항을 사용하면 백라이트의 밝기를 적절히 조절할 수도 있다. Pin Map LCD Pin Arduino Uno 1 VSS LCD GND GND 2 VDD LCD 전원 +5V 3 VO 글자 대비값 (가변저항 추가/미사용시 3.3㏀ 거쳐서 GND) 4 RS 레지스터 설정 12 5 RW 읽기/쓰기모드 설정 GND 6 E 쓰기모드 활성화 11 7 D0 데이터 핀 8 D1 ″ 9 D2 ″ 10 D3 ″ 11 D4 ″ 5 12 D5 ″ 4 13 D6 ″ 3 14 D7 ″ 2 15 A 배경밝기 전압입력 (가변저항 추가) 16 K 배경밝기 GND (가변저항 추가) sketch라이브러리 설치하기이 경우에는 Arduino IDE에 기본적으로 포함되어 있는 LiquidCrystal 라이브러리를 이용한다. 스케치&gt; 라이브러리 포함하기&gt; LiquidCrystal 1#include &lt;LiquidCrystal.h&gt; function function 기능 LiquidCrystal() LCD 클래스 생성(LCD interface 설정) begin() LCD 화면 초기화(column과 row 설정) clear() LCD 화면을 지우고 커서를 (0,0) 위치로 옮김 home() 커서를 (0,0) 위치로 옮김 setCursor() 커서를 특정 위치로 옮김 write() 현재 커서에 한 문자를 출력 print() 현재 커서부터 출력 (Serial.print() 함수와 유사) cursor(), nocursor() 커서 표시 O or X display(), noDisplay() LCD 화면에 정보 표시 O or X scrollDisplayLeft(), scrollDisplayRight() LCD 내용과 커서를 좌/우로 한 칸 스크롤 autoscroll(), noautoscroll() 문자 출력 시 이전 내용을 스크롤 할 지를 결정 leftToRight(), rightToLeft() 문자 출력 후 커서의 이동 위치 결정 (문자 출력 방향 결정) createChar() 사용자 문자 등록, 총 8개까지 가능 예시sketch : 문자 2열 출력하기12345678910111213#include &lt;LiquidCrystal.h&gt;LiquidCrystal lcd(12,11,5,4,3,2); // pin 연결에 대한 class 선언 (RS,E,D4,D5,D6,D7)void setup() { lcd.begin(16, 2); // LCD크기 지정 lcd.print(&quot;SKS Afterschool&quot;); lcd.setCursor(0, 1); // 커서를 (0,1) 즉 두번째 줄(행)의 첫번째 칸(열)으로 이동 lcd.print(&quot;Let's Arduino!!&quot;);}void loop() {} sketch : 문자열 좌우 스크롤하기123456789101112131415161718192021222324252627282930#include &lt;LiquidCrystal.h&gt;LiquidCrystal lcd(12, 11, 5, 4, 3, 2);void setup() { lcd.begin(16, 2); lcd.print(&quot;SKS Afterschool&quot;); lcd.setCursor(0, 1); lcd.print(&quot;Let's Arduino!!&quot;); delay(1000);}void loop() { for (int left = 0; left &lt; 15; left++) { lcd.scrollDisplayLeft(); // 15번 왼쪽으로 이동 (15글자) delay(300); } for (int right = 0; right &lt; 31; right++) { lcd.scrollDisplayRight(); // 31번 오른쪽으로 이동 (15글자+16칸) delay(300); } for (int left = 0; left &lt; 16; left++) { lcd.scrollDisplayLeft(); // 16번 왼쪽으로 이동 (16칸) delay(300); } delay(1000);} 문자열과 조도센서값을 출력하기schematic sketch : 문자열과 조도센서를 읽은 조도값을 동시에 출력하기1234567891011121314#include &lt;LiquidCrystal.h&gt;LiquidCrystal lcd(12,11,5,4,3,2); // pin 연결에 대한 class 선언 (RS,E,D4,D5,D6,D7)void setup() { lcd.begin(16, 2); // LCD크기 지정 lcd.print(&quot;Illumination:&quot;);}void loop() { lcd.setCursor(0, 1); // 커서를 (0,1) 즉 첫번째 줄의 두번째 칸으로 이동 lcd.print(analogRead(A0)); // A0에서 읽은 조도값을 출력 delay(200);} sketch : 조도 센서값을 위로 스크롤시키기1234567891011121314151617181920212223242526272829303132333435#include &lt;LiquidCrystal.h&gt;int i, j, k=1;LiquidCrystal lcd(12,11,5,4,3,2);void setup() { lcd.begin(16, 2); lcd.print(&quot;Illumination:&quot;); lcd.setCursor(0, 1); // 두번째 줄에 i = analogRead(A0); lcd.print(&quot;Check#&quot;); lcd.print(k); // 측정 횟수 lcd.print(&quot; : &quot;); lcd.print(i); // 첫번째 조도값 출력 delay(1000);}void loop() { lcd.clear(); // lcd 화면 지우고 (0,0)으로 커서 이동 j = i; // 이전 조도값을 j에 저장 lcd.print(&quot;Check#&quot;); lcd.print(k); // 이전 조도값 측정 횟수 lcd.print(&quot; : &quot;); lcd.print(j); // 이전 조도값 출력 lcd.setCursor(0, 1); // 두번째 줄로 이동 i = analogRead(A0); // 새로운 조도값 측정 k++; // 측정 횟수 증가 lcd.print(&quot;check#&quot;); lcd.print(k); // 새로운 측정 횟수 lcd.print(&quot; : &quot;); lcd.print(i); // 새로운 조도값 출력 delay(1000);} 초음파 센서 거리값 출력하기초음파를 이용하여 사물간의 거리를 측정하는 센서입니다. 아두이노에서는 HC-SR04, US-100 제품을 많이 사용하며, 여기서는 HC-SR04를 사용해보겠습니다. schematic Pin Map : HC-SR04 DHT11 아두이노 VCC 5V Trig (초음파 송신) 8 (pinMode 설정함) Echo (초음파 수신) 9 (pinMode 설정함) GND GND sketch1234567891011121314151617181920212223242526#include &lt;LiquidCrystal.h&gt;#define TRIG 8#define ECHO 9LiquidCrystal lcd(12, 11, 5, 4, 3, 2);void setup() { pinMode(TRIG, OUTPUT); pinMode(ECHO, INPUT); lcd.begin(16, 2);}void loop() { digitalWrite(TRIG, LOW); // 초음파발사 정지(초기화) delayMicroseconds(2); digitalWrite(TRIG, HIGH); // 초음파발사 delayMicroseconds(2); digitalWrite(TRIG, LOW); // 초음파발사 정지 long distance = pulseIn(ECHO, HIGH)/58.2; lcd.clear(); lcd.setCursor(0,0); lcd.print(distance); lcd.print(&quot; cm&quot;); delay(200);} DHT11 온·습도센서 값 출력하기DHT11 센서를 사용하면 온도와 습도를 동시에 측정할 수 있다. 여기서는 1602 LCD에 온도와 습도를 출력해본다. schematic Pin Map DHT11 1 2 3 4 Arduino 5V 2, 10㏀ 저항 거쳐서 5V GND 라이브러리 추가하기 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; 라이브러리 매니저 에서 “DHT11” 검색 DHT sensor library by Adafruit 설치 sketch12345678910111213141516171819202122232425262728#include &lt;LiquidCrystal.h&gt;#include &lt;DHT.h&gt;LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // RS, E, D4, D5, D6, D7#define DHTPIN 10#define DHTTYPE DHT11DHT dht(DHTPIN, DHTTYPE);void setup() { dht.begin(); lcd.begin(16, 2);}void loop() { float t = dht.readTemperature(); // read temperature float h = dht.readHumidity(); // read humidity lcd.clear(); lcd.setCursor(0, 0); lcd.print(&quot;Temp.: &quot;); // write temperature lcd.print(t); lcd.print(&quot; C&quot;); lcd.setCursor(0, 1); lcd.print(&quot;Humi.: &quot;); // write humidity lcd.print(h); lcd.print(&quot;%&quot;); delay(1000);} 과제입력버튼을 만들과, 각 버튼을 누를때마다 A → B → C → D 등 출력하기","link":"/2018/10/02/1602-LCD-Display/"},{"title":"Arduino, Bluetooth, Blynk","text":"Blynk 설정Blynk 라이브러리 설치 docs.blynk.cc 접속 – Downloads – Blynk Library https://github.com/blynkkk/blynk-library/releases/tag/v0.6.1 Blynk_Release_v0.6.1.zip 다운로드 압축을 풀면 libraries, tools 폴더가 보임 이 두 폴더를 아두이노IDE의 기본 스케치북 위치로 복사하여 붙여넣기 함 기존의 libraries 폴더와 합쳐짐 기본 스케치북 위치 확인 방법 아두이노IDE – 파일 – 환경설정 – 설정탭 – 스케치북 위치 스마트폰에 Blynk App 다운로드 하여 설치하기 아이폰 : 애플 앱스토어 안드로이드 : 구글 플레이스토어 버튼 위젯을 이용한 LED On/Off 하기Blynk 계정생성 및 Auth Token 받기 Blynk App 실행 Create New Account : 주로 사용하는 e-mail을 사용하여 계정 생성 Blynk에서 New Project 생성 아이폰용 MLT-BT05의 경우 Project Name 설정: BLE Test CHOOSE DEVICE: Arduino UNO CONNECTION TYPE: BLE 설정 후 Create 버튼 안드로이드용 HC-06의 경우 Project Name 설정: HC-06 Test CHOOSE DEVICE: Arduino UNO CONNECTION TYPE: Bluetooth 설정 후 Create 버튼 Auth Token 확인 가입시 지정한 이메일로 로그인하여 토큰 확인 (매우 복잡한 형태의) 토큰을 복사하여 코딩시 사용할 것이므로, 컴퓨터로 확인! 스마트폰으로 확인하는 것은 무의미함 Blynk 위젯 설정 아이폰용 MLT-BT05를 사용할 경우 생성된 프로젝트(BLE Test) 바탕화면으로 진입하면 Blynk App 상단의 초록색 메뉴바의 이름이 BLE Test로 바뀜 여기서 ⊕버튼 터치한 후 Button위젯과 BLE위젯 추가 추가된 BUTTON 위젯 선택 후 설정 OUTPUT: Select pin: Digital D13 / MODE: SWITCH 안드로이드용 HC-06를 사용할 경우 생성된 프로젝트(HC-06 Test) 바탕화면으로 진입하면 Blynk App 상단의 초록색 메뉴바의 이름이 HC-06 Test로 바뀜 여기서 ⊕버튼 터치한 후 Button위젯과 Bluetooth위젯 추가 추가된 BUTTON 위젯 선택 후 설정 OUTPUT: Select pin: Digital D13 / MODE: SWITCH Blynk 연결하기 아두이노 스케치 예제 불러오기 파일 – 예제 – Blynk – Boards_USB_Serial – Arduino_SoftwareSerial 선택 예제의 char auth[] = “YourAuthToken”; 부분을 찾아서 쌍따옴표 사이의 YourAuthToken을 지운 뒤, 이메일에서 복사한 AuthToken 붙여넣기 아두이노 UNO에 스케치 업로드 스마트폰의 블루투스 기능을 키고, 아이폰용 MLT-BT05의 경우 Bluetooth 모듈 설정에서 설정한 모듈ID 디바이스를 연결(예를 들어 MLT-BT05-T) (디폴트 연결PIN 123456) Blynk App에서 BLE버튼(블루투스 아이콘 모양) 터치 후 Connect BLE device 버튼을 누른 뒤, 연결할 디바이스 MLT-BT05-T를 찾은 후 OK버튼 누름 MLT-BT05-T connected 메시지가 나오면 연결 완료된 것임 안드로이드용 HC-06의 경우 Bluetooth 모듈 설정에서 설정한 모듈ID 디바이스를 연결(예를 들어 HC-06-T 디바이스를 연결 (디폴트 연결PIN 1234) Blynk App에서 Bluetooth버튼(블루투스 아이콘 모양) 터치 후 Connect Bluetooth device 버튼을 누른 뒤, 연결할 디바이스 HC-06-T를 찾은 후 OK버튼 누름 HC-06-T connected 메시지가 나오면 연결 완료된 것임 Blynk App 상단의 뒤로 돌아가기 버튼을 누른 뒤, App 오른쪽 상단의 ▷(플레이버튼)버튼을 누름 App상단에 빨간색 숫자1이 보이면 아직 연결이 되지 않았다는 것을 의미함 잠시 기다리면 빨간색 숫자1이 사라지고, 이 상태가 작동 준비가 완료된 것을 의미함 BUTTON 아이콘을 눌러 ON/OFF → 아두이노 Built-in LED ON/OFF Blynk App 오른쪽 상단의 □(정지버튼)을 누른 뒤, ⊕버튼 터치한 후 Text Input 위젯 추가 슬라이더 위젯을 이용한 LED 밝기 제어Built-in LED가 사용하는 13번핀은 PWM이 지원되지 않으므로, 11번핀을 사용한다. sketch아두이노 스케치는 그대로 사용 (위의 “Blynk 연결하기” 부분 스케치 참고) Blynk 앱 설정 버튼 위젯을 삭제: 버튼 위젯을 누르고 맨아래쪽으로 내려가서 Delete Slider 위젯 추가: OUTPUT D11 Slider 위젯의 위치/크기 조절: Slider 위젯 아이콘을 1초이상 누르면 위치/크기를 조절할 수 있음 (가로 크기를 최대로 늘림) App 오른쪽 상단의 ▷(플레이버튼)버튼을 누름 슬라이드를 조절하여 LED의 밝기 조절 확인 과제3색 RGB LED를 zeRGBa 위젯으로 조정하여 여러 가지 색깔 만들어보기 (스케치는 위의 스케치를 그대로 사용)","link":"/2019/10/20/Arduino-Bluetooth-Blynk/"},{"title":"Arduino, Bluetooth 페어링","text":"아두이노에서 블루투스를 이용하는 방법을 알아보겠습니다. Bluetooth module 선택 아이폰 : MLT-BT05(AT-09) BLE 모듈 사용 (이 모듈은 안드로이도에서도 사용 가능) HC-06, HC-05는 아이폰에서 SPP(Serial Port Profile) 통신이 지원하지 않는 이유로 사용할 수 없습니다. 그러므로 아이폰으로 블루투스 통신을 하기 위해서는 MLT-BT-BT05, AT-09, CC2541, HM-10, HC-02, RN-42 같은 BLE(Bluetooth Low Energy) 모듈을 사용합니다. 연결방법이나 AT명령어 세트는 HC-06과 비슷해요. 주의 할 점은, 시리얼 모니터에서 Both NL &amp; CR 모드를 선택해주어야 하는 것입니다. 안드로이드 : HC-06(or HC-05) 블루투스 모듈 사용 (이 모듈은 아이폰에서 사용 불가) ※ 요즘은 잘 사용하지 않지만, HC-05를 사용하기도 합니다. 생김새가 거의 비슷하지만, 몇가지 차이점이 있는데요. 보통 HC-06과 구별하기 위하여, HC-05에는 칩 위에 V형태로 체크를 해두거나, 화이트로 하얀색 점을 찍어두는 경우가 많습니다. 그리고, 가장 큰 차이점은 HC-05의 경우 6개의 핀이 모두 존재해요. ※ 예전에는 HC-05는 Master, HC-06은 Slave로 나누어 쓰는 경우가 많았지만, HC-06의 버전이 1.7이상인 경우 Master, Slave를 선택하여 사용할 수 있게 되면서 HC-05는 잘 사용하지 않게 되었습니다. MLT-BT05, HC-06을 사용하는 경우Pin Map Arduino Uno 1 STATE (실제 핀 없거나 미사용) 2 RXD Receive Data (수신) 3 3 TXD Transmit Data (송신) 2 4 GND GND GND 5 VCC +5V +5V 6 KEY (실제 핀 없거나 미사용) schematic sketch1234567891011121314151617181920#include &lt;SoftwareSerial.h&gt;SoftwareSerial BTSerial(2, 3); //Connect MLT-BT05 or HC-06 TX,RX void setup() { Serial.begin(9600); Serial.println(&quot;Hello!&quot;); // set the data rate for the BT port BTSerial.begin(9600); }void loop(){ if (BTSerial.available()) Serial.write(BTSerial.read()); if (Serial.available()) BTSerial.write(Serial.read());} HC-05를 사용하는 경우Pin Map HC-05 Pin Arduino Uno 1 STATE 2 RXD Receive Data 3 3 TXD Transmit Date 7 4 GND GND GND 5 VCC +5V +5V 6 KEY (ENABLE) AT command 진입을 위한 핀 8 ※ TXD로 UNO의 7번핀을 사용했으나, HC-06처럼 2번핀을 사용해도 됩니다. 단, schematic과 sketch도 2번 핀에 맞추어 수정해주세요. schematic sketch12345678910111213141516171819202122#include &lt;SoftwareSerial.h&gt;#define KEY 8SoftwareSerial BTSerial(7, 3); //Connect HC-05 TX,RX void setup() { pinMode(KEY, OUTPUT); //for HC-05 digitalWrite(KEY, HIGH); Serial.begin(9600); Serial.println(&quot;Hello!&quot;); // set the data rate for the BT port BTSerial.begin(38400); }void loop() { if (BTSerial.available()) Serial.write(BTSerial.read()); if (Serial.available()) BTSerial.write(Serial.read()); } 블루투스 모듈을 처음 사용하는 경우모듈을 처음 사용한다면, AT 명령어 세트를 사용하여 세팅을 해주어야 합니다. 또한 이전에 사용한 경험이 있더라도 블루투스 모듈ID, 페어링 암호 등을 새롭게 세팅할 필요가 있는 경우에도 동일합니다. MLT-BT05(AT-09)의 AT Command 명령어 Serial Monitor 출력 결과 의미 AT OK 접속상태 확인 AT+NAMESKS100 OKsetname 블루투스 모듈ID 지정 (default MLT-BT05) AT+PIN PASSWORD 출력 패스워드 확인 AT+PIN1234 OKsetPIN 페어링 암호 설정 (default: 123456) AT+BAUD4 OK9600 통신속도 설정 (4 → 9600bps) (default: 0 → 115200bps) AT+VERSION OKVERSION=4.0 MLT-BT05 버전 확인 AT+LADDR +LADDR=(MAC Address) MAC Address 확인 AT+ROLE=0 OK+ROLE:0 SLAVE mode (default) AT+ROLE=1 OK+ROLE:1 MASTER mode AT+ROLE=2 OK+ROLE:2 sensor mode AT+ROLE=3 OK+ROLE:3 iBeacon mode AT+ROLE=4 OK+ROLE:4 WeChat mode AT+ROLE OK+ROLE: Role 확인 ※ AT Command set 다운로드 HC-06의 AT Command 명령어 Serial Monitor 출력 결과 의미 AT OK 접속상태 확인 AT+NAMESKS100 OKsetname 블루투스 모듈ID 지정 (SKS100) AT+PIN PASSWORD출력 패스워드 확인 AT+PIN1234 OKsetPIN 페어링 암호 설정 (default: 1234) AT+BAUD4 OK9600 통신속도 설정 (4 → 9600bps) (default: 4 → 9600bps) AT+VERSION OKlinvorV1.8 HC-06 버전 확인 AT+ROLE=S OK+ROLE:S SLAVE 역할 AT+ROLE=M OK+ROLE:M MASTER 역할 (v1.7 이상만 가능) AT+ROLE OK+ROLE: MASTER/SLAVE 확인 HC-05의 AT Command ※ HC-05는 AT Command를 사용하는 경우, KEY(Enable) 핀을 연결해주어야 합니다. (schematic 참고) 명령어 Serial Monitor 출력 결과 의미 AT OK 접속상태 확인 AT+NAMESKS100 OKsetname 블루투스 모듈ID 지정 (SKS100) AT+PSWD=0000 OKsetPIN 페어링 암호 설정 (0000) AT+BAUD6 OK9600 통신속도 설정 (6 → 38400bps) AT+VERSION OKlinvorV1.8 HC-06 버전 확인 AT+ROLE=0 OK+ROLE:0 SLAVE 역할 AT+ROLE=1 OK+ROLE:1 MASTER 역할 AT+ROLE=? OK+ROLE: MASTER/SLAVE 확인 스마트폰과의 페어링 과정시리얼모니터에서HC-06과의 페어링 과정을 보도록 하겠습니다. (다른 블루투스 모듈도 유사하게 진행하면 됩니다.) 먼저 아두이노IDE의 시리얼 모니터를 엽니다. ※ 이때, 주의할 점이 있는데요. 시리얼 모니터를 열기 전에 스마트폰과 HC-06의 블루투스 연결은 해제된 상태여야 합니다. 기존에 HC-06과 스마트폰을 연결한 적이 있다면, 자기도 모르게 블루투스 연결이 자동으로 되어 있을 수 있는데요. 이런 경우에는 시리얼 모니터가 열리지 않아요. MLT-BT05: 시리얼모니터의 하단에 “Both NL &amp; CR”, “9600 보드레이트” 선택 HC-06: 시리얼창의 하단에 “line ending 없음”, “9600 보드레이트 선택 HC-05: 시리얼창의 하단에 “Both NL &amp; CR”, “9600 보드레이트” 선택 위 스케치를 사용하는 모듈에 맞게 선택하여 아두이노에 업로드 한 상태에서 시리얼 모니터를 열면, Hello! 라는 글자가 뜹니다. (업로드한 스케치에 따라 Hello!는 안나올 수도 있음) AT를 입력하고, 전송을 누르면 OK가 뜹니다. 이것은 아두이노IDE를 통해 블루투스 모듈과 연결이 정상적으로 되었음을 의미해요. 블루투스 모듈ID를 설정해보겠습니다. SKS100이라는 ID로 지정하기 위해 AT+NAMESKS100이라고 입력한 뒤, 전송을 누릅니다. (모듈ID는 본인이 사용할 이름으로 바꾸어 지정합니다.) 그러면 OKsetname이라고 출력이 되면서, 블루투스 모듈ID가 SKS100으로 셋팅이 됩니다. 이번에는 페어링 암호 설정입니다. AT+PIN0000을 입력하고 전송을 누르면 OKsetPIN이 출력되면서 페어링 암호가 0000으로 설정됩니다. 통신속도 설정입니다. HC-06은 주로 9600bps를 사용하며, 이를 위해 AT+BAUD4를 입력한 뒤 전송을 누릅니다. (HC-06의 경우 default 속도가 9600bps이므로 이 과정은 생략 가능하며, 다른 모듈을 사용하는 경우에는 각 모듈의 AT Command를 확인하여 통신속도를 변경해주어야 합니다.) OK9600이 출력되요. 여기까지 진행하면 대체적으로 HC-06을 사용할 준비가 된 것입니다. 스마트폰에서 이제 스마트폰에서 블루투스 모드를 켜세요. (아래 화면은 스마트폰 기종마다 조금은 다를 수 있습니다. 화면이 다르더라도 거의 비슷할 거에요.) 그리고 새로고침을 통해 블루투스 기기를 찾습니다. ‘거의 이용하지 않는 기기’ 하나를 찾았네요. 그곳을 누르면 조금전에 설정한 블루투스 모듈ID인 SKS100이 보입니다. 여기를 누르세요. 블루투스 모듈과 페어링을 하기 위한 암호 입력화면이 나오고, 여기에 AT명령어를 통해 입력한 암호를 넣어줍니다. 그러면 스마트폰이 SKS100 모듈에 페어링을 시도합니다. 거의 이용하지 않는 블루투스 기기 부분을 누르면 페어링된 기기 목록에 SKS100이 뜹니다. 여기까지 진행하면, 스마트폰과 블루투스 모듈이 페어링 완료된 거에요.","link":"/2019/10/26/Arduino-Bluetooth-%ED%8E%98%EC%96%B4%EB%A7%81/"},{"title":"Arduino, Geiger Counter","text":"※ SAT Subject Chemistry: Pactice Test 123456Used to detect radioactivity.① Calorimeter② Geiger Counter③ Burette④ Funnel⑤ Bunsen Burner 가이거 계수기 방사선을 측정할 수 있는 관으로 방사능 입자 하나하나를 셀 수 있다. 1908년 러더퍼드의 제자 요하네스 한스 빌헬름 가이거(Johannes Hans Wilhelm Geiger)가 알파선을 감지할 수 있는 감지기를 개발하였으며, 그 후 1928년 가이거와 가이거의 제자인 발터 뮐러가 함께 개량하여 모든 전리방사선을 감지할 수 있도록 만든 것이 현재의 가이거-뮐러 튜브(GM Tube)이다. 원리: 튜브는 비활성 기체가 충전된 상태이며 중심 전극(+극, anode)과 관의 내벽(-극, cathode, 금속이나 흑연으로 코팅)으로 구성되어 있다. 여기에 수백V의 전압을 걸면, 관 안에 걸린 높은 전기장 때문에 이온은 음극을 향해 가속되고, 전자는 양극을 향해 가속되며 운동에너지를 얻게 되며 이동 중에 충돌한 기체분자도 함께 전이된다. 이렇게 가스 안에 하전입자의 붕괴가 일어나면 음극에서 양극을 향해 짧고 강한 펄스전류가 순간적으로 나타나 흐르게 된다. 이 펄스전류가 ‘스피커’를 지날때 반응음으로 가이거 계수기 특유의 ‘틱티티틱’하는 소리가 만들어지는데, 이것이 ‘방사선이 존재한다’는 상황을 알려주는 소리이다. 그리고 이 소리 1개음이 방사능 입자 1개에 대한 대응 신호가 된다. 오래된 방식이지만 오늘날에도 큰 변화 없이 이 원리를 응용하여 방사선을 측정하고 있다. 단점: 상당히 큰 펄스신호를 얻을 수 있지만, 이 전류의 강도는 방사선이 가진 에너지와 비례관계를 나타내는 것은 아니기때문에, 방사선이 가진 에너지를 측정하는 것은 불가능하다. (방사선의 에너지를 알기 위해서는 비례계수관을 사용해야 한다.) 또한 고준위 방사선의 경우에는 전류가 연속적으로 흐르게 되어 펄스의 횟수를 계수할 수 없게 되는 경우도 있다. (주로 500cps 이상의 경우) 이것을 막기 위해 전자의 흐름을 제어하는 별도의 장치를 부착하거나, 신틸레이터(scintillator)나 이온화 챔버 같은 다른 검출기로 계측한다. 가이거 카운터에 사용하는 튜브관은 여러 종류가 제조되고 있다. 대부분의 GM관은 감마선과 2.5MeV 이상의 베타선을 검출한다. 감마선의 검출 감도는 좋지는 않다. GM관 안의 가스밀도가 낮아서, 투과력이 높은 감마선은 상호작용을 일으키기 어렵기 때문이다. 중성자선은 가스로부터 전리하지 않기때문에 검출하지 못한다. 하지만, 관 안쪽을 붕소로 코팅하거나, 삼불화붕소 아니면 ³He가스를 충전하면 중성자선에도 반응하는 GM관을 만들 수 있다. 중성자는 붕소원자핵과 반응하여 알파선을 생성하거나, ³He원자와 반응하여 수소와 트리튬이온과 전자를 생성하므로 이 전하입자들이 붕괴를 발생시킨다. 각 튜브마다 검출하는 입자가 다르기 때문에, CPM(Count Per Minute) 단위를 uSv/h(Sieverts Per Hours) 단위로 바꾸기 위한 Conversion Factor가 모두 다르다. 그러므로 사용하는 튜브관이 어떤 것인지 정확하게 알아두어야 한다. GM관은 하드웨어 난수발생기로서 이용할 수도 있다. Background Radiation: 자연적으로 존재하는 자연 방사선, 즉 Background Radiation의 경우 J305β 튜브관을 사용할때 평균 15.6 CPM이 측정된다. (주변 상황에 따라 조금씩 달라짐) 라이브러리 추가하기 Wire : 기본 내장 라이브러리 LiquidCrystal I2C (by Frank de Brabander) 검색하여 설치 schematic (for standalone) GM Monule GND 5V VIN Arduino GND 5V D2 VIN A4 A5 PowerJack 1602 LCD I2C GND VCC (VCC) SDA SCL 9V battery (+)(-) 외부로 들고 다니면서 측정할 수 있도록 9V 배터리 1개를 추가하여 Arduino, 1602 LCD, GM Molule을 모두 작동시킬 수 있도록 하였다. sketch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* --------------------------------------------------------------------------------------* WHAT IS CPM?* CPM (counts per minute) is events quantity from Geiger Tube you get during one minute.* Usually it used to calculate a radiation level. * Different GM Tubes has different quantity of CPM for background.* Some tubes can produce about 10-50 CPM for normal background,* other GM Tube models produce 50-100 CPM or 0-5 CPM for same radiation level.* Please refer your GM Tube datasheet for more information. * Just for reference here, SBM-20 can generate about 10-50 CPM for normal background.* --------------------------------------------------------------------------------------*/// This Sketch counts the number of pulses a minute.// Connect the GND on Arduino to the GND on the Geiger counter.// Connect the 5V on Arduino to the 5V on the Geiger counter.// Connect the VIN on the Geiger counter to the D2 on Arduino.// For I2C 1602 LCD : VCC-5V / GND-GND / SDA-A4 / SCL-A5#include &lt;Wire.h&gt;#include &lt;LiquidCrystal_I2C.h&gt;// I2C address: 0x20~0x27 or 0x3FLiquidCrystal_I2C lcd(0x27, 16, 2); int cpm;float sievertshour; // for converting from cpm to sieverts/hour//float sieverts; // for converting from cpm to sieverts unsigned long counts; //variable for GM Tube eventsunsigned long previousMillis; //variable for measuring time#define LOG_PERIOD 60000 // count rate (1 minute)#define CONV_FACTOR 0.008120 // for GM tube of J305beta typevoid setup() { //setup counts = 0; Serial.begin(9600); pinMode(2, INPUT); lcd.init(); // lcd 초기화 lcd.backlight(); attachInterrupt(digitalPinToInterrupt(2), impulse, FALLING); //define external interrupts}void loop() { lcd.setCursor(0,0); lcd.print(&quot;CPM:&quot;); lcd.setCursor(9,0); lcd.print(&quot; #:&quot;); lcd.setCursor(12,0); lcd.print(counts); lcd.setCursor(0,1); lcd.print(&quot;uSv/h:&quot;); //lcd.print(&quot;uSv :&quot;); unsigned long currentMillis = millis(); if (currentMillis - previousMillis &gt; LOG_PERIOD) { //every 1 minute previousMillis = currentMillis; lcd.clear(); lcd.setCursor(5, 0); cpm = counts; lcd.print(cpm); //Display CPM Serial.println(cpm); sievertshour = cpm * CONV_FACTOR; //sieverts = sievertshour * 356 * 24; lcd.setCursor(7,1); lcd.print(sievertshour); //lcd.print(sieverts); counts = 0; }}void impulse() { // called every time there is a FALLING signal at pin 2 counts++;} sketch : for ESP8266 (Geigerzaehler-LCD-ESP.ino)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*************ARDUINO SKETCH FOR GEIGER COUNTER******************Author: RH Electronics www.radiohobbystore.com / www.mygeiger.org*****************************************************************This sketch can be used with DIY Geiger Counter board. It allowto receive CPM data during minute. You can modify the sketchfor your needs.*****************************************************************LCD I2C Connection:LCD SDA -&gt; D10 = 1LCD SCL -&gt; D9 = 3VCC to +3,3V and ground****************************************************************/// include the library code:#include &lt;LiquidCrystal_I2C.h&gt;#include &lt;SPI.h&gt;#include &lt;Wire.h&gt;#define LOG_PERIOD 15000 //Logging period in milliseconds, recommended value 15000-60000.#define MAX_PERIOD 60000 //Maximum logging period without modifying this sketch#define PERIOD 60000.0 // (60 sec) one minute measure periodvolatile unsigned long CNT; // variable for counting interrupts from dosimeterunsigned long counts; //variable for GM Tube eventsunsigned long cpm; //variable for CPMunsigned int multiplier; //variable for calculation CPM in this sketchunsigned long previousMillis; //variable for time measurementunsigned long dispPeriod; // variable for measuring timeunsigned long CPM; // variable for measuring CPMconst int inputPin = 4; // pin D2 is VIN on geiger counter// initialize the library with the numbers of the interface pinsLiquidCrystal_I2C lcd(0x3F,20,4);void setup() { // setupWire.begin(1,3);lcd.begin(20, 4);lcd.init();// Turn on the backlight.lcd.backlight();CNT = 0;CPM = 0;dispPeriod = 0;attachInterrupt(digitalPinToInterrupt(inputPin), GetEvent, FALLING); // Define interrupt D2 on falling edge}void loop() { // main looplcd.setCursor(0,0);lcd.print(&quot;Berlin-Siemensstadt&quot;);lcd.setCursor(0,1);lcd.print(&quot; Geiger Counter &quot;);lcd.setCursor(0,2); // print text and CNT on the LCDlcd.print(&quot;CPM:&quot;);lcd.setCursor(0,3);lcd.print(&quot;CNT:&quot;);lcd.setCursor(5,3);lcd.print(CNT);if (millis() &gt;=dispPeriod + PERIOD) { // If one minute is overcleanDisplay(); // Clear LCD// Do something about accumulated CNT events....lcd.setCursor(5, 2);CPM = CNT;lcd.print(CPM); //Display CPMCNT = 0;dispPeriod = millis();}}void GetEvent(){ // Get Event from DeviceCNT++;}void cleanDisplay (){ // Clear LCD routinelcd.clear();lcd.setCursor(0,0);lcd.setCursor(0,0);} (출처: rhelectronics.net) Conversion Index &amp; Background RadiationCPM값은 사용하는 GM tube의 종류에 따라 다르게 측정된다. 왜냐하면, GM tube의 종류에 따라 감지할 수 있는 방사능의 종류가 다르기 때문이다. 그러므로 제조회사에서 제공하는 Conversion Index 값을 사용하여 CPM값을 Sieverts 단위로 바꿔주어야 한다. 예를들어, 위 sketch에서 사용한 J305β tube관은 CONV_FACTOR값이 0.008120이다. 이 값의 유도과정은 다음과 같다. 제조사에서 제공하는 J305β 스펙 : 65 cps/µR/s for 60Co (cps: count per second, µR = microRem) 이것은 1µR/s = 65cps 임을 뜻한다. (즉 1mR/s = 65000cps) 1mR/h = 65000cps / (60 × 60) = 18.06cps 18 cps/mR/h = 18 × 60 cpm/mR/h = 1080 / 8.77 cpm/µSv/h = 123.14 cpm/µSv/h (※1mR = 8.77μSv) ∴ Conversion Index = 123.14 123CPM = 1μSv/h → 1CPM = 0.008120 μSv/h ∴ CONV_FACTOR = 0.008120 CPM × CONV_FACTOR = μSv/h 이 CONV_FACTOR값에 24*365를 곱하면 Sv 단위의 값을 만들어 낼 수도 있다. 만일 어떤 지역에서 J305β tube를 사용하여 측정한 CPM값이 20이라면, 20×0.008120 = 0.1624μSv/h 에 해당하는 방사선이 검출되는 것이며 이는 0.1624 × 24 × 365 = 1422.6 μSv를 뜻한다. 방사능 생활척도를 통해 일반적인 배경복사보다는 다소 낮은 수준이라는 것을 알 수 있다. tube Conversion Index CONV_FACTOR Background Radiation (CPM) J305β 123.14 0.008120 15.6 SBM-20 175.4 0.0057 23.4 M4011 153.8 0.006502 LDN-712 0.01 방사능 생활척도밀리시버트(mSv)는 X선, PET, CT 등과 같은 의료 검진시 발생하는 유효 노출을 측정하는 경우 사용된다. 일상생활에서 노출되는 방사선량은 다음과 같다. (출처: 위키피디아) 10 μSv – 오늘받은 평균 방사선 0.02 ~ 0.04 mSv = 20 ~ 40 μSv – 흉부 X-레이 40 μSv – 뉴욕에서 L.A.까지 비행기를 타면받는 방사선 100 μSv – 치과 용 X- 레이 동안받는 방사선 0.24 mSv – 해수면에 도달하는 우주입자선 (연간) 0.28 mSv – 지하로부터 나오는 지상 방사선 (연간) 800 μSv – 사고 기간 동안 Three-Mile Island의 총 방사선 량 2 mSv – 미국 가정의 연 평균 라돈 방사선 양 3000 μSv – 유방 조영술의 방사선 량 3650 μSv (= 10 μSv per day = 0.081 μSv/h) = 2.5 ~ 3.5 mSv – 일반적인 배경복사 (장소에 따른 편차가 큼) ​ ※ 호주 1.5 mSv, 미국 3 mSv, 이란, 인도, 유럽의 연간 배경 방사선 양 : 50 mSv 0.8 ~ 5 mSv – 뇌 CT 스캔 6 ~ 18 mSv – 흉부 CT 스캔 6.2 mSv – 미국인 연 평균 방사선 노출량 9 mSv – 뉴욕-동경간 항공 승무원이 받는 연간 방사선 양 14 mSv – 내장기관 X-레이 20 mSv – 핵관련 종사자 연간 허용치 50000 μSv – 연간 최대 허용 직업 선량 ​ ※ 시간당 최대 방사능 = 50000 μSv / (24 * 365) = 5.70 μSv/h 100000 μSv – 암 위험 증가와 관련이 있을 가능성이 높은 연간 최저 용량 80~160 mSv – 하루 담배 1.5갑씩 1년을 필 때 350 mSv – 체르노빌 사태 후 이주를 결정한 근거 (매년) 1 Sv = 1000000 μSv – 약간의 혈액 변화 유발 2 Sv = 2000000 μSv – 심각한 방사선 중독 (때로는 치명적) 2 ~ 5 Sv = 2000000 ~ 5000000 μSv – 메스꺼움, 탈모, 출혈을 유발, 많은 경우 사망 6 Sv = 6000000 μSv – 2개월 이내에 80% 이상 사망 Radiation Cartooon Electrical Information for GM Tubes Tube Working Voltages Nominal Voltahe Anode Resisor Dead Time μs Detection SBM-20 350 ~ 450V 400V 4M7 100 ~ 190 β, γ SBM-19 “ “ 4M7 125 ~ 250 β, γ SBT-10 “ “ 4M7 65 β, γ SI29BG “ “ 4M7 95 β, γ SI21BG “ “ 10M 30 β, γ SBT-9 “ 380V 4M7 50 ~ 100 α, β, γ SBT-11A “ 390V 3M3 ~ 4M7 75 α, β, γ SI-22G “ 400V 10M γ SI180G “ “ 4M7 γ LND-712 450 ~ 650V 500V 10M 90 α, β, γ LND-7317 475 ~ 675V “ 4M7 40 α, β, γ Philips 18504 425 ~ 675V “ 10M 100 α, β, γ, n (출처: rhelectronics.net)","link":"/2020/08/23/Arduino-Geiger-Counter/"},{"title":"Arduino, IR 리모컨","text":"생활속에서 가장 밀접하게 쓰이는 IR(Infra Red, 적외선) 리모컨의 사용에 대해서 알아본다. 리모컨 작동을 위해서는 기본적으로 IR 신호를 내보내는 리모컨본체와 이 본체에서 내보내는 신호를 받아들이는 IR 리시버가 필요하다. 기본 사용법schematic 위 그림에서 IR 리시버에 있는 핀은, IR모듈이 아닌 단일 부품형태의 리시버 일때 핀의 순서이다. IR 리시버 모듈을 사용하는 경우아두이노 학습용으로 판매하는 IR 리시버는 브레드보드에 바로 붙일 수 있도록 조그만 PCB가 달린 모듈의 형태로 판매되는 경우가 많으며, 이 경우에는 PCB보드에 써있는 글씨를 보고 각 핀에 맞게 아두이노에 연결해야한다. 문제는 PCB에 어느 핀인지를 나타내는 글자가 잘 안보인다는 것! Signal : PCB에 S라고 표기되어 있는 쪽 VCC : 대부분 가운데에 있는 경우가 많았음 GND : S라고 표기된 부분의 반대쪽이라고 생각하면 된다. (-) 마이너스 표기가 작게 되어 있음 Pin Map Arduino IR Reciever 모듈 사용시 IR Reciever 단일부품 2 S (Signal) (둥근 모양을 마주보고) 왼쪽 5V 표기 되어 있지 않음 (둥근 모양을 마주보고) 오른쪽 GND - (둥근 모양을 마주보고) 가운데 라이브러리 준비하기 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; 라이브러리 매니저 검색어 irremote 입력 “IRremote by Armin Joachimsmeyer” 라이브러리 설치/업데이트 스케치&gt; 라이브러리 포함하기&gt; IRremote 를 선택하면, IR remote 기능을 사용하는데 필요한 라이브러리가 스케치에 include 된다. 1#include &lt;IRremote.h&gt; 리모컨 버튼의 고유값 알아내기 old MSB-first 32bit IR data code new LSB-first 32bit IR data code 리모컨 코드값은 위의 2가지 형태로 구분된다. 여기서는 기본적으로 MSB-first 방식을 사용하도록 한다. 아래 스케치를 이용하면 간단하게 MSB-first code 값만 출력된다. (시리얼 모니터 Baudrate 115200) sketch1234567891011121314151617181920#include &lt;IRremote.h&gt;int RECV_PIN = 2; // IR 리시버 핀 설정IRrecv irrecv(RECV_PIN); // IR 리시버 선언decode_results results; // 수신결과 저장void setup() { Serial.begin(115200); irrecv.enableIRIn(); // IR 리시버 시작}void loop() { if(irrecv.decode(&amp;results)) { // 리시버가 받은 값이 있으면 Serial.print(&quot;0x&quot;); Serial.println(results.value, HEX); // 버튼 HEX값을 콘솔에 출력 delay(500); irrecv.resume(); // 다음 값을 받기 위해 준비 }} serial monitor 출력값 중에서 앞부분의 0x를 제외한 6자리의 값(아래 그림에서 FFA25D)이 방금 누른 버튼의 고유 값이다. 리모컨 고유값보유하고 있는 리모컨(XA5-14) 제품의 경우, 리모컨 타입은 NEC타입이며 각 버튼별 HEX값은 아래와 같다. Remote Button unsigned int data 1 0xFFA25D 2 0XFF629D 3 0XFFE21D 4 0XFF22DD 5 0XFF02FD 6 0XFFC23D 7 0XFFE01F 8 0XFFA857 9 0XFF906F 0 0XFF9867 * 0XFF6897 # 0XFFB04F ▲ 0XFF18E7 ▼ 0XFFA4B5 ◀ 0XFF10EF ▶ 0XFF5AA5 OK 0XFF38C7 리모컨 버튼값 시리얼모니터에 출력하기스케치에서 리모컨 버튼 정의하기각 버튼의 Code값을 알아냈으면 스케치에서 리모컨의 버튼을 정의한다. 예를 들어, 리모컨 버튼 중에서 “1”을 눌렀을 때, 출력되는 HEX값이 “0xFFA25D” 였다면, 1#define BTN_1 0xFFA25D 리모컨에 있는 모든 버튼을 위와 같은 방법으로 정의한다. 버튼이 보통 10~20개 정도 되므로 상당히 귀찮은 작업이지만 사용하려는 버튼은 모두 정의를 해야한다. 배열을 통해 정의할 수도 있다. 또한 별도의 리모컨이 없으면 집에서 사용하는 리모컨을 사용해도 된다. sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;IRremote.h&gt;#include &lt;ir_Lego_PF_BitStreamEncoder.h&gt;#define BTN_CH_M 0xFF6897 // CH- Button#define BTN_CH 0xFFB04F // CH Button#define BTN_CH_P 0xFF18E7 // CH+ Button#define BTN_PREV 0xFF4AB5 // PREV Button#define BTN_NEXT 0xFF10EF // NEXT Button#define BTN_PLAY_PAUSE 0xFF5AA5 // PLAY PAUSE Button#define BTN_M 0xFF38C7 // - (VOL-) Button#define BTN_P 0xFF38C8 // + (VOL+) Button#define BTN_EQ 0xFF38C9 // EQ Button#define BTN_100P 0xFF38CA // 100+ Button#define BTN_200P 0xFF38CB // 100- Button#define BTN_0 0xFF9867#define BTN_1 0xFFA25D#define BTN_2 0xFF629D#define BTN_3 0xFFE21D#define BTN_4 0xFF22DD#define BTN_5 0xFF02FD#define BTN_6 0xFFC23D#define BTN_7 0xFFE01F#define BTN_8 0xFFA857#define BTN_9 0xFF906Fint recvPin = 2;IRrecv irrecv(recvPin);void setup() { Serial.begin(9600); irrecv.enableIRIn();}void loop() { decode_results results; if(irrecv.decode(&amp;results)) { switch(results.value) { case BTN_CH_M : Serial.println(&quot;CH-&quot;); break; case BTN_CH : Serial.println(&quot;CH&quot;); break; case BTN_CH_P : Serial.println(&quot;CH+&quot;); break; case BTN_PREV : Serial.println(&quot;PREV&quot;); break; case BTN_NEXT : Serial.println(&quot;NEXT&quot;); break; case BTN_PLAY_PAUSE : Serial.println(&quot;PLAY/PAUSE&quot;); break; case BTN_M : Serial.println(&quot;-&quot;); break; case BTN_P : Serial.println(&quot;+&quot;); break; case BTN_EQ : Serial.println(&quot;EQ&quot;); break; case BTN_100P : Serial.println(&quot;100+&quot;); break; case BTN_200P : Serial.println(&quot;200+&quot;); break; case BTN_0 : Serial.println(&quot;0&quot;); break; case BTN_1 : Serial.println(&quot;1&quot;); break; case BTN_2 : Serial.println(&quot;2&quot;); break; case BTN_3 : Serial.println(&quot;3&quot;); break; case BTN_4 : Serial.println(&quot;4&quot;); break; case BTN_5 : Serial.println(&quot;5&quot;); break; case BTN_6 : Serial.println(&quot;6&quot;); break; case BTN_7 : Serial.println(&quot;7&quot;); break; case BTN_8 : Serial.println(&quot;8&quot;); break; case BTN_9 : Serial.println(&quot;9&quot;); break; } delay(500); irrecv.resume(); }} 과제: 리모컨 계산기 만들기 리모컨으로 서보모터 회전시키기3개의 리모컨 버튼을 정의하여 각 버튼을 통해 서버모터를 회전시켜 본다. 초기 위치 90도 Left 버튼을 누르면 5도 감소 Right 버튼을 누르면 5도 증가 OK 버튼을 누르면 90도 위치로 이동 schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;Servo.h&gt;Servo servomotor;int servomotorPin = 9;int a = 90;#include &lt;IRremote.h&gt;#include &lt;ir_Lego_PF_BitStreamEncoder.h&gt;#define BTN_1 0xFFA25D#define BTN_2 0xFF629D#define BTN_3 0xFFE21D#define BTN_4 0xFF22DD#define BTN_5 0xFF02FD#define BTN_6 0xFFC23D#define BTN_7 0xFFE01F#define BTN_8 0xFFA857#define BTN_9 0xFF906F#define BTN_0 0xFF9867#define BTN_A 0xFF6897 // * Asterisk Button#define BTN_P 0xFFB04F // # Pound Button#define BTN_U 0xFF18E7 // Up Button#define BTN_D 0xFF4AB5 // Down Button#define BTN_L 0xFF10EF // Left Button#define BTN_R 0xFF5AA5 // Right Button#define BTN_O 0xFF38C7 // OK Buttonint recvPin = 2; // IR signal 핀IRrecv irrecv(recvPin);void setup() { servomotor.attach(servomotorPin); irrecv.enableIRIn();}void loop() { decode_results results; if(irrecv.decode(&amp;results)) { switch(results.value) { case BTN_O : // OK버튼을 누르면 90도 위치로 a = 90; break; case BTN_L : if(a &gt; 5) { a = a - 5; // L버튼을 누르면 서버모터 5도씩 감소 } else { a = 0; } break; case BTN_R : if(a &lt; 175) { a = a + 5; // R버튼을 누르면 서버모터 5도씩 증가 } else { a = 180; } break; } servomotor.write(a); delay(500); irrecv.resume(); }} LSB-first 32bit IR data code를 사용하려면LSB-first 형태의 디코더 데이터를 사용해야하는 경우에는 라이브러리에서 제공하는 설명서(IRremote: IRremote Arduino Library)를 우선 숙지하여 사용토록한다. 여기서는 간단한 사용방법만 덧붙인다. 예제&gt; IRremote&gt; SimpleReceiver를 선택하여 파일을 불러온다. SimpleReceiver.ino의 앞부분에, 사용하려는 리모컨의 프로토콜 타입을 선택할 수 있는 부분이 있다. 아두이노 실습용으로 판매되는 리모컨은 대부분 NEC타입이므로 변경할 필요가 없다. 삼성이나 LG 등 집에서 사용하는 리모컨의 HEX값을 알아내려면, 사용하려는 제품의 제조사에 따라 주석처리되는 부분을 적절히 수정한다. SimpleReceiver.ino123456789101112131415161718//#define DECODE_DENON // Includes Sharp//#define DECODE_JVC//#define DECODE_KASEIKYO//#define DECODE_PANASONIC // the same as DECODE_KASEIKYO//#define DECODE_LG#define DECODE_NEC // Includes Apple and Onkyo//#define DECODE_SAMSUNG//#define DECODE_SONY//#define DECODE_RC5//#define DECODE_RC6//#define DECODE_BOSEWAVE//#define DECODE_LEGO_PF//#define DECODE_MAGIQUEST//#define DECODE_WHYNTER//#define DECODE_DISTANCE // universal decoder for pulse width or pulse distance protocols//#define DECODE_HASH // special decoder for all protocols SimpleReceiver을 열면 PinDefinitionsAndMore.h가 동시에 열린다. 이 파일은 사용하는 보드에 따라 Signal핀을 연결하는 핀 번호를 정의하고 있다. 아두이노 UNO의 경우 DEFAULT/AVR 플랫폼으로 정의되어 있으므로 IR Input핀은 2번을 사용한다. (아래 3번과정 참고: 시리얼 모니터를 열면, 연결된 보드에 따라 몇번 핀에 연결해야하는지 출력이 되므로, 이 과정에서 Signal을 어디에 연결해야하는지 확인할 필요는 없다.) ESP32의 경우 IR Input이 GPIO 15번으로 지정되어 있다. 스케치를 업로드 한 후, 시리얼 모니터를 열고 Baud rate를 115200으로 설정한다. (Signal이 연결된 핀의 번호가 맞는지 확인) 리모컨의 버튼을 IR수신부를 향하여 누르면, 3줄이 출력됨 첫번째 라인에 출력되는 Raw-Data 부분에서 앞부분의 0x를 제외한 8자리의 값(아래 그림에서 BA45FF00)이 방금 누른 버튼의 고유 값이다. 각 버튼을 차례대로 누르면서 버튼의 고유값을 기록한다. 다운로드","link":"/2018/09/06/Arduino-IR-%EB%A6%AC%EB%AA%A8%EC%BB%A8/"},{"title":"Arduino, 피에조 부저","text":"Buzzer의 종류 Active Buzzer (능동형 부저) Passive Buzzer (수동형 부저) 有源蜂鸣器 (KY-012) 无源蜂鸣器 (KY-006) 회로가 내장되어 있어, 전원만 인가하면 소리가 나므로 프로그램 제어가 편리함 내부에 진동원이 없어, 스케치에 주파수를 지정하여야만 소리를 냄 원하는 주파수의 소리를 낼 수 없음 원하는 주파수의 소리를 만들어낼 수 있음 패시브 부저에 비해 비쌈 (모듈 1개 0.9위안) 액티브 부저에 비해 저렴 (모듈 1개 0.8위안) 모듈로 판매하는 제품의 경우 겉모양으로는 구별이 어렵다. Active Buzzer의 경우 초기 판매시 스티커를 붙여서 판매하지만, 스티커가 떨어져 나간 상태라면 Passive Buzzer와 구별하기 어렵다. 또한 반드시 스티커가 붙은 형태로 판매하는 것도 아니다. Active Buzzer의 경우 스티커로 사용전압을 표시하기도 한다. 빨간색은 3V, 파란색은 5V, 보라색은 12V용이다. Active Buzzer 모듈의 경우 低电平触发(혹은 Low Level) / 高电平触发(혹은 High Level) 2가지 형태로 표기가 되어 있다. 低电平触发은 DigitalWrite에서 HIGH일 때 소리가 나며, 高电平触发은 LOW일 때 소리가 난다. 모듈 형태가 아닌 단일 부품의 형태라면 연결 핀이 나와 있는 아랫면을 보면 구별할 수 있다. 일반적으로 Active Buzzer는 검은색 실리콘으로 밀폐되어 있으며, Passive Buzzer는 핀의 접합부위가 그대로 노출되어 있다. Active Buzzer와 Passive Buzzer를 구별하는 가장 좋은 방법은 사용전압에 해당하는 전압(낮은 전압의 건전지도 가능)의 건전지를 연결시켜보는 것이다. 소리가 나면 Active, 나지 않으면 Passive라고 생각하면 된다. Active Buzzerschematic sketch12345678910void setup () { pinMode (11, OUTPUT); // 11번 핀을 출력으로 설정}void loop () { digitalWrite (11, HIGH); // 11번 핀 부저 ON delay (1000); digitalWrite (11, LOW); // 11번 핀 부저 OFF delay (1000);} 과제tact 스위치를 누르면 액티브 부저 소리 울리기 Passive Buzzer 사용주파수 0옥타브(C0B0): 1631(Hz) (초저주파) 1옥타브(C1B1): 3362(Hz) 2옥타브(C2B2): 65123(Hz) 중저음 3옥타브(C3B3): 131247(Hz) 기본 음계에 해당하는 옥타브 4옥타브(C4B4): 262494(Hz) 일반적으로 고음이라고 불리는 영역 일반적인 남자의 경우 G4~B4음이 최고음 음악의 기준음인 **가온 라(A4)(440Hz)**가 속한 영역 5옥타브(C5B5): 523988(Hz) 일반적인 여성의 경우 D5의 음까지는 낼 수 있고, 고음을 잘 내는 경우 E5까지는 무난함 6옥타브(C6B6): 10471976(Hz) 7옥타브(C7B7): 20933951(Hz) 8옥타브(C8B8): 41867902(Hz) 9옥타브(C9B9): 837215804(Hz) 10옥타브(C10B10): 1674431608(Hz) (초음파) 한 옥타브 내려가면 주파수가 1/2배, 올라가면 2배가 되고, 한 음계 올라가면 2^(1/12) 배가 된다. 0옥타브 중간쯤(20Hz)부터나, 10옥타브 중간쯤(20kHz)부터는 소리가 들리지 않는다. 사람의 가청 영역을 벗어나기 때문. 이를 각각 초저주파, 초음파라고 한다. 어릴 수록 고음이 잘 들리기 때문에, “선생님은 못 듣는 벨소리”같은 것을 만들수 있다. 0 1 2 3 4 5 6 7 8 C(도) 16 33 65 131 262 523 1046.5 2093 4186 C♯ 17 35 69 139 277 554 1109 2217.5 4435 D(레) 18 37 73 147 294 587 1175 2349 4699 D♯ 20 39 78 156 311 622 1244.5 2489 4978 E(미) 21 41 82 165 330 659 1318.5 2637 5274 F(파) 22 44 87 175 349 698.5 1397 2794 5588 F♯ 23 46 92.5 185 370 740 1480 2960 5920 G(솔) 25 49 98 196 392 784 1568 3136 6272 G♯ 26 52 104 208 415 831 1661 3322.5 6645 A(라) 28 55 110 220 440 880 1760 3520 7040 A♯ 29 58 116.5 233 466 932 1865 3729 7459 B(시) 31 62 123.5 247 494 988 1975.5 3951 7902 Pin Map Arduino Active Buzzer Passive Buzzer 11 S S 5V 표기없음 표기없음 GND (-) (-) sketch : Passive Buzzertone() 사용방법 tone 함수는 3개의 매개변수(핀, 주파수, 음길이)를 사용하며, 마지막 매개변수(음길이)는 생략 가능하다. 1tone(11, 262, 500); // 11번 핀에 연결된 부저에 C3음을 0.5초 연주 마지막 매개변수를 사용하지 않고 tone을 연속으로 사용하는 경우 주의가 필요하다. 예를들어, 12tone(11, 262); // 11번 핀에 연결된 부저에 C3음을 0.5초 연주tone(11, 294); // 11번 핀에 연결된 부저에 D3음을 0.5초 연주 이렇게 tone을 연속으로 사용하면 C3음을 소리낸 이후에, D4음을 내는 것이 아니라 C3음이 계속되므로, noTone함수를 사용하여 소리 출력을 멈추어야 한다. 123tone(11, 262); // 11번 핀에 연결된 부저에 C3음을 0.5초 연주noTone(11);tone(11, 294); // 11번 핀에 연결된 부저에 D3음을 0.5초 연주 마지막 매개변수를 사용할 때, 중간에 음을 멈추는 구간을 만들려면, delay를 사용한다. 123tone(11, 262, 500); // 11번 핀에 연결된 부저에 C3음을 0.5초 연주delay(600);tone(11, 294, 500); // 11번 핀에 연결된 부저에 D3음을 0.5초 연주 C3음을 0.5초 소리낸 후 delay(600) 에 의해 0.6초를 쉬는 것이 아니라, delay(600) 의 시간 중, 0.5초는 C3음을 소리내는 데 사용하고, 나머지 0.1초를 쉰다. 예시도레미파솔라시도12345678910111213141516171819202122232425262728293031323334353637const int BUZZER_PIN = 11; const int C_4 = 261; // 도const int D_4 = 294; // 레const int E_4 = 330; // 미const int F_4 = 349; // 파const int G_4 = 392; // 솔const int A_4 = 440; // 라const int B_4 = 494; // 시 void setup() {} void loop() { tone(BUZZER_PIN, C_4); delay(500); tone(BUZZER_PIN, D_4); delay(500); tone(BUZZER_PIN, E_4); delay(500); tone(BUZZER_PIN, F_4); delay(500); tone(BUZZER_PIN, G_4); delay(500); tone(BUZZER_PIN, A_4); delay(500); tone(BUZZER_PIN, B_4); delay(500); noTone(BUZZER_PIN);} 노래 연주: Super Mario Theme123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290/* Arduino Mario Bros Tunes With Piezo Buzzer and PWM by : ARDUTECH Connect the positive side of the Buzzer to pin 11, then the negative side to a 1k ohm resistor. Connect the other side of the 1 k ohm resistor to ground(GND) pin on the Arduino. */ #define NOTE_B0 31#define NOTE_C1 33#define NOTE_CS1 35#define NOTE_D1 37#define NOTE_DS1 39#define NOTE_E1 41#define NOTE_F1 44#define NOTE_FS1 46#define NOTE_G1 49#define NOTE_GS1 52#define NOTE_A1 55#define NOTE_AS1 58#define NOTE_B1 62#define NOTE_C2 65#define NOTE_CS2 69#define NOTE_D2 73#define NOTE_DS2 78#define NOTE_E2 82#define NOTE_F2 87#define NOTE_FS2 93#define NOTE_G2 98#define NOTE_GS2 104#define NOTE_A2 110#define NOTE_AS2 117#define NOTE_B2 123#define NOTE_C3 131#define NOTE_CS3 139#define NOTE_D3 147#define NOTE_DS3 156#define NOTE_E3 165#define NOTE_F3 175#define NOTE_FS3 185#define NOTE_G3 196#define NOTE_GS3 208#define NOTE_A3 220#define NOTE_AS3 233#define NOTE_B3 247#define NOTE_C4 262#define NOTE_CS4 277#define NOTE_D4 294#define NOTE_DS4 311#define NOTE_E4 330#define NOTE_F4 349#define NOTE_FS4 370#define NOTE_G4 392#define NOTE_GS4 415#define NOTE_A4 440#define NOTE_AS4 466#define NOTE_B4 494#define NOTE_C5 523#define NOTE_CS5 554#define NOTE_D5 587#define NOTE_DS5 622#define NOTE_E5 659#define NOTE_F5 698#define NOTE_FS5 740#define NOTE_G5 784#define NOTE_GS5 831#define NOTE_A5 880#define NOTE_AS5 932#define NOTE_B5 988#define NOTE_C6 1047#define NOTE_CS6 1109#define NOTE_D6 1175#define NOTE_DS6 1245#define NOTE_E6 1319#define NOTE_F6 1397#define NOTE_FS6 1480#define NOTE_G6 1568#define NOTE_GS6 1661#define NOTE_A6 1760#define NOTE_AS6 1865#define NOTE_B6 1976#define NOTE_C7 2093#define NOTE_CS7 2217#define NOTE_D7 2349#define NOTE_DS7 2489#define NOTE_E7 2637#define NOTE_F7 2794#define NOTE_FS7 2960#define NOTE_G7 3136#define NOTE_GS7 3322#define NOTE_A7 3520#define NOTE_AS7 3729#define NOTE_B7 3951#define NOTE_C8 4186#define NOTE_CS8 4435#define NOTE_D8 4699#define NOTE_DS8 4978#define melodyPin 11//Mario main theme melodyint melody[] = { NOTE_E7, NOTE_E7, 0, NOTE_E7, 0, NOTE_C7, NOTE_E7, 0, NOTE_G7, 0, 0, 0, NOTE_G6, 0, 0, 0, NOTE_C7, 0, 0, NOTE_G6, 0, 0, NOTE_E6, 0, 0, NOTE_A6, 0, NOTE_B6, 0, NOTE_AS6, NOTE_A6, 0, NOTE_G6, NOTE_E7, NOTE_G7, NOTE_A7, 0, NOTE_F7, NOTE_G7, 0, NOTE_E7, 0, NOTE_C7, NOTE_D7, NOTE_B6, 0, 0, NOTE_C7, 0, 0, NOTE_G6, 0, 0, NOTE_E6, 0, 0, NOTE_A6, 0, NOTE_B6, 0, NOTE_AS6, NOTE_A6, 0, NOTE_G6, NOTE_E7, NOTE_G7, NOTE_A7, 0, NOTE_F7, NOTE_G7, 0, NOTE_E7, 0, NOTE_C7, NOTE_D7, NOTE_B6, 0, 0};//Mario main theme tempoint tempo[] = { 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,};//Underworld melodyint underworld_melody[] = { NOTE_C4, NOTE_C5, NOTE_A3, NOTE_A4, NOTE_AS3, NOTE_AS4, 0, 0, NOTE_C4, NOTE_C5, NOTE_A3, NOTE_A4, NOTE_AS3, NOTE_AS4, 0, 0, NOTE_F3, NOTE_F4, NOTE_D3, NOTE_D4, NOTE_DS3, NOTE_DS4, 0, 0, NOTE_F3, NOTE_F4, NOTE_D3, NOTE_D4, NOTE_DS3, NOTE_DS4, 0, 0, NOTE_DS4, NOTE_CS4, NOTE_D4, NOTE_CS4, NOTE_DS4, NOTE_DS4, NOTE_GS3, NOTE_G3, NOTE_CS4, NOTE_C4, NOTE_FS4, NOTE_F4, NOTE_E3, NOTE_AS4, NOTE_A4, NOTE_GS4, NOTE_DS4, NOTE_B3, NOTE_AS3, NOTE_A3, NOTE_GS3, 0, 0, 0};//Underwolrd tempoint underworld_tempo[] = { 12, 12, 12, 12, 12, 12, 6, 3, 12, 12, 12, 12, 12, 12, 6, 3, 12, 12, 12, 12, 12, 12, 6, 3, 12, 12, 12, 12, 12, 12, 6, 6, 18, 18, 18, 6, 6, 6, 6, 6, 6, 18, 18, 18, 18, 18, 18, 10, 10, 10, 10, 10, 10, 3, 3, 3};void setup(void){ pinMode(melodyPin, OUTPUT); // buzzer pinMode(13, OUTPUT); // led indicator when singing a note}void loop(){ //sing the tunes sing(1); sing(1); sing(2);}int song = 0;void sing(int s) { // iterate over the notes of the melody: song = s; if (song == 2) { Serial.println(&quot; 'Underworld Theme'&quot;); int size = sizeof(underworld_melody) / sizeof(int); for (int thisNote = 0; thisNote &lt; size; thisNote++) { // to calculate the note duration, take one second // divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / underworld_tempo[thisNote]; buzz(melodyPin, underworld_melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: buzz(melodyPin, 0, noteDuration); } } else { Serial.println(&quot; 'Mario Theme'&quot;); int size = sizeof(melody) / sizeof(int); for (int thisNote = 0; thisNote &lt; size; thisNote++) { // to calculate the note duration, take one second // divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / tempo[thisNote]; buzz(melodyPin, melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: buzz(melodyPin, 0, noteDuration); } }}void buzz(int targetPin, long frequency, long length) { digitalWrite(13, HIGH); long delayValue = 1000000 / frequency / 2; // calculate the delay value between transitions //// 1 second's worth of microseconds, divided by the frequency, then split in half since //// there are two phases to each cycle long numCycles = frequency * length / 1000; // calculate the number of cycles for proper timing //// multiply frequency, which is really cycles per second, by the number of seconds to //// get the total number of cycles to produce for (long i = 0; i &lt; numCycles; i++) { // for the calculated length of time... digitalWrite(targetPin, HIGH); // write the buzzer pin high to push out the diaphram delayMicroseconds(delayValue); // wait for the calculated delay value digitalWrite(targetPin, LOW); // write the buzzer pin low to pull back the diaphram delayMicroseconds(delayValue); // wait again or the calculated delay value } digitalWrite(13, LOW);} 노래 연주: 학교종이 땡땡땡1234567891011121314151617181920212223242526272829303132333435363738394041const int BUZZER_PIN = 11; const int C_4 = 261; // 도const int D_4 = 294; // 레const int E_4 = 330; // 미const int F_4 = 349; // 파const int G_4 = 392; // 솔const int A_4 = 440; // 라const int B_4 = 494; // 시 typedef struct { int tone; unsigned long delay;} TAD;//Tone And Delay TAD music[] = { {G_4, 100}, {G_4, 100}, {A_4, 100}, {A_4, 100}, {G_4, 100}, {G_4, 100}, {E_4, 200}, {G_4, 100}, {G_4, 100}, {E_4, 100}, {E_4, 100}, {D_4, 200}, {G_4, 100}, {G_4, 100}, {A_4, 100}, {A_4, 100}, {G_4, 100}, {G_4, 100}, {E_4, 200}, {G_4, 100}, {E_4, 100}, {D_4, 100}, {E_4, 100}, {C_4, 200} }; int musicLen; void setup() { musicLen = sizeof(music) / sizeof(TAD);} void loop() { for(int i = 0; i &lt; musicLen; i++) { tone(BUZZER_PIN, music[i].tone); delay(music[i].delay * 5); noTone(BUZZER_PIN); delay(30); } noTone(BUZZER_PIN); delay(1000);} 과제 크리스마스 캐롤 만들어보기 크리스마스 캐롤 연주시에, 음이 바뀔때마다 신호등 LED점멸 바꿔보기 미니 피아노 만들기패시브 부저와 스위치를 사용하여 미니 피아노를 만들어보자. schematic sketch1234567891011121314151617181920212223const int BUZZER_PIN = 11;// 도 레 미 파 솔 라 시// C4 D4 E4 F4 G4 A4 B4int octave_4[9] = {0, 0, 261, 294, 330, 349, 392, 440, 494};void setup() { // tact switch pin 2~8 for Keyboard for(int i=2; i&lt;=8; i++) { pinMode(i, INPUT_PULLUP); } Serial.begin(9600);}void loop() { for(int i=2; i&lt;=8; i++) { if(digitalRead(i) == HIGH) { tone(BUZZER_PIN, octave_4[i]); delay(1); } } noTone(BUZZER_PIN);} 과제23명의 학생이 모여 23 옥타브를 사용하는 피아노 연주곡 만들어보기","link":"/2018/09/07/Arduino-Piezo-Buzzer/"},{"title":"Arduino, TM1637 모듈 사용하기","text":"TM1637 schematic TM1637 CLK DIO VCC GND Arduino 4 7 5V GND 라이브러리 추가하기 파일&gt; 새파일&gt; 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; 라이브러리 매니저 창이 뜨면, 검색란에 “tm1637”를 적어 넣음. tm1637관련 라이브러리가 5~6개정도 검색됨. TM1637 by Avishay Orpaz 라이브러리를 선택하여 설치 TM1637 숫자 표기 방법for TM1637 by Avishay Orpaz library * A * F B * G * E C * D * DP sketch“8.8.8.8.” → “ “ → “0123” → “dOnE” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7// The amount of time (in milliseconds) between tests#define TEST_DELAY 2000const uint8_t SEG_DONE[] = { SEG_B | SEG_C | SEG_D | SEG_E | SEG_G, // d SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F, // O SEG_C | SEG_E | SEG_G, // n SEG_A | SEG_D | SEG_E | SEG_F | SEG_G // E };TM1637Display display(CLK, DIO);void setup(){}void loop(){ uint8_t data[] = { 0xff, 0xff, 0xff, 0xff }; uint8_t blank[] = { 0x00, 0x00, 0x00, 0x00 }; display.setBrightness(15); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f); // All segments on display.setSegments(data); // &quot;8.8.8.8.&quot; delay(TEST_DELAY); // Selectively set different digits // &quot;0123&quot; data[0] = display.encodeDigit(0); data[1] = display.encodeDigit(1); data[2] = display.encodeDigit(2); data[3] = display.encodeDigit(3); display.setSegments(data); delay(TEST_DELAY); // Done! display.setSegments(SEG_DONE); // &quot;dOnE&quot; delay(TEST_DELAY);} 0000~9999까지 나타내기 for() 문을 이용하는 방법먼저 가장 간단하게 for문을 사용하여 0~9999까지의 숫자를 표시해보겠습니다. 123456789101112131415161718192021222324252627282930313233343536#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7uint8_t data[] = { 0x00, 0x00, 0x00, 0x00 }; // 초기 출력값 0000 int seg3, seg2, seg1, seg0;TM1637Display display(CLK, DIO);void setup() { display.setBrightness(15); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f); Serial.begin(9600); }void loop() { for(int digitValue = 0; digitValue &lt;= 9999; digitValue++) { // 0~9999까지 1씩 증가시킴 seg0 = (digitValue / 1000) % 10; // 4자리에서 1000의 자리 숫자 저장 seg1 = (digitValue / 100) % 10; // 4자리에서 100의 자리 숫자 저장 seg2 = (digitValue / 10) % 10; // 4자리에서 10의 자리 숫자 저장 seg3 = digitValue % 10; // 4자리에서 1의 자리 숫자 저장 data[0]=display.encodeDigit(seg0); // 첫번째 FND에 1000의 자리 숫자배열 data[1]=display.encodeDigit(seg1); // 두번째 FND에 100의 자리 숫자 배열 data[2]=display.encodeDigit(seg2); // 세번째 FND에 10의 자리 숫자 배열 data[3]=display.encodeDigit(seg3); // 네번째 FND에 1의 자리 숫자 배열 display.setSegments(data); Serial.println(digitValue); delay(10); // 10ms 마다 카운트 }} millis() 함수를 이용하는 방법millis() 함수를 이용하여 시간카운트를 통해 0~9999까지 카운트 해보는 방법도 있습니다. ※ 주의: seg0, seg1, seg2, seg3 등의 변수값이 1015사이의 값을 갖게되면 16진수(AF)로 표현되므로, 각 변수는 10보다 작은 값을 갖도록 해야한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061extern volatile unsigned long timer0_millis; // millis() 리셋을 위한 변수#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7unsigned long previousTime, currentTime; // 현재시간, 현재시간(ms)int timeValue;uint8_t data[] = { 0x00, 0x00, 0x00, 0x00 }; // 초기 출력값 0000 int seg3, seg2, seg1, seg0;TM1637Display display(CLK, DIO);void setup() { display.setBrightness(15); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f); Serial.begin(9600); }void loop() { currentTime = millis(); // 현재 시간값을 측정 /* if(currentTime - previousTime &gt;= 1000) { // 현재 시간값을 1s마다 1000씩 증가시킴 previousTime = currentTime; timeValue = currentTime / 1000; // 1s 마다 1000씩 증가된 숫자를 1000으로 나누어 줌. // (결과적으로 1s마다 1씩 증가된 숫자가 timeValue에 저장됨)*/ if(currentTime - previousTime &gt;= 100) { // 현재 시간값을 0.1s마다 100씩 증가시킴 previousTime = currentTime; timeValue = currentTime / 100; // 0.1s 마다 100씩 증가된 숫자를 100으로 나누어 줌. // (결과적으로 0.1s마다 1씩 증가된 숫자가 timeValue에 저장됨)/* if(currentTime - previousTime &gt;= 10) { // 현재 시간값을 0.01s마다 10씩 증가시킴 previousTime = currentTime; timeValue = currentTime / 10; // 0.01s 마다 10씩 증가된 숫자를 10으로 나누어 줌. (결과적으로 0.01s마다 1씩 증가된 숫자가 timeValue에 저장됨) */ seg0 = (timeValue / 1000) % 10; // 현재 시간값 4자리에서 1000의 자리 숫자 저장 seg1 = (timeValue / 100) % 10; // 현재 시간값 4자리에서 100의 자리 숫자 저장 seg2 = (timeValue / 10) % 10; // 현재 시간값 4자리에서 10의 자리 숫자 저장 seg3 = timeValue % 10; // 현재 시간값 4자리에서 1의 자리 숫자 저장 data[0]=display.encodeDigit(seg0); // 첫번째 Segment에 1000의 자리 숫자 배열 data[1]=display.encodeDigit(seg1); // 두번째 Segment에 100의 자리 숫자 배열 data[2]=display.encodeDigit(seg2); // 세번째 Segment에 10의 자리 숫자 배열 data[3]=display.encodeDigit(seg3); // 네번째 Segment에 1의 자리 숫자 배열 display.setSegments(data); Serial.println(timeValue); } if(currentTime&gt;=1000000) { // 1,000,000ms(1000초) 후 millis() 리셋 timer0_millis = 0; previousTime = 0; }} millis() 함수를 이용하여 (분:초) 시계 만들기※ 주의: seg0, seg1, seg2, seg3 등의 변수값이 1015사이의 값을 갖게되면 16진수(AF)로 표현되므로, 각 변수는 10보다 작은 값을 갖도록 해야한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475extern volatile unsigned long timer0_millis; // millis() 리셋을 위한 변수#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7unsigned long previousTime, currentTime; // 현재시간, 현재시간(ms)int timeValue;uint8_t data[] = { 0x00, 0x00, 0x00, 0x00 }; // 초기 출력값 0000uint8_t segto;int seg3, seg2, seg1, seg0;int initTime = 5948; // 초기 시간 59분 48초TM1637Display display(CLK, DIO);void setup() { display.setBrightness(7); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f); seg0 = (initTime / 1000) % 10; // 초기 시간값 4자리에서 1000의 자리 숫자 저장 seg1 = (initTime / 100) % 10; // 초기 시간값 4자리에서 100의 자리 숫자 저장 seg2 = (initTime / 10) % 10; // 초기 시간값 4자리에서 10의 자리 숫자 저장 seg3 = initTime % 10; // 초기 시간값 4자리에서 1의 자리 숫자 저장 Serial.begin(9600); }void loop() { currentTime = millis(); // 현재 시간값을 측정 if(currentTime - previousTime &gt;= 1000) { // 현재 시간값을 0.1s마다 100씩 증가시킴 previousTime = currentTime; timeValue = currentTime / 1000; // 0.1s 마다 100씩 증가된 숫자를 100으로 나누어 줌. // (결과적으로 0.1s마다 1씩 증가된 숫자가 timeValue에 저장됨) seg3++; if(seg3 == 10) { seg3 = 0; seg2++; } if(seg2 == 6 &amp;&amp; seg3 == 0) { seg2 = 0; seg1++; } if(seg1 == 10) { seg1 = 0; seg0++; } if(seg0 == 6 &amp;&amp; seg1 == 0) { seg0 = 0; seg1 = 0; seg2 = 0; seg3 = 0; } data[0]=display.encodeDigit(seg0); // 첫번째 Segment에 1000의 자리 숫자 배열 data[1]=display.encodeDigit(seg1); // 두번째 Segment에 100의 자리 숫자 배열 data[2]=display.encodeDigit(seg2); // 세번째 Segment에 10의 자리 숫자 배열 data[3]=display.encodeDigit(seg3); // 네번째 Segment에 1의 자리 숫자 배열 // 0.5초마다 콜론 깜박이기 segto = 0x80 | display.encodeDigit(seg1); // 분과 초사이의 콜론(:) 표시 display.setSegments(&amp;segto,1,1); delay(500); // 깜박임 딜레이 display.setSegments(data); delay(500); // 깜박임 딜레이 } if(currentTime&gt;=86400000) { // 86,400,000ms(86,400초 = 24시간*60분/시간*60분/초) 후 millis() 리셋 timer0_millis = 0; previousTime = 0; }} 다양한 표현방법 익히기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7// The amount of time (in milliseconds) between tests#define TEST_DELAY 2000const uint8_t SEG_DONE[] = { SEG_B | SEG_C | SEG_D | SEG_E | SEG_G, // d SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F, // O SEG_C | SEG_E | SEG_G, // n SEG_A | SEG_D | SEG_E | SEG_F | SEG_G // E };TM1637Display display(CLK, DIO);void setup(){}void loop(){ int k; uint8_t data[] = { 0xff, 0xff, 0xff, 0xff }; uint8_t blank[] = { 0x00, 0x00, 0x00, 0x00 }; display.setBrightness(15); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f); // All segments on display.setSegments(data); delay(TEST_DELAY); // Selectively set different digits data[0] = display.encodeDigit(0); data[1] = display.encodeDigit(1); data[2] = display.encodeDigit(2); data[3] = display.encodeDigit(3); display.setSegments(data); delay(TEST_DELAY); /* for(k = 3; k &gt;= 0; k--) { display.setSegments(data, 1, k); delay(TEST_DELAY); } */ display.clear(); display.setSegments(data+2, 2, 2); // __23 -&gt; data+2: data배열 0123에서 앞에 두 자리 건너 띄운 후, // 2: 남은 숫자 중 2자리를 잘라서, 2: 앞의 2칸을 띄운 후 출력 delay(TEST_DELAY); display.clear(); display.setSegments(data+2, 2, 1); // _23_ -&gt; data+2: data배열 0123에서 앞에 두 자리 건너 띄운 후, // 2: 남은 숫자 중 2자리를 잘라서, 1: 앞의 1칸을 띄운 후 출력 delay(TEST_DELAY); display.clear(); display.setSegments(data+1, 3, 1); // _123 -&gt; data+1: data배열 0123에서 앞에 한자리 건너 띄운 후, // 3: 남은 숫자 중 3자리를 잘라서, 1: 앞의 1칸을 띄운 후 출력 delay(TEST_DELAY); display.clear(); display.setSegments(data+3, 1, 2); // __3_ -&gt; data+2: data배열 0123에서 앞에 두 자리 건너 띄운 후, // 1: 남은 숫자 중 1자리를 잘라서, 2: 앞의 2칸을 띄운 후 출력 delay(TEST_DELAY); display.clear(); display.setSegments(data+3, 2, 1); // _3__ -&gt; data+2: data배열 0123에서 앞에 두 자리 건너 띄운 후, // 2: 남은 숫자 중 2자리를 잘라서(3이 마지막 자리이므로 1자리만 자름) // 2: 앞의 2칸을 띄운 후 출력 delay(TEST_DELAY); // Show decimal numbers with/without leading zeros display.showNumberDec(0, false); // Expect: ___0 delay(TEST_DELAY); display.showNumberDec(0, true); // Expect: 0000 delay(TEST_DELAY); display.showNumberDec(1, false); // Expect: ___1 delay(TEST_DELAY); display.showNumberDec(1, true); // Expect: 0001 delay(TEST_DELAY); display.showNumberDec(301, false); // Expect: _301 delay(TEST_DELAY); display.showNumberDec(301, true); // Expect: 0301 delay(TEST_DELAY); display.clear(); display.showNumberDec(14, false, 2, 1); // Expect: _14_ delay(TEST_DELAY); display.clear(); display.showNumberDec(4, true, 2, 2); // Expect: __04 delay(TEST_DELAY); display.showNumberDec(-1, false); // Expect: __-1 delay(TEST_DELAY); display.showNumberDec(-12); // Expect: _-12 delay(TEST_DELAY); display.showNumberDec(-999); // Expect: -999 delay(TEST_DELAY); display.clear(); display.showNumberDec(-5, false, 3, 0); // Expect: _-5_ delay(TEST_DELAY); display.showNumberHexEx(0xf1af); // Expect: f1Af delay(TEST_DELAY); display.showNumberHexEx(0x2c); // Expect: __2C delay(TEST_DELAY); display.showNumberHexEx(0xd1, 0, true); // Expect: 00d1 delay(TEST_DELAY); display.clear(); display.showNumberHexEx(0xd1, 0, true, 2); // Expect: d1__ delay(TEST_DELAY); // Run through all the dots for(k=0; k &lt;= 4; k++) { display.showNumberDecEx(0, (0x80 &gt;&gt; k), true); delay(TEST_DELAY); } display.showNumberDecEx(3141, (0x80 &gt;&gt; 0), true); // 3.141 -&gt; 0x80: dot출력, 0x40: 콜론출력, &gt;&gt;0: 첫번째 도트출력, // true: 빈자리 0으로 채우기 delay(TEST_DELAY); display.showNumberDecEx(243, (0x80 &gt;&gt; 1), false); // _2.43 -&gt; 0x80: dot출력, 0x40: 콜론출력, &gt;&gt;1: 두번째 도트출력, // true: 빈자리 0으로 채우기 delay(TEST_DELAY); display.showNumberDecEx(314, (0x80 &gt;&gt; 2), false); // _31.4 -&gt; 0x80: dot출력, 0x40: 콜론출력, &gt;&gt;2: 세번째 도트출력, // false: 빈자리 채우지 않기 delay(TEST_DELAY); display.showNumberDecEx(52, (0x80 &gt;&gt; 3), false); // __52. -&gt; 0x80: dot출력, 0x40: 콜론출력, &gt;&gt;3: 네번째 도트출력, // false: 빈자리 채우지 않기 delay(TEST_DELAY); // Brightness Test for(k = 0; k &lt; 4; k++) data[k] = 0xff; // 모두 segment를 키는 data배열 선언 for(k = 0; k &lt; 7; k++) { display.setBrightness(k); // 밝기를 7단계에 걸쳐 점점 밝게 출력 display.setSegments(data); delay(TEST_DELAY); } // On/Off test for(k = 0; k &lt; 4; k++) { display.setBrightness(7, false); // Turn off display.setSegments(data); delay(TEST_DELAY); display.setBrightness(7, true); // Turn on display.setSegments(data); delay(TEST_DELAY); } // Done! display.setSegments(SEG_DONE); // while(1);}","link":"/2018/09/02/Arduino-TM1637-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"Arduino, 라인트레이서, L298N","text":"아두이노를 사용하여 검은색 라인을 따라 움직이는 라인트레이서 자동차를 만들어보자. TCRT5000 IR reflective sensor라인트레이서 제작시 가장 널리 사용되는 IR 센서이다. 감지하는 부분이 검은색으로 되어 있는 부분이라면 IR이 모두 흡수되고, 흰색으로 되어 있는 부분에서는 모두 반사되는 원리를 이용한다. 장애물이 없는 경우: 1 반환 센서와 12mm이내의 거리에 밝은색이 위치하는 경우: 0 반환 센서와 12mm이내의 거리에 검은색이 위치하는 경우: 1 반환 검은색의 경우도 아주 가까이 가져가면 적외선 수신량이 증가하여 0의 값을 반환할 수 있으므로, 라인트레이서 구성시 감지하는 적당한 거리를 찾는 것이 중요합니다. 10~12mm 정도의 거리에서 측정하는 것을 추천 AO 단자를 이용할 경우 아날로그 신호로 처리도 가능 (위 스펙과는 별도로) 라인트레이서 제작시에는 경험상 센서가 바닥면으로부터 2cm정도 떨어지도록 설치하는 것을 추천함 schematic sketch12345678910111213int i = 0;int pin_sensor = 2;void setup() { Serial.begin(9600); pinMode(pin_sensor, INPUT);}void loop() { i = digitalRead(pin_sensor) Serial.println(i); // 검은색(1), 밝은색(0) 출력 delay(1000);} 모터드라이버 L298N대부분의 모터는 구동에 필요한 전력 소모량 커서 아두이노의 자체 출력으로는 구동이 불가능하다. 그러므로 건전지, SMPS 등의 외부 전원을 사용하여 모터에 충분한 전력을 공급하고, 이를 제어하기위한 모터드라이버를 반드시 사용해야 한다. 아두이노에서 사용하는 대표적인 모터드라이브는 L298N, TB6612FNG 등이 있으며, 여기서는 2CH의 2A출력이 가능한 L298N을 사용하여 간단한 라인트레이서를 제작한다. Pinout 모터A 출력 : 왼쪽 모터를 연결한다. 모터B 출력 : 오른쪽 모터를 연결한다. 12V (입력) : 외부전원을 입력한다. (5~35V) 12V 이상의 외부전원을 입력하는 경우, 레귤레이터 보호를 위해 5V 점퍼선을 제거해야 함 5V (입력/출력) 점퍼핀이 연결되어 있는 경우 5V 출력 (단, 5V출력으로 사용하려면 외부전원을 12V이하로 주어야 하며, 그 이상의 전압을 인가하는 경우 레귤레이터가 손상됨) 점퍼핀 없는 경우 5V 입력을 통해 L298N에 전원 인가 Enable 모터A : 왼쪽 모터 PWM (점퍼를 제거하고, INPUT핀 양옆의 핀에 PWM신호 입력) Enable 모터B : 오른쪽 모터 PWM (점퍼를 제거하고, INPUT핀 양옆의 핀에 PWM신호 입력) PWM을 사용하는 경우 모터에 인가하는 전원이 6V(AA*4개)인 경우 PWM값이 낮으면 모터가 회전하지 않으므로 코딩시 주의한다. INPUT : IN1, IN2, IN3, IN4 Direction IN1 IN2 IN3 IN4 Go HIGH HIGH LOW LOW Back LOW LOW HIGH HIGH Brake LOW LOW LOW LOW Left_Turn HIGH LOW LOW LOW Right_Turn LOW HIGH LOW LOW Left_Back_Turn LOW LOW HIGH LOW Right_Back_Turm LOW LOW LOW HIGH Jumper Enable 모터A 점퍼를 연결시키지 않으면 PWM사용 점퍼 연결시 왼쪽 모터에 5V (즉, PWM을 사용하지 않는 경우에만 연결) Enable 모터B 점퍼를 연결시키지 않으면 PWM사용 점퍼 연결시 오른쪽 모터 5V (즉, PWM을 사용하지 않는 경우에만 연결) 5V (※ Pinout의 5V 부분 참고) 전원 대부분의 초보자를 위한 4WD 제작 키트는 AA건전지 4개를 직렬연결할 수 있는 전지소켓을 포함하여 판매하는 경우가 많지만 But, 제작 경험으로 볼 때 AA건전지 4개로 얻을 수 있는 전력만으로는 원활한 구동이 되지 않는 경우가 많다. AA건전지 6개를 직렬로 연결하여 9V정도를 공급하거나 (사용시간 10~15분정도 가능) 18650 리튬이온전지 2개를 연결하여 7.4V를 공급하는 것을 추천한다. 모터아두이노 기초 실습용으로 많이 쓰이는 이름없는 중국산 모터이다. 기어비 48:1 RPM(무부하) 전류 mA (무부하) 토크(kg·cm) 3V 120 40 3.2 6V 240 70 5.5 프레임 조립준비물 조립과정 모터 4개와 M-F형태의 8가닥 리드선을 준비하고 모터에 리드선을 납땜할 준비를 합니다. DC모터를 보면 양쪽에 (+)(-)극을 연결하는 단자가 있습니다. 준비한 8가닥의 M-F리드선을 2가닥씩 묶어 4갈래로 전체 길이의 1/2의 길이만큼 나누어 준비한뒤, 2개의 가닥 중 한 부분을 모터의 (+)(-)단자에 끼우고, 각각을 납땜합니다. 총 4개의 모터를 납땜하여 아래 모습처럼 만듭니다. ※ (주의) 납땜시, 아래 그림처럼 리드선이 모터의 본체에 닿으면 안됩니다. ​ 처음 납땜할 때부터 닿지 않도록 하는 것이 좋지만, 납땜을 이미 진행한 후에 리드선이 본체에 닿아 있다면 아래의 그림처럼 끝 부분을 살짝 휘어두거나, 니퍼로 잘라내도록 합니다. 외부 전원으로 사용할 건전지소켓을 준비합니다. (사진상에는 1.5V AA건전지 4개가 직렬로 연결되는 건전지소켓을 사용하였지만, 4개의 모터를 구동하기 위해서는 1.5V AA건전지를 6개 직렬로 연결하여 9V 전압을 사용하는 것을 추천합니다. 단, 9V사각전지(6F22) 1개로 사용하는 것은 전류가 약하므로 사용불가!) ​ 건전지소켓에 나와있는 리드선의 끝부분을 스트리퍼를 사용하여 피복을 조금더 벗겨냅니다. 또한 빨간색과 검은색 점퍼선 2개를 별로로 준비한뒤, 한쪽 단자를 잘라내고, 스트리퍼로 피복을 벗겨냅니다. 건전지소켓의 리드선과 점퍼선을 붙여 떨어지지 않도록 단단히 납땜한 후, 합선되지 않도록 절연테이프나 열수축튜브로 각각을 잘 감싸둡니다. 이제 아크릴판을 준비합니다. 아래 그림의 Step1~2과정과 같이 모터를 고정할 아크릴 조각을 끼울 것입니다. ​ 우선, 모터를 고정할 아크릴 조각 2개를 고정할 위치를 확인합니다. 총 4개의 모터를 고정할 것이므로 아크릴 조각 8개가 필요합니다. 모터고정 아크릴 조각을 아래 사진처럼 끼웁니다. 하나는 구멍에 집어 넣고, 나머지 하나는 측면의 홈에 살짝 걸쳐둡니다. 이제 모터를 설치하겠습니다. ​ 나사와 너트를 2개씩 준비한 후 ​ 아크릴 조각 2개 사이에 모터를 위치시킨 후, 모터 몸체이 있는 나사 구멍에 나사 2개를 통과시켜 ​ 아래 사진 같이 고정합니다. 13. 모터를 고정한 후, 바퀴축의 안쪽 부분에 바퀴의 균형을 잡아줄 동그란 아크릴 조각을 끼워줍니다. ​ 4개의 모터를 같은 방법으로 고정시켜 아래와 같은 형태를 만듭니다. 주의할 것은 모터의 단자가 위치한 은색부분의 모터본체 부분이 서로 맞닿는 형태로 조립을 해야 합니다. 바퀴를 끼웁니다. 금속기둥을 세우고 상판을 덮습니다. (아크릴상판이 없는 경우는 생략 가능) 기판 아래면에 모터가 위치하도록 위아래를 뒤집은 후에, 기판 윗면에 TCRT5000 IR Reflective Sensor, 아두이노, 브레드보드, L298N 모터드라이브, 9V 전지소켓을 차례대로 올리고 나사볼트와 절연테이프 등으로 고정합니다. 대략 아래 사진과 비슷하게 고정하면 됩니다. 아두이노 연결하기schematic 회로 연결모터 ↔ 모터드라이버 L/F 모터 U단자 L/F 모터 D단자 L/R 모터 U단자 L/R 모터 D단자 R/F 모터 U단자 R/F 모터 D단자 R/R 모터 U단자 R/R모터 D단자 L298N OUT1 ○ ○ L298N OUT2 ○ ○ L298N OUT3 ○ ○ L298N OUT4 ○ ○ 모터드라이버 ↔ 전지소켓 ↔ 아두이노 전지소켓 (+) 전지소켓(-) 아두이노 L298N 12V ○ Vin L298N GND GND (아두이노) GND L298N 5V 5V 모터드라이브 ENABLE &amp; INPUT ↔ 아두이노 아두이노 L298N EN(A) 5 L298N IN1 8 L298N IN2 9 L298N IN3 10 L298N IN4 11 L298N EN(B) 6 TCRT5000 Sensor ↔ 아두이노 아두이노 #1 TCRT5000 VCC 5V #1 TCRT5000 GND GND #1 TCRT5000 DO 2 #1 TCRT5000 AO – #2 TCRT5000 VCC 5V #2 TCRT5000 GND GND #2 TCRT5000 DO 3 #2 TCRT5000 AO – sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/* L298N - 2CH Motor DriverDirection IN1 IN2 IN3 IN4-------------------------------------------GO HIGH HIGH LOW LOWBACK LOW LOW HIGH HIGHBRAKE LOW LOW LOW LOWLEFT_TURN HIGH LOW LOW LOWRIGHT_TURN LOW HIGH LOW LOWLEFT_BACK_TURN LOW LOW HIGH LOWRIGHT_BACK_TURN LOW LOW LOW HIGHPWM: 6V시 최소값 200이상은 되야 바퀴회전 가능 (너무 낮은 전압에서 회전 안됨)*/// 모터_전진컨트롤int Left_motor_IN1 = 8; // IN1int Right_motor_IN2 = 9; // IN2// 모터_후진컨트롤int Left_motor_IN3 = 10; // IN3int Right_motor_IN4 = 11; // IN4// 모터_속도컨트롤int Left_PWM = 5; // 왼쪽모터 속도int Right_PWM = 6; // 오른쪽모터 속도// IR Sensorconst int Left_Sensor = 2; // 왼쪽센서const int Right_Sensor = 3; // 오른쪽센서int Left_Sensor_Value; // 검은색:1int Right_Sensor_Value; // 흰색:0void setup(){ pinMode(Left_motor_IN1, OUTPUT); // PIN 8 pinMode(Right_motor_IN2, OUTPUT); // PIN 9 pinMode(Left_motor_IN3, OUTPUT); // PIN 10 pinMode(Right_motor_IN4, OUTPUT); // PIN 11 pinMode(Left_PWM, OUTPUT); // PIN 5 pinMode(Right_PWM, OUTPUT); // PIN 6 pinMode(Left_Sensor, INPUT); // 왼쪽센서 pinMode(Right_Sensor, INPUT); // 오른쪽센서}// 전진void go() { digitalWrite(Left_motor_IN1, HIGH); // 왼쪽모터 전진_정지 digitalWrite(Right_motor_IN2, HIGH); // 오론쪽모터 전진_정지 digitalWrite(Left_motor_IN3, LOW); // 왼쪽모터 후진_회전 digitalWrite(Right_motor_IN4, LOW); // 오른쪽모터 후진_회전 analogWrite(Left_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 analogWrite(Right_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 delay(5);}// 후진void back() { digitalWrite(Left_motor_IN1, LOW); // 왼쪽모터 전진_정지 digitalWrite(Right_motor_IN2, LOW); // 오론쪽모터 전진_정지 digitalWrite(Left_motor_IN3, HIGH); // 왼쪽모터 후진_회전 digitalWrite(Right_motor_IN4, HIGH); // 오른쪽모터 후진_회전 analogWrite(Left_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 analogWrite(Right_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 }// 정지void brake() { digitalWrite(Left_motor_IN1, LOW); // 왼쪽모터 전진_정지 digitalWrite(Right_motor_IN2, LOW); // 오론쪽모터 전진_정지 digitalWrite(Left_motor_IN3, LOW); // 왼쪽모터 후진_정지 digitalWrite(Right_motor_IN4, LOW); // 오른쪽모터 후진_정지 delay(5); }// 좌회전void turn_left(){ digitalWrite(Left_motor_IN1, LOW); // 왼쪽모터 전진_정지 digitalWrite(Right_motor_IN2, HIGH); // 오론쪽모터 전진_회전 digitalWrite(Left_motor_IN3, LOW); // 왼쪽모터 후진_정지 digitalWrite(Right_motor_IN4, LOW); // 오른쪽모터 후진_정지 analogWrite(Right_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 delay(5);}// 우회전void turn_right() { digitalWrite(Left_motor_IN1, HIGH); // 왼쪽모터 전진_회전 digitalWrite(Right_motor_IN2, LOW); // 오론쪽모터 전진_정지 digitalWrite(Left_motor_IN3, LOW); // 왼쪽모터 후진_정지 digitalWrite(Right_motor_IN4, LOW); // 오른쪽모터 후진_정지 analogWrite(Left_PWM, 255); // PWM값(0~255), 모터 회전속도 조절 delay(5);}void loop(){ while(1) { //신호가 있으면(흰색) LOW, 신호가 없으면(검은색) HIGH Right_Sensor_Value = digitalRead(Right_Sensor); Left_Sensor_Value = digitalRead(Left_Sensor); // 전진: 왼쪽센서 검은색, 오른쪽센서 검은색 if (Left_Sensor_Value == HIGH &amp;&amp; Right_Sensor_Value == HIGH) go(); // 좌회전: 왼쪽센서 검은색, 오른쪽센서 흰색 else if (Left_Sensor_Value == HIGH &amp; Right_Sensor_Value == LOW) turn_left(); // 우회전: 왼쪽센서 흰색, 오른쪽센서 검은색 else if (Left_Sensor_Value == LOW &amp; Right_Sensor_Value == HIGH) turn_right(); // 정지: 왼쪽센서 흰색, 오른쪽센서 흰색 else brake(); }} 센서 감도 조정 센서 반응을 살피면서 TCRT5000 모듈에 붙어 있는 감도조절기를 십자드라이버로 돌려 라인트레이싱에 가장 최적인 감도를 찾아야 한다.","link":"/2019/10/28/Arduino-%EB%9D%BC%EC%9D%B8%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%84%9C-L298N/"},{"title":"Arduino, 스텝모터","text":"스텝모터 (Step Motor) 펄스 모양의 전압에 의해 일정 각도(스텝 수) 만큼 회전하는 모터. 회전 각도는 입력 펄스 신호의 수에 비례하고, 회전 속도는 입력 펄스 신호의 주파수에 비례한다. 스텝모터 28BYJ-48 정격전압: 5VDC 기어비: 1/64$$\\frac {32}{9} \\times \\frac {22}{11} \\times \\frac {26}{9} \\times \\frac {31}{10} = 63.68395 \\fallingdotseq 64$$ 스트라이드 각도 스펙상 5.625º / 64 = 0.087890625 그러므로, 360º / 0.087890625 = 4096 스텝 실제로는 11.25º / 64 = 0.17578125 그러므로, 360º / 0.17578125 = 2048 스텝으로 1회전 (이 값이 중요함!) Frequency: 100Hz 토크: 34.3mN,m 모터드라이브 ULN2003 schematic Pin Map 모터드라이브 아두이노 INT1 11 INT2 10 INT3 9 INT4 8 GND GND VCC 5V sketch: 예제112345678910111213141516171819202122#include &lt;Stepper.h&gt;// 2048:한바퀴(360도), 1024:반바퀴(180도)...// datasheet를 통해 스트라이드 각도를 계산한 값을 사용const int stepsPerRevolution = 2048;// 모터 드라이브에 연결된 핀 IN1, IN3, IN2, IN4Stepper myStepper(stepsPerRevolution, 11, 9, 10, 8);void setup() { myStepper.setSpeed(14); }void loop() { // 시계 반대 방향으로 한바퀴 회전 myStepper.step(stepsPerRevolution); delay(500); // 시계 방향으로 한바퀴 회전 myStepper.step(-stepsPerRevolution); delay(500);} Stepper myStepper(stepsPerRevolution, 11, 9, 10, 8); 모터 드라이브에 연결되는 순서에 유의한다! (IN1, IN3, IN2, IN4 순서임!) myStepper.setSpeed(14); 아두이노 보드의 5V 전원 사용시 16이 최대값. 16 이상은 안정적으로 회전이 안되며, 17을 넣으면 한바퀴 돌고 정지. 18을 넣으면 돌지 않음 sketch: 예제212345678910111213141516171819202122232425262728#include &lt;Stepper.h&gt;// 2048:한바퀴(360도), 1024:반바퀴(180도), 64:11.25도const int stepsPerRevolution = 64;// 모터 드라이브에 연결된 핀 IN1, IN3, IN2, IN4Stepper myStepper(stepsPerRevolution, 11, 9, 10, 8);void setup() { myStepper.setSpeed(16);}void loop() { // 시계 반대 방향으로 한바퀴 회전 // 64 * 32 = 2048 한바퀴 =&gt; 11.25도씩 32번 회전 (360도) for(int i=0; i&lt;32; i++) { myStepper.step(stepsPerRevolution); } delay(500); // 시계 방향으로 한바퀴 회전 // -64 * 32 = 2048 한바퀴 =&gt; -11.25도씩 32번 회전 (-360도) for(int i=0; i&lt;32; i++) { myStepper.step(-stepsPerRevolution); } delay(500);}","link":"/2018/09/08/Arduino-%EC%8A%A4%ED%85%9D%EB%AA%A8%ED%84%B0/"},{"title":"Arduino, 서보모터","text":"서보모터 SG-90 모터드라이버, 회전센서, 모터, 제어회로가 내장된 기어 박스를 포함하고 있는 형태의 모터로, 스텝모터보다 힘이 강함 보통 선이 3가닥이며, 회전수와 각도 등의 움직임 제어가 가능 아두이노에서 많이 다루는 SG90 제품의 경우 0~180˚ 제어가 가능 아두이노UNO의 USB 전류량이 500mA 정도가 한계이므로 별도의 전원을 사용하지 않으면 1~2개의 서보모터만 사용 가능 라이브러리 추가하기서보모터를 사용하기 위한 Servo 라이브러리는 아두이노 IDE에 기본으로 포함되어 있다. 스케치&gt; 라이브러리 포함하기&gt; Servo 를 선택하면, #include &lt;servo.h&gt; 라이브러리가 스케치에 추가 된다. schematic SG90 Brown Red Orange Arduino GND 5V 10 sketch : 서보모터 180º 회전 왕복하기123456789101112131415161718192021#include &lt;Servo.h&gt;Servo servomotor; // servomotor 선언int position = 0;void setup() { servomotor.attach(10); // servomotor 핀 설정}void loop() { for(position = 0; position &lt; 180; position++) { servomotor.write(position); // pos값의 위치로 이동 delay(15); } for(position = 180; position &gt; 0; position--) // 같은 방법으로 역회전 { servomotor.write(position); delay(15); }} servomotor.write(숫자)를 사용할때, 숫자는 현재 위치에서의 ‘회전각’을 의미하는 것이 아니다! 초기 위치를 0º로 기준삼아, 표시된 숫자의 각도 위치로 이동하라는 의미이다. 예를들어서 servomotor.write(90)와 servomotor.write(30)을 연속으로 실행하면, 90도를 회전한 뒤, 추가로 30도를 회전하여 120도 위치에 있다 → × 90도의 위치로 회전한 뒤, 역회전하여 (처음위치를 기준으로) 30도의 위치로 이동한다. → ○ 단, servo.h 라이브러리를 사용하면, 스케치 내에서 analogWrite를 사용할 수 없다는 단점도 있다. sketch: 시리얼모니터에서 각도값을 입력받아 회전시키기1234567891011121314151617181920212223#include &lt;Servo.h&gt;Servo servomotor;int a = 0;void setup() { servomotor.attach(10); Serial.begin(9600); // Serial 통신을 설정 while(!Serial); Serial.println(&quot;Servor Mortor&quot;);}void loop() { if(Serial.available()){ // Serial 모니터창에 어떤 값이 들어오면 실행 a = Serial.parseInt(); // Serial 모니터창에서 받은 값을 a에 넘겨줌 if(a&gt;=0 &amp;&amp; a&lt;=180) { Serial.print(&quot;angle : &quot;); Serial.println(a); servomotor.write(a); // a값에 해당하는 각도의 위치로 이동 delay(15); } }} 서보모터 SG-90: 라이브러리 없이 사용하기for SG90 with Arduino Frequency of that signal should be 50hz. Its range is 544-2450 micro seconds for 0-180 degree angle. Again its a little complex. For example 0 degree signal will be something like 5 volts for 544 micro seconds and 0 volt for 19465. highDelay the time in which we want to keep voltage high on pin 10 and this unit is in micro seconds. lowDelay the time in which want to keep voltage zero across pin 10 again this unit is going to be in micro seconds only HIGH part of signal wont operate servo. we have to send complete HIGH and LOW signal to make servo work. deg_factor signal range (2450 - 544) for SG90 divided by 180 which is equal to 10.6 something that we make 11 as an integer. Loop = 20000; 20000 micro seconds or 20 milli seconds is signal cycle or u can say total signal should be equal to 20 milli seconds including HIGH and LOW input. (50Hz) 12345678910111213141516171819202122232425262728293031323334int servoPin = 10; // servo is connected to pin 10.int initialDelay = 544;int highDelay, lowDelay;int deg;int deg_factor = 10; int Loop = 20000; void setup() { pinMode (servoPin, OUTPUT);}void loop() { for (deg = 0;deg &lt;= 180; deg++) { servoWrite(servoPin, deg); } for (deg = 180;deg &gt;= 0; deg--) { servoWrite(servoPin, deg); }}void servoWrite(int servo, int duty){ highDelay = initialDelay + (duty * deg_factor); // setting angle digitalWrite(servo, HIGH); delayMicroseconds(highDelay); lowDelay = Loop - highDelay; digitalWrite(servo, LOW); delayMicroseconds(lowDelay); delay(500);} 시리얼 모니터에 입력한 문자로 서보모터 회전시키기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int servoPin = 10; // servo is connected to pin 10.int initialDelay = 544;int highDelay, lowDelay;int deg = 90; // servo initial degreeint deg_factor = 10; int Loop = 20000; void setup() { Serial.begin(9600); pinMode (servoPin, OUTPUT);}void loop() { servoWrite(servoPin, deg); while(Serial.available() &gt; 0) { char flag=Serial.read(); delay(2); if(flag=='l') { deg = deg - 5; if(deg &lt; 0) { deg = 0; } } if(flag=='r') { deg = deg + 5; if(deg &gt; 180) { deg = 180; } } }void servoWrite(int servo, int duty){ highDelay = initialDelay + (duty * deg_factor); // setting angle digitalWrite(servo, HIGH); delayMicroseconds(highDelay); lowDelay = Loop - highDelay; digitalWrite(servo, LOW); delayMicroseconds(lowDelay); delay(500);} l 을 입력하면, 5도 좌회전하며, ll을 입력하면 10도 좌회전한다. r 을 입력하면, 5도 우회전하며, rr을 입력하면 10도 우회전한다. 서보모터와 인터럽트 동시에 사용하기서보모터가 180도 회전하는 동안, 스위치를 누르면 13번 LED가 토글되도록 만들어보자. schematic sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int servoPin = 10; // servo is connected to pin 10.int initialDelay = 544; int highDelay, lowDelay; int deg;int deg_factor = 10;int Loop = 20000;#define swPin 2#define ledPin 13#define debounceTime 500 // Set debounce Time (unit ms) 버튼을 누른 후 0.5sec 이내에는 버튼 체크하지 않음boolean state = false;void setup() { pinMode(servoPin, OUTPUT); pinMode(swPin, INPUT_PULLUP); pinMode(ledPin, OUTPUT); attachInterrupt(digitalPinToInterrupt(swPin), swInterrupt, FALLING);}void loop() { for (deg = 0;deg &lt;= 180; deg++) { servoWrite(servoPin, deg); } for (deg = 180;deg &gt;= 0; deg--) { servoWrite(servoPin, deg); }}void servoWrite(int servo, int duty){ highDelay = initialDelay + (duty * deg_factor); // setting angle digitalWrite(servo, HIGH); delayMicroseconds(highDelay); lowDelay = Loop - highDelay; digitalWrite(servo, LOW); delayMicroseconds(lowDelay); delay (15);}void swInterrupt() { static unsigned long lastTime = 0; unsigned long now = millis(); if((now-lastTime) &gt; debounceTime) { state=!state; } lastTime = now; digitalWrite(ledPin, state);} 스위치를 눌렀다 뗄 때, 물리적 요인에 의해 다시 스위치가 눌리는 효과가 나타나기도 함 (chattering) Chattering 효과를 방지하기 위해, 하드웨어적으로 콘덴서를 붙이거나, 소프트웨어적으로 debounce 시간을 만들어 해결해야 한다. 레이저 모듈 추가: 서보모터 날개에 부착schematic sketch13번 핀에 레이저모듈을 연결하므로 위 스케치를 그대로 이용 조도센서 추가반대편에 조도센서를 놓고, 레이저 모듈이 움직이는 동안 버튼을 눌러 조도센서를 정확하게 맞추면 점수가 올라가는 게임을 만들어보자. Keypad에서 값을 입력받아 회전시키기schematic sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;Servo.h&gt;#include &lt;Keypad.h&gt;Servo servomotor;int pos = 0;const byte ROWS = 4; // 키패드 배열 선언const byte COLS = 4;char keys[ROWS][COLS] = { // 키패드 정의 {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'},};byte rowPins[ROWS] = {9, 8, 7, 6}; // 키패드 연결 핀 설정byte colPins[COLS] = {5, 4, 3, 2};Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );void setup() { servomotor.attach(10);}void loop() { char keyValue = keypad.getKey(); if(keyValue) { switch(keyValue) { case '0' : // 시리얼 모니터에 0을 입력하면 servomotor.write(0); // 0도 위치로 이동 delay(15); break; case '1' : // 시리얼 모니터에 1을 입력하면 servomotor.write(15); // 15도 위치로 이동 delay(15); break; case '2' : servomotor.write(30); // 30도 위치로 이동 delay(15); break; case '3' : servomotor.write(45); // 45도 위치로 이동 delay(15); break; case '4' : servomotor.write(60); // 60도 위치로 이동 delay(15); break; case '5' : servomotor.write(75); // 75도 위치로 이동 delay(15); break; case '6' : servomotor.write(90); // 90도 위치로 이동 delay(15); break; case '7' : servomotor.write(120); // 120도 위치로 이동 delay(15); break; case '8' : servomotor.write(150); // 150도 위치로 이동 delay(15); break; case '9' : servomotor.write(180); // 180도 위치로 이동 delay(15); break; default : break; } } delay(10);} 비밀번호 확인하여 서보모터 회전시키기서보모터의 날개를 금고의 개폐장치로 사용하여, 비밀번호 금고를 만들어 보자. sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;Keypad.h&gt;#include &lt;Servo.h&gt;int tru=0; // 비밀번호가 맞는지 확인int count=0; // 4자리수 카운트char PW[4]={'1','2','3','A'}; //비밀번호Servo servomotor;// 키패드 설정 시작const byte ROWS = 4;const byte COLS = 4;byte rowPins[ROWS] = {9, 8, 7, 6};byte colPins[COLS] = {5, 4, 3, 2};char keys[ROWS][COLS] = { {'1','2','3', 'A'}, {'4','5','6', 'B'}, {'7','8','9', 'C'}, {'*','0','#', 'D'}};Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );// 키패드 설정 끝void setup() { Serial.begin(9600); servomotor.attach(10); // 서보모터 핀 설정}void loop() { char key = keypad.getKey(); // 키패드 입력 변수 if (key) { Serial.println(key); if(key==PW[count]) { // 입력번호와 비밀번호가 맞으면 count++; // 자리수 카운트 1증가 tru++; // 맞은수 값 1증가 } else if(key!=PW[count]) { // 입력번호와 비밀번호가 틀리면 count++; // 자리수 카운트 값만 1증가 } if(key=='#') // #을 누르면 re(); // 초기화 if(count==4) { // 4자리 입력받은 값이 if(tru==4) // 모두 맞으면 Su(); // 성공 else // 그렇지 않으면(4자리는 입력했는데, 모두 맞지는 않았으면) Fa(); // 실패 tru=0; // tru, count값 초기화 count=0; } }}void Su() { // 성공했을 때 실행 servomotor.write(90); // 90도 돌려서 도어락 열림 Serial.println(&quot;open the door&quot;);}void Fa() { // 실패한 경우는 도어락 잠금 유지 servomotor.write(0); Serial.println(&quot;close the door&quot;);}void re() { // 비밀번호 입력중 #을 입력하면 초기화하고 도어락 잠금 유지 tru=0; count=0; servomotor.write(0); Serial.println(&quot;password reset&quot;);} Joystick을 사용하여 2개의 서보모터 제어하기schematic sketch12345678910111213141516171819202122232425262728293031323334353637383940#define JSTICKPIN A0 // joystick is connected to pin 11int servoPin = 10; // servo is connected to pin 10int initialDelay = 544;int highDelay, lowDelay;int deg, Jstick, duty;int deg_factor = 10; int Loop = 20000;void setup() { pinMode (servoPin, OUTPUT);}void loop() { PrintValue(); Jstick = analogRead(JSTICKPIN); deg = map(Jstick, 0, 1023, 0, 180); servoWrite(servoPin, deg);}void servoWrite(int servo, int duty){ highDelay = initialDelay + (duty * deg_factor); // setting angle digitalWrite(servo, HIGH); delayMicroseconds(highDelay); lowDelay = Loop - highDelay; digitalWrite(servo, LOW); delayMicroseconds(lowDelay); delay (15);}void PrintValue() { Serial.print(analogRead(JSTICKPIN)); Serial.println (&quot; Joystick Value&quot;);}","link":"/2018/09/08/Arduino-%EC%84%9C%EB%B3%B4%EB%AA%A8%ED%84%B0/"},{"title":"Arduino 스위치, 풀다운저항, 풀업저항","text":"Tact Switch Pull-down 동작 Arduino 스위치를 누르면 ON HIGH 스위치에서 손을 떼면 OFF LOW schematic저항(10k 이상)을 GND에 연결한 경우: Pull-down 회로 sketch12345678910111213141516const int switch_R = 2;void setup() { pinMode(switch_R, INPUT); Serial.begin(9600);}void loop() { int i = digitalRead(switch_R); if(i == HIGH) { // 스위치를 누르면 Serial.println(&quot;1&quot;); } else { // 스위치에서 손을 떼면 Serial.println(&quot;0&quot;); }} Pull-up 동작 Arduino 스위치를 누르면 OFF LOW 스위치에서 손을 떼면 ON HIGH schematic저항(10k 이상)을 VCC(5V)에 연결한 경우: Pull-up 회로 sketch12345678910111213141516const int switch_R = 2;void setup() { pinMode(switch_R, INPUT); Serial.begin(9600);}void loop() { int i = digitalRead(switch_R); if(i == HIGH) { // 스위치를 누르면 Serial.println(&quot;1&quot;); } else { // 스위치에서 손을 떼면 Serial.println(&quot;0&quot;); }} 스위치를 사용할 때, 풀다운 or 풀업 저항을 구성해야 하는 이유출처: 풀업(Pull-up)저항, 풀다운(Pull-down)저항 (악보쓰는 프로그래머) Floating 문제 5V에 연결한 경우 GND에 연결한 경우 스위치를 누르면 HIGH, 스위치를 떼면 LOW ? 스위치를 누르면 LOW, 스위치를 떼면 HIGH ? 실제로는 스위치를 누른 상태에는 HIGH이지만, 스위치를 뗀 상태에는 HIGH와 LOW가 섞여서 들어간다 실제로는 스위치를 누른 상태에는 LOW이지만, 스위치를 뗀 상태에는 LOW와 HIGH가 섞여서 들어간다. 즉, 스위치를 누른 상태에서는 어떤 값을 가져야 하는지 확실하지만, 스위치를 뗀 상태에서는 어떤 값을 가져야 하는지 불확실하다는 문제가 발생하는데, 이것이 플로팅이다. Floating의 해결과 또 다른 문제 (아래 그림대로 연결 절대 금지!) 위 그림 2개를 조합하여, 회로를 만든다고 가정하면 스위치를 누르면 HIGH, 스위치를 누르지 않으면 LOW ? (그림대로 연결 절대 금지!) 그러나 위 그림과 같이 연결하면 또다른 심각한 문제가 발생한다. 스위치를 누르는 순간, 5V와 GND가 직접 연결되어 전기적으로 합선(쇼트)이 되기때문에 아두이노 보드가 망가지거나 심한 경우, 아두이노가 연결된 컴퓨터가 망가질 수도 있다. 이 그림은 마치 건전지 양극을 도선으로 그대로 연결한 것과 마찬가지인 상황이며, 실제 건전지에 이와 같은 방법으로 선을 연결하면 건전지가 과열되어 녹거나 심하면 불이 날수도 있다. 문제 해결 방법 이런 문제를 해결하려면, 양극의 사이에 저항을 하나 넣어서 전류의 흐름을 방해하면 된다. 이를 응용하여 스위치의 한쪽에 저항을 하나 추가로 연결하는 것이고, 이것이 바로 풀다운 저항 혹은 풀업 저항을 구성해야하는 이유이다. 아두이노 보드에 내장된 풀업저항 사용하기 스위치를 사용하는 경우, 풀다운 저항 혹은 풀업 저항을 사용해야 하므로. 스위치를 구성할 때마다 10k~100kΩ 정도의 저항을 별도로 준비해서 회로를 구성해야 한다. 매우 중요한 문제이지만, 매우 귀찮기도 하다. 그래서…친절하게도 아두이노 보드는 자체에 풀업 저항을 내장해두었다. 당연한 이야기이지만 아두이노 보드에 내장된 풀업 저항을 사용한다면, 별도의 저항을 준비하지 않아도 되기때문에 회로를 간단하게 구성할 수 있다. 기본적으로 풀업 회로이므로 스위치가 눌리지 않은 상태가 HIGH이며, 스위치가 눌린 상태에서 LOW값을 갖습니다. pinMode 선언시, INPUT_PULLUP을 사용합니다. 1pinMode (2, INPUT_PULLUP); schematic sketch123456789101112131415161718const int switch_R = 2;int R;void setup() { pinMode(switch_R, INPUT_PULLUP); Serial.begin(9600);}void loop() { R = digitalRead(switch_R); if(R == LOW) { // 스위치를 누르면 Serial.println(&quot;0&quot;); } else { // 스위치에서 손을 떼면 Serial.println(&quot;1&quot;); }} 스위치를 눌러 LED 켜기위에서 구성한 풀업 회로에 RGB LED를 추가하여, 각 스위치에 연결된 LED가 점등되도록 구성해보자. schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int switch_R = 2;const int switch_G = 3;const int switch_B = 4;const int pin_ledR = A0;const int pin_ledG = A1;const int pin_ledB = A2;int R, G, B;void setup() { pinMode(switch_R, INPUT_PULLUP); pinMode(switch_G, INPUT_PULLUP); pinMode(switch_B, INPUT_PULLUP); pinMode(pin_ledR, OUTPUT); pinMode(pin_ledG, OUTPUT); pinMode(pin_ledB, OUTPUT); Serial.begin(9600);}void loop() { R = digitalRead(switch_R); G = digitalRead(switch_G); B = digitalRead(switch_B); if(R == LOW) { // R 스위치를 누르면 Serial.println(&quot;R=1&quot;); digitalWrite(pin_ledR, HIGH); } else { // R 스위치에서 손을 떼면 Serial.println(&quot;R=0&quot;); digitalWrite(pin_ledR, LOW); } if(G == LOW) { // G 스위치를 누르면 Serial.println(&quot;G=1&quot;); digitalWrite(pin_ledG, HIGH); } else { // G 스위치에서 손을 떼면 Serial.println(&quot;G=0&quot;); digitalWrite(pin_ledG, LOW); } if(B == LOW) { // B 스위치를 누르면 Serial.println(&quot;B=1&quot;); digitalWrite(pin_ledB, HIGH); } else { // B 스위치에서 손을 떼면 Serial.println(&quot;B=0&quot;); digitalWrite(pin_ledB, LOW); }}","link":"/2018/09/01/Arduino-%EC%8A%A4%EC%9C%84%EC%B9%98-%ED%92%80%EB%8B%A4%EC%9A%B4-%ED%92%80%EC%97%85%EC%A0%80%ED%95%AD/"},{"title":"Arduino 시작하기, RGB LED, PWM","text":"Arduino PinoutDigital &amp; Analog Digital 0~13번 핀 PWM:3,5,6,9,10,11번 핀 (8bit로 0~255의 범위를 사용) Analog Input: ADC 10bit로 0~1023의 범위를 사용 스케치 업로드 중에는 0번핀(RX), 1번핀(TX)을 사용할 수 없다. 전원부 V_in input으로 사용 기본적으로 파워잭을 사용하는 것과 같음 아두이노에 전원을 공급 (6.6V~12V 범위에서 가능) 외부전원이 Vin을 통해 공급되면, USB포트에서 나오는 전원공급은 자동으로 차단됨 최소 전압은 6.6V이나, 다이오드에서의 전압 강하로 인해, 최소 7.2V가 공급되어야 USB포트에서의 전원이 차단되고, 외부전원으로 아두이노가 전원을 공급받기 시작함 output으로 사용 파워잭으로 전원을 공급하면, Vin은 자동으로 OUTPUT용도가 됨 5V보다 큰 전압, 전류를 필요로 하는 장치(모터 등)를 연결할 경우, 파워잭으로 전원을 공급하고 Vin으로 출력 Arduino 보드의 종류 브레드 보드 &amp; 점퍼선 부품, 센서, 모듈, 쉴드 Arduino IDEArduino IDE 설치하기 2021년 9월 현재 최신버전 1.8.60 &amp; 2.0 beta 11 (당분간 1.8.x 버전 설치 추천) 아두이노 홈페이지, www.arduino.cc 에서 다운로드 받아 설치 설치 경로에 한글이 포함되지 않도록 한다. 설치 완료 후, 아두이노 IDE를 실행하면 arduino driver가 설치된다. 모두 설치 호환칩(CH340 or CH341)을 사용하는 아두이노의 경우, 칩제조사 홈페이지에서 별도의 driver를 다운로드 받은 후 추가로 설치해야 한다. CH340/341 호환칩을 사용하는 아두이노 우노보드의 경우 빨간색으로 된 표시된 부분의 칩이 직사각형인 형태로 되어 있는 경우가 많다. 정품의 경우 FT232칩을 사용하며, 대부분의 경우 동일한 위치에 정사각형 모양의 칩을 가지고 있다. 드라이버 추가 설치이외의 기능상의 차이점은 없다. Arduino IDE의 기본 구성 Arduino 연결하기 USB A(M)-B(M) 케이블을 사용하여 PC와 아두이노 우노를 연결한다. (아두이노에 연결하는 포트는 대부분 USB-B(M) type이나, 최근 나오는 일부 호환 보드의 경우 microUSB 포트인 경우도 있다.) 툴&gt; 보드&gt; 에서 Arduino 보드를 선택한다. → Arduino/Genuino Uno 툴&gt; 포트&gt; 에서 Arduino에 연결되어 있는 포트를 선택한다. → COMx (Arduino/Genuino Uno) Arduino 스케치기본 구조123456789블록‘I’ // 블록I은 라이브러리, 변수 선언 (필요없는 경우 생략가능) void setup() { // 블록II 부분을 아두이노 켜질 때 딱 한번 실행 블록‘II’ // 초기화, pinMode … } void loop() { // 블록III 부분을 반복 실행 블록‘III’} Exercise 1:1234567891011121314/* 처음 해보는 아두이노 코딩 LED 깜박이기 */void setup() { pinMode(13, OUTPUT); // digitalWrite 사용시 pinMode 설정해야 함. (플로팅 방지) digitalWrite(13, HIGH); delay(1000); digitalWrite(13, LOW); delay(1000);}void loop() {} void setup에 모든 명령어가 위치 ; (세미콜론)은 문장이 끝났음을 선언 **처음 컴파일하는 경우 파일을 저장하는 절차가 수행되며, 이를 위해 파일 이름을 지정해주어야 함 ** 주석문 사용 방법 (컴파일시 skip) // ~~~~ 1개의 라인만 주석문 처리 /* ~~~~/ 여러개의 라인을 /* */ 안에 넣어서 주석문을 만들 수 있음 pinMode(13, OUTPUT); 13번 핀을 출력 모드로 설정 (※입력 모드로 사용하려면 OUTPUT 대신 INPUT or INPUT_PULLUP 사용) pinMode는 digitalRead, digitalWrite를 사용하는 핀에만 선언 즉, 0과 1의 입출력에만 사용하는 핀에 선언하며, PWM사용핀은 pinMode 선언이 불필요하다. INPUT은 입력핀으로 사용시, OUTPUT은 출력핀으로 사용시 digitalWrite(led, HIGH); 디지털 핀의 전압을 LOW(0의 값) 또는 HIGH(1의 값)로 설정 LOW : 0V (전기가 통하지 않음) HIGH : 5V (전기가 통함) delay(1000); 특정 시간 동안 아두이노를 멈추게 하는 명령 (ms 단위) 1초 : 1000 5초 : 5000 그러므로 위 예제는, 아두이노 보드에 있는 13번 LED가 1초가 켜졌다가 꺼짐 void loop에서 수행할 반복 명령이 없으므로, LED가 꺼진 상태를 그대로 유지 Exercise 2:12345678910void setup() { pinMode(13, OUTPUT);}void loop() { digitalWrite(13, HIGH); delay(1000); digitalWrite(13, LOW); delay(1000);} void setup pinMode는 digitalWrite를 사용하는 pin을 설정하여 플로팅을 방지하는 선언이므로, 한번만 실행하면 됨 void loop에 의해 1초간 켜졌다가, 1초간 꺼지는 것을 반복 Exercise 3: 변수 설정123456789101112int led = 13;void setup() { pinMode(led, OUTPUT);}void loop() { digitalWrite(led, HIGH); delay(1000); digitalWrite(led, LOW); delay(1000);} int led = 13; led 라는 integer (정수) 변수를 선언 led 변수의 값을 13으로 지정 Exercise 4: 상수로 설정하는 경우(1)123456789101112#define led 13void setup() { pinMode(led, OUTPUT);}void loop() { digitalWrite(led, HIGH); delay(1000); digitalWrite(led, LOW); delay(1000);} #define led 13 int led = 13; 을 사용하는 대신 #define으로 상수 선언을 해도 됨 상수 형태로 선언하면 컴파일시에 정의된 값을 참조하여 대체하므로 메모리를 차지하지 않음 #define을 사용하는 경우, 문장 종료 기호인 ;(세미콜론)을 사용하지 않음! Exercise 5: 상수로 설정하는 경우(2)123456789101112const int led = 13;void setup() { pinMode(led, OUTPUT);}void loop() { digitalWrite(led, HIGH); delay(1000); digitalWrite(led, LOW); delay(1000);} const int led = 13; const int led = 13; 형태로 상수 선언을 해도 됨 단, 문장종료 기호인 ;(세미콜론)을 사용함! Blink 예제파일&gt; 예제&gt; 01.Basics&gt; Blink 1234567891011121314151617/* (주석문 생략)*/// the setup function runs once when you press reset or power the boardvoid setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT);}// the loop function runs over and over again forevervoid loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second} Exercise 켜고 끄는 시간을 시간을 2초로 설정해본다. 신호등 LED Exercise빨간색 5초 → 노란색 1초 → 초록색 5초씩 번갈아가면서 점등되도록 만들어 보자. RGB LEDRGB LED의 3색을 교대로 점멸하기 schematic sketch: RGB LED 모듈의 핀이 **(GND,R,G,B)**형태로 구성되어 있는 경우 digitalWrite를 사용하는 경우: HIGH 켜짐, LOW 꺼짐 analogWrite를 사용하는 경우: 0 꺼짐, 255 켜짐 123456789101112131415161718192021int pin_ledR = 9; int pin_ledG = 10; int pin_ledB = 11; void setup() { pinMode(pin_ledR, OUTPUT); pinMode(pin_ledG, OUTPUT); pinMode(pin_ledB, OUTPUT);} void loop() { digitalWrite(pin_ledR, HIGH); delay(1000); digitalWrite(pin_ledR, LOW); digitalWrite(pin_ledG, HIGH); delay(1000); digitalWrite(pin_ledG, LOW); digitalWrite(pin_ledB, HIGH); delay(1000); digitalWrite(pin_ledB, LOW);} 주의사항: RGB LED 모듈의 핀이 (VCC,R,G,B)형태로 구성되어 있는 경우 255에서 각 Color 코드값을 뺀 값으로 사용해야 한다!!! (주의할 것) digitalWrite를 사용하는 경우 HIGH 꺼짐 LOW 켜짐 analogWrite를 사용하는 경우 원래 값이 “0”인 경우 LED가 꺼지는 것이 정상이지만, VCC/R/G/B LED의 경우는 255 - 0 = 255 일때, LED가 꺼짐 원래 값이 “255”인 경우 LED가 켜지는 것이 정상이지만, VCC/R/G/B LED의 경우는 255 - 255 = 0 일때 LED가 켜짐 Red LED의 세기를 “153”으로 주고 싶을 경우, VCC/R/G/B LED에서는 255 - 153 = 102 의 값을 주어야 함 (수정된) sketch: (VCC,R,G,B로 구성된 모듈의 경우)123456789101112131415161718192021int pin_ledR = 9; int pin_ledG = 10; int pin_ledB = 11; void setup() { pinMode(pin_ledR, OUTPUT); pinMode(pin_ledG, OUTPUT); pinMode(pin_ledB, OUTPUT);} void loop() { digitalWrite(pin_ledR, LOW); delay(1000); digitalWrite(pin_ledR, HIGH); digitalWrite(pin_ledG, LOW); delay(1000); digitalWrite(pin_ledG, HIGH); digitalWrite(pin_ledB, LOW); delay(1000); digitalWrite(pin_ledB, HIGH);} PWMArduino PWM 출력 analogWrite() : 8bit를 사용하므로 0~255 범위에서 센서값을 출력 GND,R,G,B로 구성된 모듈의 경우 * analogWrite(pin_ledR, 0); pin_ledR에 연결된 LED를 “켬” * analogWrite(pin_ledR, 255); pin_ledR에 연결된 LED를 끔 PWM 출력이 가능한 디지털핀(3,5,6,9,10,11)을 사용하여 출력 pinMode 선언 불필요 예를들어, pinMode(9, OUTPUT); → 9번 핀으로 PWM 출력을 한다면 불필요한 선언임 sketch: (GND,R,G,B로 구성된 모듈의 경우)123456789101112131415161718int pin_ledR = 9; int pin_ledG = 10; int pin_ledB = 11; void setup() { // pinMode 필요없음} void loop() { analogWrite(pin_ledR, 255); delay(1000); analogWrite(pin_ledR, 0); analogWrite(pin_ledG, 255); delay(1000); analogWrite(pin_ledG, 0); analogWrite(pin_ledB, 255); delay(1000); analogWrite(pin_ledB, 0);} 여러가지 색깔 만들어보기16진수 및 10진수 Color Table ※ 색깔이 미묘하게 다를 수 있다. sketch: 006699 (R:000, G:102, B:153) 색깔 만들기123456789101112int pin_ledR = 9; int pin_ledG = 10; int pin_ledB = 11; void setup() {} void loop() { analogWrite(pin_ledR, 0); analogWrite(pin_ledG, 102); analogWrite(pin_ledB, 153);} Exercise: 무지개 색깔 만들기 1초마다 빨-주-노-초-파-남-보 순서대로 색깔이 출력되도록 만들어 본다. (색상표에서 가장 비슷한 색깔 선택) 각 색깔을 출력한 뒤 delay(1000); 을 추가하여야 1초간 해당 색깔이 유지된다. 빨 주 노 초 파 남 보 R color code G color code B color code RGB Gradation: 그라데이션 효과를 주어 색깔 바꿔보기 빨간색 (R:255, G:0, B:0)에서 초록색 (R:0, G:255, B:0)으로 색깔 바꾸기 R값이 255에서 시작하여 0까지 감소하는 동안 G값은 0에서 시작하여 255까지 감소하면 된다. B는 0 유지 for문 사용하기 기본 문법 123for(초기값; 조건; 증감) { 반복처리문;} 예를들어 123for(R=255; R&gt;=0; R--) { 반복처리문;} R값이 255부터 0보다 크거나 같을 때(0)까지 R값을 1씩 감소시키면서 반복처리문을 실행 즉, 반복처리문을 256회 실행 Color값 변화시키기 먼저 변화하는 값을 저장할 변수를 설정하고, 초기값으로 0을 지정 (초기값은 지정하지 않아도 됨) 123int R = 0;int G = 0;int B = 0; R값을 255부터 0까지 감소시키면서, G값은 0에서 255까지 감소시킴 123for(R=255; R&gt;=0; R--) { G = 255 - R;} 여기에 analogWrite를 추가하고, 색깔이 일정한 시간동안 나타난 뒤 바뀌도록 delay를 추가 1234567for(R=255; R&gt;=0; R--) { G = 255 - R; analogWrite(pin_ledR, R); analogWrite(pin_ledG, G); analogWrite(pin_ledB, 0); delay(10);} 빨간색&gt;초록색 그라데이션 코드 완성하기1234567891011121314151617181920int R = 0;int G = 0;int B = 0;int pin_ledR = 9; int pin_ledG = 10; int pin_ledB = 11; void setup() {} void loop() { for(R=255; R&gt;=0; R--) { G = 255 - R; analogWrite(pin_ledR, R); analogWrite(pin_ledG, G); analogWrite(pin_ledB, 0); delay(10); }} Exercise: 빨간색&gt;초록색&gt;파란색&gt;(반복)&gt;&gt; 그라데이션 Analog 신호의 처리가변저항 값을 시리얼모니터에 출력하기ANALOG IN(A0~A5) 핀의 역할 아날로그 입력으로 사용 : analogRead() analogRead()는 pinMode 선언 불필요 예를들어, pinMode(A0, INPUT); → 불필요한 선언임 PWM을 사용하는 디지털 입력으로 사용 : analogRead() analogRead() : 10bit를 사용하므로 0~1023 범위에서 센서값을 읽음 schematic sketch1234567891011int value_potentiometer = 0; // potentiometer valuevoid setup() { Serial.begin(9600); }void loop() { value_potentiometer = analogRead(A0); // 10bit (0~1023) Serial.println(value_potentiometer); delay(100);} 가변저항 값에 따라 LED 밝기 조절하기schematic sketch123456789101112131415int pin_ledB = 11; // Blue LED for PWMint value_potentiometer = 0; // potentiometer valuevoid setup() { Serial.begin(9600); }void loop() { value_potentiometer = analogRead(A0); // 10bit (0~1023) value_potentiometer = map(value_potentiometer, 0, 1023, 0, 255); // 10bit → 8bit analogWrite(pin_ledB, value_potentiometer); Serial.print(&quot;illumination level: &quot;); Serial.println(value_potentiometer); delay(100);} 시리얼 모니터 사용하기123456789101112131415161718void setup() { Serial.begin(9600); // 시리얼 모니터 사용 선언, 출력속도 지정 9600 Baud rate}void loop() { Serial.print(&quot;A&quot;); // print 출력 Serial.println(&quot;B&quot;); // println 출력 후 줄바꾸기 Serial.print(&quot;C&quot;); Serial.println(&quot;D&quot;); Serial.println(); for(int i=1; i&lt;11; i++) { Serial.println(i); // 변수값 출력 } delay(5000); Serial.println();} Excercise 1. 시리얼 모니터에 출력해보기 12345678910**************************************************************************************************** 1234567891011121314151617void setup() { Serial.begin(9600); // 시리얼 모니터 사용 선언, 출력속도 지정 9600 Baud rate}void loop() { Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); Serial.println(&quot;**********&quot;); delay(5000);} for문을 사용하여 위 모양대로 출력해보기 1234567891011void setup() { Serial.begin(9600); // 시리얼 모니터 사용 선언, 출력속도 지정 9600 Baud rate}void loop() { for(int i=1; i&lt;=10; i++) { // 1 ~ 10행 Serial.println(&quot;**********&quot;); } Serial.println(); delay(5000);} Excercise 2. 시리얼 모니터에 출력해보기 12345678910******************************************************* 123456789101112131415161718void setup() { Serial.begin(9600); // 시리얼 모니터 사용 선언, 출력속도 지정 9600 Baud rate}void loop() { Serial.println(&quot;*&quot;); Serial.println(&quot;**&quot;); Serial.println(&quot;***&quot;); Serial.println(&quot;****&quot;); Serial.println(&quot;*****&quot;); Serial.println(&quot;******&quot;); Serial.println(&quot;*******&quot;); Serial.println(&quot;********&quot;); Serial.println(&quot;*********&quot;); Serial.println(&quot;**********&quot;); delay(5000); Serial.println();} for문을 사용하여 위 모양대로 출력해보기 1234567891011121314void setup() { Serial.begin(9600); // 시리얼 모니터 사용 선언, 출력속도 지정 9600 Baud rate}void loop() { for(int i=1; i&lt;=10; i++) { // 1 ~ 10행 for(int j=1; j&lt;=i; j++) { // 1 ~ 10열 Serial.print(&quot;*&quot;); } Serial.println(); } delay(5000); Serial.println();}","link":"/2018/09/01/Arduino-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Arduino, 온도측정(DS18b20)","text":"DS18b20 온도센서DS18b20 온도 센서를 이용하여 온도를 측정한다. one-wire 버스 통신 공급전압: 3.0V ~ 5.5V 작동온도: -55ºC ~ +125ºC 오차: +/-0.5 ºC (-10ºC ~ 85ºC 범위에서) Pinout schematicDS18b20 센서는 두 가지 연결방법을 제공하는데, 하나는 VCC를 5V에 연결하는 Normal Mode이고 다른 하나는 VCC를 GND에 연결하는 Parasite Mode이다. 두가지 방법 모두 지원되지만 (경험상) Normal를 추천하며 (원인은 잘 모르겠지만) Parasite Mode에서는 온도센서가 작동이 되지 않는 경우도 가끔 있었다. 회로 구성을 위해 4.7㏀ 저항 1개가 필요하며 Normal Mode 구성을 위해 다음 그림과 같이 연결한다. 3가닥의 선에 브레드보드에 연결할 수 있는 핀을 납땜하고, 노란색선과 빨간색선의 연결부위에 4.7㏀ 저항을 추가로 납땜하여 연결한다. 수축튜브를 사용하여 연결부위를 절연한 뒤, 구경이 조금 더 큰 수축튜브를 사용하여 3가닥을 하나로 감싸 마무리한다. Normal Mode DS18b20 Yellow Red Black Arduino 2 5V GND 4.7㏀ O O Parasite Mode DS18b20 Yellow Red Black Arduino 5V 2 GND GND 4.7㏀ O O sketch라이브러리 준비하기 OneWire (by Jim Studt etc.) DallasTemperature (by Miles Burton) sketch123456789101112131415161718192021222324252627#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 2OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);void setup() { Serial.begin(9600); Serial.println(&quot;DallasTemperature IC Control&quot;); // Start up the library sensors.begin();}void loop() { sensors.requestTemperatures(); float temperatureC = sensors.getTempCByIndex(0); float temperatureF = sensors.getTempFByIndex(0); Serial.print(temperatureC); Serial.println(&quot;*C&quot;); Serial.print(temperatureF); Serial.println(&quot;*F&quot;); delay(2000);} TM1637에 온도 표시하기 schematic: Normal Mode sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;Arduino.h&gt;#include &lt;TM1637Display.h&gt;// Module connection pins (Digital Pins)#define CLK 4#define DIO 7TM1637Display display(CLK, DIO);uint8_t data[] = { 0xff, 0xff, 0xff, 0xff };int seg3, seg2, seg1, seg0;// DS18b20 Temperature Sensor Setting#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 2OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);float celciusTemperature; // Celcius Temperatureint tempTemperature;void setup() { Serial.begin(9600); Serial.println(&quot;DallasTemperature IC Control&quot;); // DS18b20 Temperature Sensor Initialize sensors.begin(); // TM1637 Initialize display.setBrightness(15); // 0 ~ 15 (15가 가장 밝음) // display.setBrightness(0x0f);}void loop() { sensors.requestTemperatures(); celciusTemperature = sensors.getTempCByIndex(0); Serial.print(&quot;Temperature is: &quot;); Serial.println(celciusTemperature); tempTemperature = celciusTemperature * 100; seg0 = (tempTemperature / 1000) % 10; // 4자리에서 1000의 자리 숫자 저장 seg1 = (tempTemperature / 100) % 10; // 4자리에서 100의 자리 숫자 저장 seg2 = (tempTemperature / 10) % 10; // 4자리에서 10의 자리 숫자 저장 seg3 = tempTemperature % 10; // 4자리에서 1의 자리 숫자 저장 data[0]=display.encodeDigit(seg0); // 첫번째 FND에 1000의 자리 숫자배열 data[1]=display.encodeDigit(seg1); // 두번째 FND에 100의 자리 숫자 배열 data[2]=display.encodeDigit(seg2); // 세번째 FND에 10의 자리 숫자 배열 data[3]=display.encodeDigit(seg3); // 네번째 FND에 1의 자리 숫자 배열 // 온도가 100도보다 높으면 소수점 첫째자리까지 출력 if (celciusTemperature &gt;= 100) { display.showNumberDecEx(tempTemperature, (0x80 &gt;&gt; 2), true); } // 온도가 100도보다 낮으면 소수점 둘째자리까지 출력 else { display.showNumberDecEx(tempTemperature, (0x80 &gt;&gt; 1), true); } delay(2000);}","link":"/2018/09/01/Arduino-%EC%98%A8%EB%8F%84%EC%B8%A1%EC%A0%95-DS18b20/"},{"title":"Arduino, 온도 및 습도 측정 (DHT22)","text":"온습도 센서 DHT22DHT22 센서를 이용하여 온도와 습도를 측정한다. 센서 DHT11 DHT22 (AM2302) 사진 온도 0 ~ 50℃ (오차범위 ±2℃) -40 ~ 100℃ (오차범위 ±0.5℃) (해상도 0.1℃) 습도 20 ~ 90% (오차범위 ±5%) 0 ~ 100% (오차범위 ±2~5%) (해상도 0.1%) Pinout DHT22 DAT VCC GND Arduino 8 5V GND schematic 라이브러리 준비하기Case1: 위 사진과 같은 형태의 DHT22 모듈을 사용하는 경우 라이브러리 매니저검색창에 검색어로 ‘AM2302’를 입력 Groove Temperature And Humidity Sensor (by Seeed Studio) 설치 Case2: 위 라이브러리로 동작하지 않는 경우2개의 라이브러리가 필요합니다. 먼저 DHT sensor library (by Adafruit)를 검색하여 설치를 클릭합니다. 그러면 Dependencies for library DHT sensor library 창이 나타나는데, 이때 Install all을 클릭하면 2개의 라이브러리가 동시에 설치됩니다. 두 개의 라이브러리를 설치하기만 하면 되기때문에, 순서가 바뀌어도 관계없습니다. sketch12345678910111213141516171819202122232425262728293031#include &lt;DHT.h&gt;#define DHTPIN 8 // data pin#define DHTTYPE DHT22 // change to DHT11 if you're using the DHT11 // AM2301(DHT21) -&gt; DHT21, AM2302(DHT22) -&gt; DHT22DHT dht(DHTPIN, DHTTYPE);void setup() { Serial.begin(9600); dht.begin();}void loop() { delay(2000); // float temperature = dht.readTemperature(); // float humidity = dht.readHumidity(); float temp_hum_val[2] = {0}; if(!dht.readTempAndHumidity(temp_hum_val)){ Serial.print(&quot;Temperature: &quot;); Serial.print(temp_hum_val[1]); Serial.print(&quot; *C\\t,\\t&quot;); Serial.print(&quot;Humidity: &quot;); Serial.print(temp_hum_val[0]); Serial.println(&quot; %&quot;); } else{ Serial.println(&quot;Failed to get temprature and humidity value.&quot;); }} 1602 LCD에 온도, 습도 출력하기schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;DHT.h&gt;#define DHTPIN 8 // data pin#define DHTTYPE DHT22 // change to DHT11 if you're using the DHT11 // AM2301(DHT21) -&gt; DHT21, AM2302(DHT22) -&gt; DHT22DHT dht(DHTPIN, DHTTYPE);// I2C 1602 LCD (연결핀을 바꿀 수 없음)// VCC-5V / GND-GND / SDA-A4 / SCL-A5#include &lt;Wire.h&gt;#include &lt;LiquidCrystal_I2C.h&gt;// i2c address 는 칩에 따라 0x27, 0x3F값을 가짐LiquidCrystal_I2C lcd(0x27, 16, 2); void setup() { Serial.begin(9600); dht.begin(); // lcd 초기화 lcd.init(); lcd.backlight();}void loop() { delay(2000); // float temperature = dht.readTemperature(); // float humidity = dht.readHumidity(); float temp_hum_val[2] = {0}; if(!dht.readTempAndHumidity(temp_hum_val)){ Serial.print(&quot;Temperature: &quot;); Serial.print(temp_hum_val[1]); Serial.print(&quot; *C\\t,\\t&quot;); lcd.setCursor(0, 0); lcd.print(&quot;Temp. : &quot;); lcd.print(temp_hum_val[1]); lcd.print(&quot;*C&quot;); Serial.print(&quot;Humidity: &quot;); Serial.print(temp_hum_val[0]); Serial.println(&quot; %&quot;); lcd.setCursor(0, 1); lcd.print(&quot;Humi. : &quot;); lcd.print(temp_hum_val[0]); lcd.print(&quot; %&quot;); } else{ Serial.println(&quot;Failed to get temprature and humidity value.&quot;); }}","link":"/2018/09/02/Arduino-%EC%98%A8%EC%8A%B5%EB%8F%84%EC%B8%A1%EC%A0%95-DHT22/"},{"title":"Arduino, 키패드 사용하기","text":"4×4 매트릭스 키보드키패드 입력값을 시리얼 모니터로 출력해보자. schematic Pin Map Arduino Keypad 일부 Keypad의 경우 2 1 8 3 2 7 4 3 6 5 4 5 6 5 4 7 6 3 8 7 2 9 8 1 주의 : Keypad 제조회사에 따라 통상적인 배선 순서와는 반대로 해야하는 경우도 있다. 키패드의 단자에 단자번호가 적혀있지 않으므로, 일단 통상적인 배선순서에 따라 연결해보고 시리얼 모니터를 통해 출력되는 값을 보고 확인해야 한다. 라이브러리 추가하기Keypad 라이브러리는 아두이노 IDE에 기본으로 포함되어 있지 않으므로, 컴파일 전에 라이브러리를 추가한다. 1. 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; 라이브러리 매니저 검색창에서 keypad 검색 Keypad by Mark Stanley, Alexander Brevig 라이브러리 설치 2. 스케치&gt; 라이브러리 포함하기 에서 Keypad를 선택하면 1#include &lt;Keypad.h&gt; 라이브러리가 스케치에 추가된다. sketch1234567891011121314151617181920212223242526#include &lt;Keypad.h&gt;const byte ROWS = 4; //배열const byte COLS = 4; //배열char keys[ROWS][COLS] = { //배열 {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'}};byte rowPins[ROWS] = {9, 8, 7, 6}; //핀 지정byte colPins[COLS] = {5, 4, 3, 2}; //핀 지정Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );void setup(){ Serial.begin(9600); //시리얼 통신 9600}void loop(){ char key = keypad.getKey(); //읽어온 값을 key에 저장 if (key){ Serial.println(key); //key값을 시리얼 모니터에 출력한다 }} 툴&gt; 시리얼 모니터(혹은 Ctrl-Shift-M) 에서 확인한다.","link":"/2018/09/07/Arduino-%ED%82%A4%ED%8C%A8%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"Bluetooth Serial Controller 앱","text":"Bluetooth 시리얼 통신Bluetooth Serial Controller 앱을 통하여 아두이노와 스마트폰 간의 간단한 시리얼 통신을 해보겠습니다. 이를 위해서는 먼저 Bluetooth 페어링 문서를 참고하여 블루투스 모듈과 스마트폰을 페어링 해두어야 합니다. 페어링이 완료된 후 시리얼 통신을 진행합니다. schematic sketch12345678910111213141516171819#include &lt;SoftwareSerial.h&gt;SoftwareSerial BTSerial(2, 3); //Connect HC-06 TX,RX void setup() { Serial.begin(9600); Serial.println(&quot;Hello!&quot;); // set the data rate for the BT port BTSerial.begin(9600); }void loop() { if (BTSerial.available()) Serial.write(BTSerial.read()); if (Serial.available()) BTSerial.write(Serial.read()); } 스마트폰에 Bluetooth Serial Controller 앱 설치하기 이제 Google Playstore를 통해서 스마트폰에 Bluetooth Serial Controller 앱을 설치합니다. (iOS는 유사한 프로그램으로 설치) ​ 비슷한 역할을 하는 수많은 앱들이 있는데, 여러 앱을 설치하고 사용해본 결과, 이 앱이 사용하기에 유연함을 갖고 있는 것 같더군요. ​ 설치되었습니다. 설치 후 처음 실행을 하면, LANDSCAPE 모드(가로모드)로 실행이 되는데요. 그대로 사용해도 무방하지만 PORTRAIT 모드(세로 모드)로 바꿔보겠습니다. 먼저 PREFERENCE를 누르세요. 그러면 아래 화면이 뜹니다. 아무곳이나 누르고 위로 스크롤을 하면 아래에 숨겨져 있는 메뉴가 나타나게 되는데요. OPTION - Orientation을 선택한 뒤, PORTRAIT를 누릅니다. 이제 세로모드로 나타나요. 이제 HC-06모듈과 스마트폰과의 Serial 통신을 해보도록 하겠습니다. 다시 PREFERENCE를 누르고, TERMINAL MODE를 활성화 시키세요. 아래 화면이 TERMINAL Mode 화면입니다. 여기서 돋보기 모양을 누르고, Paired Devices 목록에서 SKS100을 선택하세요. 그러면 TERMINAL이 HC-06에 접속하여, 서로간 통신할 수 있는 상태가 됩니다. ​ 만일, 아래와 같이 Paired Devices 목록이 없으면, Scan for devices를 눌러 HC-06을 찾아보세요. TERMINAL이 SKS100에 접속을 시도합니다. 접속 완료! 터미널과 Serial 통신하기 이제 터미널 창에 Test를 입력하고 SEND를 눌러보세요. 그러면 화면에 Test가 출력됨과 동시에, ​ 시리얼 모니터에 Test가 출력됩니다. 즉, TERMINAL에서 입력한 Test라는 글자가 HC-06을 통해, 아두이노와 연결되어 있는 컴퓨터의 시리얼 모니터에 출력된 것이에요. 이번에는 반대로 시리얼 모니터에 Good morning! 을 입력하고 전송을 누르면 ​ 스마트폰의 TERMINAL에 Good morning! 이 출력됩니다.","link":"/2019/10/17/Bluetooth-%EC%8B%9C%EB%A6%AC%EC%96%BC-%ED%86%B5%EC%8B%A0/"},{"title":"Blynk에 센서값 출력하기","text":"원문: http://help.blynk.cc/en/articles/512056-how-to-display-any-sensor-data-in-blynk-app 센서값을 Blynk로 출력하기 위해서는 Blynk가 연결되지 않은 상태에서 시리얼모니터에 센서값들을 출력할 수 있어야 한다. ​센서값을 출력하는 코드가 완성되면, 그 다음으로 Blynk에 센서값을 보내는 작업을 시작하는 것이 좋다. Blynk앱에 센서값을 표시하는 방법에는 크게 두가지 방법이 있으며, 진행중인 프로젝트에 따라 적절한 방법을 선택하면 된다. PULL 이 경우에 블링크는 앱이 열려있는 동안에만 Blynk에서 값을 받는다. 앱에서 센서값을 표시하는 가장 간단한 방법이며, Blynk 앱의 Virtual Pins이 구동중일때 센서값을 가져온다. (Blynk를 닫거나 백그라운드에서 실행될때 데이타는 요청되지 않는다.) 타이머를 사용할 필요가 없으므로 코딩이 단순한 편이지만, 데이터가 서버에 저장되지 않으므로 히스토리 그래프를 볼 수 없다는 단점이 있다. Blynk 앱 설정 새 프로젝트를 만든다. (새로운 Auth Token값이 당신의 이메일에 전송된다) Value Display 위젯을 추가한다. 위젯 세팅으로 가서 PIN 항목을 Virtual Pin V5로 설정한다. Reading Rate를 3초로 설정한다. sketch Analog Pin에서 값을 (간단하게) 읽어들이는 경우에는 코드를 쓸 필요가 없다. 단지 예제파일을 오픈하여 하드웨어와 커넥션만 변경한다. e-mail을 체크하여 Auth Token을 확인하고, 스케치에 Auth Token을 수정입력한다. 하드웨어에 코드를 업로드한다. Blynk에서 플레이버튼을 누른다. 값이 표시되는 것을 볼 수 있다. 1234BLYNK_READ(V5) { //Blynk app has something on V5 sensorData = analogRead(A0); //reading the sensor on A0 Blynk.virtualWrite(V5, sensorData); //sending to Blynk} 이 코드는 매시간마다 Blynk가 _READ 요청을 Virtual Pin V5에 보내도록 한다. A0핀에서 센서값을 읽은 후, Blynk에서 Virtual Pin V5에 되돌려 준다. PUSH 이 경우 하드웨어(아두이노 or ESP32 등)는 Blynk가 오프라인 상태일때도 센서값을 Blynk 서버에 저장하고, 앱을 열어 온라인 상태가 되면 앱으로 전송하여 센서값을 보여준다. Virtual Pin을 통하여 일정 주기로 하드웨어로부터 센서값을 전송하고, 이때마다 Blynk가 값을 받아들인다. 주의할 점void loop() 에서는 센서 값을 보낼 수 없다!!! 만약 void loop()문 내에 어떤 값을 넣게 되면 MCU가 아주 짧은 시간 간격으로 무한 반복하여 실행하게 되는데, Blynk는 인터넷을 통하여 값을 전송할 것이므로 Blynk 클라우드가 하드웨어로부터 오는 계속적인 데이터를 받게 될 것이다. Blynk 클라우드가 이러한 상황을 감지하면 자동적으로 접속을 끊게 된다. 그러므로 데이타를 일정 간격으로 보내야하며, 이를 위해 타이머를 사용하는 방법을 취한다. 일정간격으로 데이타를 보내는 방법에는 여러가지가 있지만, 가장 간단한 방법으로 BlynkTimer의 사용을 권장한다. BlynkTimer는 Blynk 라이브러리 패키지안에 포함되어 있으므로, Blynk 라이브러리만 제대로 설치되었다면 별도의 라이브러리를 설치하지 않아도 된다. Blynk 앱 설정 새 프로젝트를 만든다. (새로운 Auth Token값이 당신의 이메일에 전송된다) Value Display 위젯을 추가한다. 위젯 세팅으로 가서 PIN 항목을 Virtual Pin V5로 설정한다. Frequency를 PUSH로 설정한다. Example timer라고 하는 BlynkTimer 오브젝트를 만든다.1BlynkTimer timer; // Announcing the timer 그 다음으로 일정 간격으로 실행하게 될 함수를 만든다. 이 함수는 A0에 연결된 센서로부터 값을 Virtual Pin V5를 통하여 전송한다.1234void myTimerEvent() { sensorData = analogRead(A0); Blynk.virtualWrite(V5, sensorData);} setup()문에서, 서브함수 myTimerEvent()가 매 1000ms, 즉 1초 간격으로 실행되도록 선언할 것이다.123456void setup() { ... ... ... timer.setInterval(1000L, myTimerEvent);} loop문은 다음과 같이 설정한다.1234void loop() { Blynk.run(); timer.run(); // running timer every second}","link":"/2019/10/18/Blynk%EC%97%90-%EC%84%BC%EC%84%9C%EA%B0%92-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/"},{"title":"esp32 ADC","text":"ESP32 ADC ESP32는 18개의 12bit ADC 입력핀을 사용할 수 있다. (0~4095) 아두이노의 경우 10bit를 사용한다. (0~1023) 0V ~ 3.3V의 전압을 0~4095(0xFFF)까지의 디지털값으로 AD 변환한다. Arduino IDE 환경에서는 ESP32의 ADC 관련 레지스터를 조작하지 않고 analogRead() 함수를 사용하여 ESP32의 ADC 입력핀의 전압값을 가져올 수 있다. Potentiometer 저항값 출력하기schematic sketch가변저항의 저항을 A0(ADC1_CH0, GPIO36)로 읽고 전압값으로 변환한 뒤 시리얼 모니터로 출력한다. 12345678910111213141516171819// ESP32 ADC test#define analogPin A0void setup() { Serial.begin(115200);} void loop() { // read the input on analog pin GPIO36 (ADC1_CH0): int sensorValue = analogRead(analogPin); // Convert the analog (12bit ADC : 0 - 4095) to a voltage (0 - 3.3V): float voltage = (sensorValue /4095.0) * 3.3; // print out the value you read: Serial.println(voltage); delay(200);} Potentiometer로 LED 밝기 조절하기schematic LED : R → GPIO19 / G → GPIO18 / B → GPIO17 / GND 저항 : R → 150Ω / G → 100Ω / B → 100Ω Potentiometer: Left 5V, Center AO(IO36), Right GND sketch12345678910111213141516171819202122#define RED_LED 19 // GPIO 19#define analogPin A0 // Sensor VP, GPIO 36int freq = 5000; // 주파수int ledChannel = 0; // 채널 (0 ~ 15 선택)int resolution = 10; // 해상도 (1 ~ 16bit resolution 선택)int R = 0;void setup() { Serial.begin(115200); ledcSetup(ledChannel, freq, resolution); // 지정된 채널, 주파수 및 해상도 설정 ledcAttachPin(RED_LED, ledChannel); // LED 핀과 채널 연결}void loop() { float raw = analogRead(analogPin); R = map(raw, 0, 4095, 0, 1023); // 12bit -&gt; 10bit Serial.print(R); Serial.println(&quot; ohm&quot;); ledcWrite(ledChannel, R); delay(7);}","link":"/2019/10/20/ESP32-ADC/"},{"title":"esp32-WROOM-32D DevkitC V4","text":"ESP32-WROOM-32D DevkitC V4 핀아웃 다운로드 녹색핀: 사용에 적합한 핀 노란색: 사용은 가능하나 부팅시 예기치 않은 동작이 발생할 수 있으므로 주의해야 하는 핀 (GPIO34~39는 Input only!) 빨간색: 입력 또는 출력으로 사용할 수 없는 핀을 의미한다. (사용이 가능하더라도 사용하지 않음!) 보라색: Wifi사용시 사용불가한 analog핀 GPIO에서 Output이 가능한 모든 핀은 PWM으로 사용 가능 ADC: 03.3V (04095) (00.15V구간과 3.13.3V의 값은 리니어하지 않으므로 구별이 거의 불가능함 I2C: 아두이노IDE에서 사용하는 디폴트 핀 RTC GPIO: Ultra Low Power(Deep Sleep)모드의 ESP32를 Wake up Strapping Pins: Bootloader나 Flashing시에 사용되며, 코드 업로드시 문제될 수 있음 High at Boot, Low at Boot, BOOT, PWM at Boot: Boot시 신호가 나오며, Output으로 사용하면 reset이나 booting시에 문제가 될 수 있는 핀 PeripheralADC와 DAC 기능은 특정 핀에 고정되어 있다. 하지만 UART, I2C, SPI, PWM등의 기능은 어느 핀에 사용할지 결정해서 코드에서 지정해 줘야 한다. 소프트웨어에서 핀의 속성을 정의해 줄 수 있지만, 각 핀들은 디폴트로 지정되어 있는 기능들이 있다. (Pinout 참고) Pheripheral ADC Channel SP UART I2C PWM DAC I2S Capacitive touch GPIO 개수 18 3 3 2 16 2 2 10 PWM(Pulse Width Modulation)ESP32는 16개의 독립적인 채널을 통해 각각 다른 속성의 PWM 신호를 만들 수 있다. 출력으로 사용할 수 있는 모든 핀은 PWM으로 사용할 수 있으며, GPIO 34~39는 Input only핀이므로 PWM으로 사용할 수 없다. PWM신호를 만들기 위해 코드상에 4개의 파라미터를 정해주어야 한다. Signal Frequency Duty Cycle PWM Channel 신호를 출력할 GPIO핀 I2CI2C를 디폴트가 아닌 다른 핀을 사용할 경우, 아래와 같은 코드를 통해 지정한다. (디폴트 SDA 21, SCL 22) 1Wire.begin(SDA, SCL); Interrupts모든 GPIO핀은 인터럽트로 사용할 수 있다. EN (Enable)풀업되어 있는 3.3V 레귤레이터의 enable 핀이다. GND에 연결하면 3.3V 레귤레이터가 비활성화된다. 이 핀을 푸쉬버튼에 연결하면 ESP32를 재시동하는데 사용할 수 있다. GPIO Current draw권장 동작 조건에 따라 GPIO마다 최대 40mA의 전류를 흘릴 수 있다. VinESP32 보드에 전원을 공급하는 방법은 3가지가 있다. USB 포트를 통한 공급 5V/GND 핀을 통한 공급 5V핀을 통해서 전원을 공급할 경우, 전압은 5~12V 정도 사용하면 된다. 최적 공급 전압은 6~7V 정도이며, 이보다 높은 전압을 공급할 경우 과열될 수 있다. 5V 공급시 소비전류는 128mA이며, 10V 공급시 99.9mA 정도를 유지한다. 3.3V/GND핀을 통한 공급 3.3V핀을 통해서 전원을 공급할 경우에는, 공급 전압을 (정확하게) 3.3V로 유지해야 한다. 위 3가지 중 1가지 방법만으로 전원을 공급해야하며, 동시에 2~3가지 방법을 사용하면 ESP32 보드 자체가 고장날 수 있음에 유의한다. Troubleshooting1) 업로드시 error 메세지12345Warning: Could not auto-detect Flash size (FlashID=0xffffff, SizeID=0xff), defaulting to 4MBCompressed 8192 bytes to 47...A fatal error occurred: Timed out waiting for packet contentA fatal error occurred: Timed out waiting for packet content GPIO12에 풀업을 넣을 경우 플래시 인식 오류가 발생한다. GPIO12 핀은 사용하지 않는 것이 좋다. 그밖의 보드TTGO T-Energy TTGO T-BEAM","link":"/2019/10/19/ESP-WROOM-32D-DevkitC-V4/"},{"title":"esp32 BLE, Blynk Button","text":"Blynk를 처음 사용하는 경우Blynk 라이브러리 설치하기 docs.blynk.cc 접속 – Downloads – Blynk Library https://github.com/blynkkk/blynk-library/releases/tag/v0.6.1 Blynk_Release_v0.6.1.zip 다운로드 압축을 풀면 libraries, tools 폴더가 보임 이 두 폴더를 아두이노IDE의 기본 스케치북 위치로 복사하여 붙여넣기 함 기존의 libraries 폴더와 합쳐짐 기본 스케치북 위치 확인 방법 아두이노IDE – 파일 – 환경설정 – 설정탭 – 스케치북 위치 스마트폰에 Blynk App 설치하기 아이폰 : 애플 앱스토어 안드로이드 : 구글 플레이스토어 버튼 위젯을 이용한 LED On/Off 하기schematic ※ RGB LED 모듈을 사용하는 경우에는 저항을 연결하지 않는다. Blynk 설정 Blynk App 실행 Create New Account : 주로 사용하는 e-mail을 사용하여 계정 생성 (계정이 이미 생성되어 있는 경우에는 Log In) New Project 생성 : ESP32_LED 프로젝트명 : ESP32_LED CHOOSE DEVICE : ESP32 Dev Board CONNECTION TYPE : BLE Create를 누르면 Blynk 가입시 계정으로 사용한 이메일로 Auth Token 발송된다. OK버튼을 누르면 프로젝트가 생성된다. 컴퓨터를 사용하여 이메일 계정에 로그인 한 후, Auth Token을 복사한다. (복잡한 형태의 토큰을 코딩시 사용할 것이므로, 스마트폰인 아닌 컴퓨터에서 확인하여 복사하는 것이 좋다.) Blynk 위젯 설정 : 생성된 프로젝트(ESP32_LED) 바탕화면으로 진입하면 Blynk App 상단의 초록색 메뉴바의 이름이 “ESP32_LED”로 바뀐다. 만약, 아래와 같이 초록색 메뉴바의 이름이 “Blynk”로 되어있다면, 프로젝트 바탕화면으로 진입하지 못한 것이다. 이때에는 검은색 바탕화면의 “ESP32_LED”프로젝트명을 확인한 후 터치하면 해당프로젝트로 진입할 수 있다. 기존에 다른 프로젝트를 만들어 둔 적이 있다면 검은색 바탕화면의 프로젝트명이 “ESP32_LED”가 아닐 수도 있다. 이런 경우에는 스마트폰 화면을 좌우로 스크롤하여 프로젝트명을 변경한 후 진입한다. 프로젝트 바탕화면에서 ⊕버튼을 누른 후, Button 위젯과 BLE 위젯을 눌러 추가한다. 프로젝트 바탕화면에 두개의 위젯이 표시된다. BUTTON 위젯을 누르면 Buttom Settings 화면이 나타난다. 여기서 PIN부분을 누른다. LED를 연결한 PIN을 선택한다. 여기서는 Digital GP19를 선택하였다. OK버튼을 누르면 OUTPUT 버튼이 GP19로 설정된다. Mode는 SWITCH로 설정한다. Blynk App 상단의 뒤로가기 버튼을 누른뒤 프로젝트 바탕화면으로 간다. Blynk 연결하기 Arduino IDE에서 예제를 로드한다. 파일&gt; 예제&gt; Blynk&gt; Boards_Bluetooth&gt; ESP32_BLE 예제의 char auth[] = “YourAuthToken”; 부분을 찾아서 쌍따옴표 사이의 YourAuthToken을 지운 뒤, 이메일에서 복사한 AuthToken 붙여넣은 뒤, 다른 이름으로 저장한다. 예제의 Blynk.setDeviceName(“Blynk”); 부분을 찾아 따옴표 안의 BLE Device 이름을 적당한 이름으로 바꿔준다. (※이름을 바꿔주지 않으면 주변의 다른 기기와 중복되어 오작동할 소지가 있으므로 반드시 다른 이름으로 바꿔주어야 한다.) Device Name을 “Blynk-t”로 수정하였다. ESP32에 스케치를 업로드한다. (업로드 시간이 Arduino에 비해 오래 걸림) 12345678910111213141516171819202122232425#define BLYNK_PRINT Serial#define BLYNK_USE_DIRECT_CONNECT#include &lt;BlynkSimpleEsp32_BLE.h&gt;#include &lt;BLEDevice.h&gt;#include &lt;BLEServer.h&gt;// You should get Auth Token in the Blynk App.// Go to the Project Settings (nut icon).char auth[] = &quot;rc77E7UrbQHhoLE-LV1Ajxz.........&quot;; // Edit Your Auth Token!!void setup(){ // Debug console Serial.begin(115200); Serial.println(&quot;Waiting for connections...&quot;); Blynk.setDeviceName(&quot;Blynk-t&quot;); // Edit Your ESP32 Name!!! Blynk.begin(auth);}void loop(){ Blynk.run();} 이제 스마트폰의 Bluetooth기능을 키고, 위의 코드에서 수정한 Device Name을 찾아 연결한다. Blynk App에서 BLE버튼(블루투스 아이콘 모양)을 누른다. Connect BLE device 버튼을 누른다. 연결할 Device(여기서는 Blynk-t)를 선택하고 OK를 누른다. Connected 메세지가 나오면 연결 설정이 완료된 것이다. Blynk App 상단의 뒤로 돌아가기 버튼을 눌러 프로젝트 바탕화면으로 돌아간다. App 오른쪽 상단의 ▷(플레이버튼)버튼을 누른다. 플레이버튼을 눌렀을 때, App상단에 빨간색 숫자1이 보이면 아직 연결이 되지 않았다는 것을 의미한다. 잠시 기다리면 빨간색 숫자1이 사라지고, 이 상태가 작동 준비가 완료된다. 현재 Button은 OFF 되어 있으며, 이에 따라 GPIO 19에 연결되어 있는 LED도 OFF되어 있다. Button을 누르면 ON 상태로 바뀌면서, LED가 ON 상태로 점등된다. 다시 Button을 누르면 OFF 상태로 바뀌면서, LED가 OFF 상태로 소등된다. 정지버튼을 누르면 플레이상태가 정지상태로 바뀌면서 프로젝트 바탕화면으로 돌아간다.","link":"/2019/10/21/ESP32-BLE-Blynk-Button/"},{"title":"esp32 BLE, Blynk Gauge","text":"ESP32에서 Blynk로 센서값 보내기Blynk App의 GAUGE 위젯을 사용하여 ESP32에 연결된 Potentiometer의 저항값을 읽어 Blynk App에 전압(V), 저항(㏀) 값을 표시해본다. (ESP32 → Blynk App) ESP32의 Potentiometer 값을 읽기 위해 BLYNK_READ(Vpin)을 사용한다. 새로운 프로젝트를 만드는 경우, 새로운 auth token을 받아서 사용해야 한다. schematic sketch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#define BLYNK_PRINT Serial#define BLYNK_USE_DIRECT_CONNECT#include &lt;BlynkSimpleEsp32_BLE.h&gt;#include &lt;BLEDevice.h&gt;#include &lt;BLEServer.h&gt;// You should get Auth Token in the Blynk App.// Go to the Project Settings (nut icon).char auth[] = &quot;WUAeS6P57T3XNaIGyLK1-OUv........&quot;;// Potentiometer Pin#define PIN_POTENTIOMETER A0 // Potentiometer GPIO 36// Resist, Voltageint value_Potentiometer; int value_R;float value_V;void setup(){ // Debug console Serial.begin(115200); Serial.println(&quot;Waiting for connections...&quot;); // for Blynk Blynk.setDeviceName(&quot;Blynk-t&quot;); Blynk.begin(auth);}void loop(){ value_Potentiometer = analogRead(PIN_POTENTIOMETER); // 12bit ADC (0~4095) value_V = map(value_Potentiometer, 0, 4095, 3300, 0); // 0~3300mV value_R = map(value_V, 0, 3300, 10000, 0); // 0~10kΩ Blynk.run(); Serial.print(&quot;Resist : &quot;); Serial.print(value_R); Serial.println(&quot;Ω&quot;); Serial.print(&quot;Voltage: &quot;); Serial.print(value_V); Serial.println(&quot;mV&quot;); delay(1000);}BLYNK_READ(V1) // ESP32 -&gt; widget virtual pin1{ Blynk.virtualWrite(V1, value_R);}BLYNK_READ(V2) // ESP32 -&gt; widget virtual pin1{ Blynk.virtualWrite(V2, value_V);} Blynk에서 2개의 Gauge를 사용하기 위해 BLYNK)READ(Vpin)을 2번 사용한다. Blynk.virtualWrite(Vpin, value)를 통해 Blynk App의 Gauge 위젯에서 지정한 virtual pin에 value값을 표시한다. Blynk 설정 새로운 프로젝트를 생성한다. NAME : ESP32_Potentiometer CHOOSE DEVICE : ESP32 Dev Board CONNECTION TYPE : BLE 이메일로 발송된 토큰을 복사한다. +버튼을 눌러 위젯을 추가할 수 있는 화면으로 진입한다. 먼저 BLE 위젯을 선택하여 ESP32와 Blynk간의 통신 방법을 지정한다. 블루투스 모양의 위젯 버튼을 눌러 Blynk와의 통신을 준비한다. Connect BLE device 연결하고자 하는 BLE 장비를 선택하면, 연결 확인! +버튼을 눌러 출력 위젯 2개를 추가한다. (Gauge, Labeled value) 먼저 Gauge 위젯을 선택한다. Gauge 위젯이 추가되면 육각형 모양의 아이콘을 눌러 GAUGE Setting 화면으로 진입한다. 설정화면에서 다음 4가지를 설정한다. NAME : 저항 INPUT : V1, 0~1000 LABEL : (단위를 표시하기 위해) x10 Ohm 을 적는다. READING RATE : 1sec (PUSH 위젯은 실행되지 않음) Labeled Value 위젯을 추가하고, 다음과 같이 설정한다. NAME : 저항 INPUT : V2, 0~3300 LABEL : (단위를 표시하기 위해) mV 를 적는다. READING RATE : 1sec (PUSH 위젯은 실행되지 않음) 상단의 뒤로가기 화살표를 눌러 프로젝트 바탕화면으로 돌아간다. 여기서 플레이버튼을 누르면, 저항과 전압의 측정이 시작된다. (시리얼 모니터에서도 관찰 가능) 가변 저항을 돌릴 때마다 저항과 전압이 바뀐다.","link":"/2019/10/23/ESP32-BLE-Blynk-Gauge/"},{"title":"esp32 BLE, Blynk Slider (PWM)","text":"ESP32와 Blynk에서의 PWM 사용Blynk app에서 Slider 위젯을 사용하여 App → ESP32로 PWM 신호를 보내 LED의 밝기를 조절해본다. Blynk에서 Slider는 Virtual pin을 사용해야한다. (Digital핀을 선택하는 것이 불가능) Virtual pin을 사용하기 위해 BLYNK_WRITE(Vpin)을 사용한다. ESP32에서 PWM을 사용하기 위한 절차에 따라 코딩을 진행한다. schematic ※ LED모듈을 사용하는 경우 저항이 필요없다. sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define BLYNK_PRINT Serial#define BLYNK_USE_DIRECT_CONNECT#include &lt;BlynkSimpleEsp32_BLE.h&gt;#include &lt;BLEDevice.h&gt;#include &lt;BLEServer.h&gt;// You should get Auth Token in the Blynk App.// Go to the Project Settings (nut icon).char auth[] = &quot;rc77E7UrbQHhoLE-LV1Ajxz20k8eLBrk&quot;;// setting PWM properties#define LEDC_FREQ 5000 // Hz#define LEDC_CHANNEL_0 0#define LEDC_RESOLUTION 12 // 10bit (0~1023) 12bit(0~4095) 16bit(0~65535)// led Pinconst int pin_ledR = 19; BLYNK_WRITE(V5) // widget virtual pin5 -&gt; ESP32{ int value_V5 = param.asInt(); ledcWrite(LEDC_CHANNEL_0, value_V5); Serial.print(&quot;V5 value: &quot;); Serial.println(value_V5);}void setup(){ // Debug console Serial.begin(115200); Serial.println(&quot;Waiting for connections...&quot;); // configure LED PWM functionalitites ledcSetup(LEDC_CHANNEL_0, LEDC_FREQ, LEDC_RESOLUTION); // attach the same channel to the GPIO to be controlled ledcAttachPin(pin_ledR, LEDC_CHANNEL_0); // for Blynk Blynk.setDeviceName(&quot;Blynk-t&quot;); Blynk.begin(auth);}void loop(){ Blynk.run();} sketch 분석Button 위젯 사용을 위해 사용하였던 예제 sketch에 다음의 라인을 추가하여야 한다. LED가 연결되어 있는 ESP32 핀 1const int pin_ledR = 19; Blynk App에서 ESP32로 신호를 보내는 Virtual 핀 12345BLYNK_WRITE(V5) { // widget virtual pin(V5) -&gt; ESP32 int value_V5 = param.asInt(); // V5로 지정된 위젯의 값을 읽고 ledcWrite(LEDC_CHANNEL_0, value_V5); // PWM 채널0으로 보냄 Serial.print(&quot;V5 value: &quot;); Serial.println(value_V5); // 시리얼모니터에 출력} LED에 PWM 신호 출력 (밝기 조절) 12345// configure LED PWM functionalititesledcSetup(LEDC_CHANNEL_0, LEDC_FREQ, LEDC_RESOLUTION);// attach the same channel to the GPIO to be controlledledcAttachPin(pin_ledR, LEDC_CHANNEL_0); Blynk App 설정 Button 위젯을 삭제한다. (그냥 두어도 관계없음) 프로젝트 바탕화면에서 ⊕버튼을 누른 후, Slider 위젯을 추가한다. 프로젝트 바탕화면의 Slider 위젯을 누른다. Slider 설정화면이 나오면, PIN을 누르고 사용할 Virual 핀을 선택한 뒤 OK버튼을 누른다. (여기서는 V5선택) 다음 3가지를 추가로 설정한다. OUTPUT 범위 : 0 ~ 4095 (12bit 사용시) SEND ON RELEASE : OFF (OFF 선택시 Slide를 조절하는 즉시 실시간으로 출력값 반영되며, ON 선택시 Slide에서 손가락을 떼면 출력값이 반영된다.) WRITE INTERVAL : SEND ON RELEASE를 OFF로 선택시 나타나며, 100ms가 가장 작은 값이다. 설정을 모두 마치면 상단의 뒤로가기 화살표를 눌러 프로젝트 바탕화면으로 돌아간다. Slider 위젯을 1초이상 누르고 있으면 위젯의 위치와 크기를 조절할 수 있다. 위젯의 위치를 아래로 내리고 가로폭의 크기를 늘려본다. 이제 플레이(▷) 버튼을 누르고 Slide를 조절해본다. Slide값에 따라 LED의 밝기가 조절된다. Slider를 조절하는 동안 Arduino IDE의 시리얼 모니터값을 확인해볼 수 있다.","link":"/2019/10/22/ESP32-BLE-Blynk-Slider-PWM/"},{"title":"ESP32, DC모터, TB6612FNG","text":"DC모터 사용하기아두이노의 경우와 마찬가지로 ESP32에서도 TB6612FNG 모터드라이버와 함께, 모터 및 아두이노 단독사용을 위하여 3.7V 18650 2개를 직렬로 연결한 외부전원을 사용한다. TB6612FNG기본 핀 배열 VMVCCGND(*)AOUT1AOUT2BOUT2BOUT1GND PWMAAIN2AIN1STBYBIN1BIN2PWMBGND 핀 배열이 다른 경우 GNDVCCAOUT1AOUT2BOUT2BOUT1VMGND PWMAAIN2AIN1NC (=STBY)BIN1BIN2PWMBGND VM (모터 전압) = 15V max VCC (로직 전압) = 2.7 ~ 5.5V GND TB6612FNG 모듈을 여러개 테스트한 결과, 기본 핀 배열을 가진 모듈의 3번핀 GND에 연결할 경우 작동이 안되는 몇몇 제품이 있었음 그러므로 8번핀, 9번핀의 GND 사용을 권장함 출력전류: 정전류 1.2A (3.2A peak)까지 (모터 2개 사용시 합산 전류임) 모터 제어모드: CW, CCW, short-brake, STOP, stand-by 두개의 모터 출력을 개별 제어하며, 100kHz의 PWM으로 속도 제어 써멀 셧다운 및 저전압 감지회로 내장 Pin의 사용ESP32와 TB6612FNG모듈을 브레드보드를 통해 연결하기 쉽도록 핀을 구성한 Pinmap이므로, 필요에 따라 수정하여 사용할 수 있다. (아래표는 참고만 할 것!) 핀번호 TB6612FNG 모터드라이브 (기본 핀 배열) ESP32 DEVKIT_C V4 사용시 ESP32 DEVKIT V1 사용시 외부전원 모터 / 역할 1 VM (+) (DC모터에 사용하는 전압 사용) 2 VCC +3.3V +3.3V 3 GND (사용 비추천) 4 A_OUT1 모터A 5 A_OUT2 모터A 6 B_OUT2 모터B 7 B_OUT1 모터B 8 GND (-) 9 GND GND GND 10 B_PWM 12 13 모터B 속도제어 11 B_IN2 14 12 모터B 방향제어 12 B_IN1 27 14 모터B 방향제어 13 STBY 26 27 모터 상태신호 14 A_IN1 25 26 모터A 방향제어 15 A_IN2 33 25 모터A 방향제어 16 A_PWM 32 33 모터A 속도제어 ESP32 DEVKIT V4 사용시 ESP32 DEVKIT V1 사용시 모터 1개 컨트롤하기 (기어박스를 포함한) 일반 DC모터 (엔코더 모듈을 포함한) 엔코더 DC모터 아두이노를 사용한 스마트카 실습용으로 많이 사용됨 Hall sensor를 통해 회전수를 정밀하게 측정가능 (+)와 (-), 2P 단자가 있음 5P or 6P 단자가 있음 (여기서는 (+)와 (-) 2P만 사용) schematicESP32와 컴퓨터를 USB선으로 연결하여 사용할 경우 (단, 모터 외부전원은 사용) ESP32와 컴퓨터의 연결없이, 외부전원을 사용하여 단독으로 사용할 경우 18650 2S 외부전원(7.4V)을 DC컨버터 모듈에 연결 입력: 8~36V 출력: 1.25~32V 및 USB 5V 출력 75W내 사용 권장, 전류량 최대 5A (4.5A 이내 사용 권장) 여기서는 서보모터 추가 연결을 위해서, 왼쪽 가변 저항을 사용하여 출력 전압을 5V로 세팅하여 사용 USB 출력단자는 ESP32의 microUSB 단자에 연결 sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// TB6612FNG right side &amp; ESP32-WROOM-32D DEVKIT_C V4 left side pin orderconst int PIN_PWMA = 32; const int PIN_AIN1 = 33;const int PIN_AIN2 = 25;const int PIN_STBY = 26;const int PIN_BIN1 = 27;const int PIN_BIN2 = 14;const int PIN_PWMB = 12;/*// TB6612FNG right side &amp; ESP32-WROOM-32 left side pin orderconst int PIN_PWMA = 33; const int PIN_AIN1 = 25;const int PIN_AIN2 = 26;const int PIN_STBY = 27;const int PIN_BIN1 = 14;const int PIN_BIN2 = 12;const int PIN_PWMB = 13;*/// PWM Channel setupconst int CH_PWMA = 0;const int CH_PWMB = 1;// PWM frequency and bit resolution setupconst int pwmFrequency = 10000; // Hzconst int bitResolution = 8; // pwm value: 0~255const int PIN_LED = 2;void setup() { // put your setup code here, to run once: Serial.begin(115200); pinMode(PIN_LED, OUTPUT); // tb6612fng setting pinMode(PIN_STBY,OUTPUT); pinMode(PIN_AIN1,OUTPUT); pinMode(PIN_AIN2,OUTPUT); pinMode(PIN_PWMA,OUTPUT); pinMode(PIN_BIN1,OUTPUT); pinMode(PIN_BIN2,OUTPUT); pinMode(PIN_PWMB,OUTPUT); // motor output(PWM) setting (channel, frequency, bit) ledcSetup(CH_PWMA, pwmFrequency, bitResolution); ledcSetup(CH_PWMB, pwmFrequency, bitResolution); ledcAttachPin(PIN_PWMA, CH_PWMA); ledcAttachPin(PIN_PWMB, CH_PWMB); // channel setting (GPIO pin, channel) // if STBY(CH0) = LOW, Standby states. // if STBY(CH0) = HIGH, and INA1&amp;INA2 have different value // and PWMA has some value, CW or CCW rotation is made. // Channel CW CCW Stanby Stop Brake1 Brake2 Brake3 // PIN_STBY (0) HIGH HIGH LOW HIGH HIGH HIGH HIGH // PIN_INA1 (1) HIGH LOW * LOW HIGH LOW HIGH // PIN_INA2 (2) LOW HIGH * LOW HIGH HIGH LOW // CH_PWMA (3) PWM PWM * HIGH * LOW LOW }void loop() { // Motor A : CW digitalWrite(PIN_STBY, HIGH); // STBY digitalWrite(PIN_AIN1, HIGH); // AIN1 digitalWrite(PIN_AIN2, LOW); // AIN2 ledcWrite(CH_PWMA, 255); // PWMA // Motor B : CW digitalWrite(PIN_BIN1, HIGH); // BIN1 digitalWrite(PIN_BIN2, LOW); // BIN2 ledcWrite(CH_PWMB, 255); // PWMB delay(3000); // Motor : Stand-by digitalWrite(PIN_STBY, LOW); // STBY //delay(1000); //LED Blink digitalWrite(ledPin, LOW); delay(3500); digitalWrite(ledPin, HIGH); delay(500); digitalWrite(ledPin, LOW); // Motor A : CCW digitalWrite(PIN_STBY, HIGH); // STBY digitalWrite(PIN_AIN1, LOW); // AIN1 digitalWrite(PIN_AIN2, HIGH); // AIN2 ledcWrite(CH_PWMA, 255); // PWMA // Motor B : CCW digitalWrite(PIN_BIN1, LOW); // BIN1 digitalWrite(PIN_BIN2, HIGH); // BIN2 ledcWrite(CH_PWMB, 255); // PWMB delay(3000); // Motor : Stand-by digitalWrite(PIN_STBY, LOW); // STBY //delay(1000); //LED Blink digitalWrite(PIN_LED, LOW); delay(3500); digitalWrite(PIN_LED, HIGH); delay(500); digitalWrite(PIN_LED, LOW);} Troubleshooting스케치 중간에 있는 stand-by가 있거나 없거나 동일한 운동을 보일 것 같지만, 실제로는 완전히 다르다. stand-by가 있는 경우 3초간 CW회전 후 정지 → 3.5초 대기 → 0.5초 LED켜졌다가 꺼짐 → 3초간 CCW회전 후 정지→ 3.5초 대기 → 0.5초 LED켜졌다가 꺼짐 stand-by가 없는 경우: 모터 모터의 delay 시간(회전시간)이 3초로 되어 있어도 stand-by 상태로 들어가지 않으므로, 실제로는 7초간 회전 후 방향을 바꿈 7초간 CW회전 후 → (정지하지 않고) 곧바로 7초간 CCW회전 (반복) LED 꺼짐: 6.5초간 꺼져있다가 (모터의 delay 시간 3초 + led low delay 시간 3.5초) 켜짐: 0.5초간 켜짐 (반복) 그러므로, 각 상황에 따라 stand-by를 걸어야 할지, 말아야할지를 결정해야 함. stand-by를 걸지 않은 상태에서 멈추려면 PWMA or PWMB를 0으로 주면 됨. 회전 방향이 (생각했던 방향과) 반대로 회전하는 경우AIN1핀과 AIN2 핀의 번호를 바꿔준다. 즉, 위 스케치에서 12const int AIN2 = 25;const int AIN1 = 26; 부분을 12const int AIN2 = 26;const int AIN1 = 25; 로 바꿔준다. 모터 2개 컨트롤하기 sketch위의 ‘’모터 1개 컨트롤하기’’ 스케치와 동일함. 스케치 최적화move(), stop()을 만들어서 스케치 최적화 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// TB6612FNG right side &amp; ESP32-WROOM-32D DEVKIT_C V4 left side pin orderconst int PIN_PWMA = 32; const int PIN_AIN1 = 33;const int PIN_AIN2 = 25;const int PIN_STBY = 26;const int PIN_BIN1 = 27;const int PIN_BIN2 = 14;const int PIN_PWMB = 12;/*// TB6612FNG right side &amp; ESP32-WROOM-32 left side pin orderconst int PIN_PWMA = 33; const int PIN_AIN1 = 25;const int PIN_AIN2 = 26;const int PIN_STBY = 27;const int PIN_BIN1 = 14;const int PIN_BIN2 = 12;const int PIN_PWMB = 13;*/// PWM Channel setupconst int CH_PWMA = 0;const int CH_PWMB = 1;// PWM frequency and bit resolution setupconst int pwmFrequency = 10000; // Hzconst int bitResolution = 8; // pwm value: 0~255const int PIN_LED = 2;void setup() { // put your setup code here, to run once: Serial.begin(115200); pinMode(PIN_LED, OUTPUT); // tb6612fng setting pinMode(PIN_STBY,OUTPUT); pinMode(PIN_AIN1,OUTPUT); pinMode(PIN_AIN2,OUTPUT); pinMode(PIN_PWMA,OUTPUT); pinMode(PIN_BIN1,OUTPUT); pinMode(PIN_BIN2,OUTPUT); pinMode(PIN_PWMB,OUTPUT); // motor output(PWM) setting (channel, frequency, bit) ledcSetup(CH_PWMA, pwmFrequency, bitResolution); ledcSetup(CH_PWMB, pwmFrequency, bitResolution); ledcAttachPin(PIN_PWMA, CH_PWMA); ledcAttachPin(PIN_PWMB, CH_PWMB); // channel setting (GPIO pin, channel) // if STBY(CH0) = LOW, Standby states. // if STBY(CH0) = HIGH, and INA1&amp;INA2 have different value // and PWMA has some value, CW or CCW rotation is made. // Channel CW CCW Stanby Stop Brake1 Brake2 Brake3 // PIN_STBY (0) HIGH HIGH LOW HIGH HIGH HIGH HIGH // PIN_INA1 (1) HIGH LOW * LOW HIGH LOW HIGH // PIN_INA2 (2) LOW HIGH * LOW HIGH HIGH LOW // CH_PWMA (3) PWM PWM * HIGH * LOW LOW }void loop() { move(1, 128, 0); // motor A(right wheels), half speed, moving forward move(2, 255, 0); // motor B(left wheels), full speed, moving forward delay(3000); stop(); // Motor : Stand-by //delay(1000); //LED Blink digitalWrite(ledPin, LOW); delay(3500); digitalWrite(ledPin, HIGH); delay(500); digitalWrite(ledPin, LOW); move(1, 255, 1); // motor A(right wheels), full speed, moving backward move(2, 128, 1); // motor B(left wheels), half speed, moving backward delay(3000); stop(); // Motor : Stand-by //delay(1000); //LED Blink digitalWrite(ledPin, LOW); delay(3500); digitalWrite(ledPin, HIGH); delay(500); digitalWrite(ledPin, LOW);}void move(int motor, int speed, int direction) { //Move specific motor at speed and direction//motor: A(Right) -&gt; 1, B(Left) -&gt; 2//speed: 0 is off, and 255 is full speed//direction: 0 clockwise, 1 counter-clockwise digitalWrite(PIN_STBY, HIGH); // move boolean inPin1 = HIGH; // Defalut(direction=0) - Clockwise boolean inPin2 = LOW; if(direction == 1) { // Count-clockwise inPin1 = LOW; inPin2 = HIGH; } if(motor == 1){ // if motor == 1, right wheel digitalWrite(PIN_AIN1, inPin1); digitalWrite(PIN_AIN2, inPin2); ledcWrite(CH_PWMA, speed); } else { // if motor is not 1, left wheel digitalWrite(PIN_BIN1, inPin1); digitalWrite(PIN_BIN2, inPin2); ledcWrite(CH_PWMB, speed); }}void stop() { digitalWrite(PIN_STBY, LOW); // stand-by = stop}","link":"/2021/11/01/ESP32-DC%EB%AA%A8%ED%84%B0/"},{"title":"esp32 서보모터 PWM제어","text":"SG90, MG90S, MG966R 서보모터datasheet 사용법 ESP32는 16개의 PWM채널이 있으므로, 최대 16개의 서보모터를 동시에 제어할 수 있다. 서보모터 데이터 시트의 스펙상으로는… 대부분의 서보모터(SG90, MG90S, MG966R 등 포함)는 위의 그림처럼 20ms가 1주기가 되므로, PWM frequency를 50Hz로 설정한다. 20ms가 1주기이고, HIGH 펄스가 2ms 지속될 때 180º 회전을 한다. 그러므로, 전체 펄스 폭의 1/10만큼 HIGH 펄스가 주어지면 180º 회전을 한다. Resolution이 16비트라면 65535의 1/10에 해당하는 6554의 값이 duty값으로 주어지면 서보모터는 180º 회전을 한다. 데이터 시트에 나온 스펙에 따라서, 16비트 해상도에서 duty값에 따른 회전 각도 PWM 5% : 3277 → 0º PWM 7.5% : 4915 → 90º PWM 10% : 6554 → 180º 라고 생각했으나, 실제로는 이와 달랐다. MG90S 16비트 해상도(0~65535)에서 duty값에 따른 회전 각도는 PWM 2.5% : 1639 → 0º PWM 7.5% : 4915 → 90º PWM 12.5% : 8191 → 180º 즉, 각도에 따른 PWM값은 다음과 같이 지정한다.$$PWM = 2^{16} \\times 0.1 \\times \\frac{angle}{180} + 2^{16} \\times 0.025 = 2^{16} \\times 0.1 \\times (\\frac{angle}{180} + 0.25)$$ 그리고, 이 서보모터 스펙상 180도 회전을 하지만 PWM 값을 조절하면 최대 190도 정도까지는 회전한다. 그러므로, map 함수를 사용하여 다음과 같이 각도를 조절한다. duty = map(deg, 0, 180, 1638, 8191); 이에 따라, 12비트 해상도(0~4095)에서 duty값에 따른 회전 각도는 PWM 2.5% : 103 → 0º PWM 7.5% : 307 → 90º PWM 12.5% : 511 → 180º MG996R duty = map(deg, 0, 180, 2720, 8191); 가 가장 적당한 값을 나타내었다. (4.15% ~ 12.5%) (이유는 잘 모르겠음) 이런 내용을 종합해 볼때, 기기 데이터시트의 스펙과는 관계없이, 테스트를 통해 경험적으로 값을 찾아야 하는 듯… delay( ); 서보 회전 속도를 조절하며, 숫자가 작을 수록 빠르게 회전한다. 이동하는 각도만큼 돌아갈 수 있는 충분한 시간을 주어야한다. (전류가 약하면) delay( ) 값이 너무 작을 경우 원하는 각도의 회전을 완성하지 못할 수도 있다. 전류가 충분하면 delay값을 줄여도 됨. Servo 라이브러리를 이용하지 않는 경우일반적으로 아두이노에서 서보모터를 사용하는 경우 아두이노 IDE에 기본적으로 포함되어 있는 &lt;Servo.h&gt; 라이브러리를 사용하면 되지만 이 라이브러리는 ESP32에서 사용할 수 없다. 그러므로 ESP32에 맞는 별도의 Servo.h 라이브러리를 다운로드 받아 사용해야하는 불편함이 있다. 또한 ESP32servo와 같은 ESP32용 라이브러리를 사용할 경우, 라이브러리에 따라 ledcWrite를 사용할 수 없는 경우도 있다. 그러므로, 여기서는 라이브러리를 사용하지 않고 PWM을 사용하여 ESP32로 MG90 서보모터를 제어해보고자 한다. schematic sketch123456789101112131415161718192021222324252627282930313233const int ledPin = 15; // corresponds to GPIO 15// setting PWM propertiesconst int ledChannel = 0;const int freq = 50;const int resolution = 16;int deg, duty;void setup(){ // PWM Setup ledcSetup(ledChannel, freq, resolution); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin, ledChannel); // PWM CH0을 GPIO 15번으로 출력}void loop(){ for (deg = 0;deg &lt;= 180; deg++) { servoWrite(ledChannel, deg); } for (deg = 180;deg &gt;= 0; deg--) { servoWrite(ledChannel, deg); }}// deg는 0~180도 까지void servoWrite(int ch, int deg){ duty = map(deg, 0, 180, 1638, 8192); ledcWrite(ch, duty); delay(15); // delay를 줄이면 180도가 완전히 돌지 않음} sketch: 시리얼 모니터에 입력한 문자로 서보모터 회전시키기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int ledPin = 15; // corresponds to GPIO 15// setting PWM propertiesconst int ledChannel = 0;const int freq = 50;const int resolution = 16;int deg = 90;int duty;void setup() { Serial.begin(9600); // PWM Setup ledcSetup(ledChannel, freq, resolution); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin, ledChannel); // PWM CH0을 GPIO 15번으로 출력 servoWrite(ledChannel, deg);}void loop(){ while(Serial.available() &gt; 0) { char flag=Serial.read(); delay(2); if(flag=='l') { deg = deg - 5; if(deg &lt; 0) { deg = 0; } } if(flag=='r') { deg = deg + 5; if(deg &gt; 180) { deg = 180; } } servoWrite(ledChannel, deg);}// deg는 0~180도 까지void servoWrite(int ch, int deg){ duty = map(deg, 0, 180, 1638, 8192); ledcWrite(ch, duty); delay(15); // delay를 줄이면 180도가 완전히 돌지 않음} 2축 서보모터 거치대 조립 및 테스트거치대 조립첫번째 단계로 서보모터 거치대를 조립하고 서보모터 2개를 장착한다. SG90 서보 2개를 준비하고 니퍼로 아래 빨간 동그라미로 표시한 부분의 크기에 맞추어, 서보모터 날개를 잘라낸 뒤 아래 형태대로 조립한다. 날개를 나사로 조인 부분에 순간접착제를 살짝 뿌려, 완전히 고정시킨다. (단, 서보모터의 회전축 부분에는 접착제가 뭍지 않도록 주의한다.) schematic sketch: 두개의 서보모터를 180도 회전시키기12345678910111213141516171819202122232425262728293031323334353637383940414243444546// for horizontal Servo PWM propertiesconst int ledPin_hori = 15; // corresponds to GPIO 15const int ledChannel_hori = 1;const int freq_hori = 50;const int resolution_hori = 16;// for vertical Servo PWM propertiesconst int ledPin_vert = 2; // corresponds to GPIO 2const int ledChannel_vert = 0;const int freq_vert = 50;const int resolution_vert = 16;int deg_hori, deg_vert, duty;void setup(){ // PWM Setup ledcSetup(ledChannel_hori, freq_hori, resolution_hori); // PWM CH1, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_hori, ledChannel_hori); // PWM CH1을 GPIO 19번으로 출력 ledcSetup(ledChannel_vert, freq_vert, resolution_vert); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_vert, ledChannel_vert); // PWM CH0을 GPIO 18번으로 출력}void loop(){ for (deg_hori = 0;deg_hori &lt;= 180; deg_hori++) { servoWrite(ledChannel_hori, deg_hori); } for (deg_vert = 0;deg_vert &lt;= 180; deg_vert++) { servoWrite(ledChannel_vert, deg_vert); } for (deg_hori = 180;deg_hori &gt;= 0; deg_hori--) { servoWrite(ledChannel_hori, deg_hori); } for (deg_vert = 180;deg_vert &gt;= 0; deg_vert--) { servoWrite(ledChannel_vert, deg_vert); }}// deg는 0~180도 까지void servoWrite(int ch, int deg){ duty = map(deg, 0, 180, 1638, 8192); ledcWrite(ch, duty); delay(15); // delay를 줄이면 180도가 완전히 돌지 않음} Joystick 1개를 사용하여 2개의 서보모터 제어하기schematic sketch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// for horizontal Servo PWM propertiesconst int ledPin_hori = 15; // corresponds to GPIO 15const int ledChannel_hori = 1;const int freq_hori = 50;const int resolution_hori = 16;// for vertical Servo PWM propertiesconst int ledPin_vert = 2; // corresponds to GPIO 2const int ledChannel_vert = 0;const int freq_vert = 50;const int resolution_vert = 16;const int Jstick_LR_pin = 25; // Left_Right GPIO25const int Jstick_FB_pin = 32; // Forward_Backward GPIO32int Jstick_LR, Jstick_FB, deg_hori, deg_vert, duty; void setup() { Serial.begin(115200); // Servo PWM Setup ledcSetup(ledChannel_hori, freq_hori, resolution_hori); // PWM CH1, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_hori, ledChannel_hori); // PWM CH1을 GPIO 19번으로 출력 ledcSetup(ledChannel_vert, freq_vert, resolution_vert); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_vert, ledChannel_vert); // PWM CH0을 GPIO 18번으로 출력}void loop(){ PrintValue(); Jstick_LR = analogRead(Jstick_LR_pin); deg_hori = map(Jstick_LR, 0, 4095, 0, 180); servoWrite(ledChannel_hori, deg_hori); Jstick_UD = analogRead(Jstick_UD_pin); deg_vert = map(Jstick_FB, 0, 4095, 0, 180); servoWrite(ledChannel_vert, deg_vert); delay(15); }// deg는 0~180도 까지void servoWrite(int ch, int deg){ duty = map(deg, 0, 180, 1638, 8192); ledcWrite(ch, duty); delay(15); // delay를 줄이면 180도가 완전히 돌지 않음 (최소값 15)}void PrintValue(){ Serial.print(analogRead(Jstick_LR)); Serial.print (&quot; - &quot;); Serial.print(analogRead(Jstick_FB)); Serial.println (&quot; Joystick Value&quot;);} ESP32Servo 라이브러리 사용시library for ESP32스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리 에서 “esp32servo“ (by Kevin Harrington) 검색 후 설치 schematic sketch123456789101112131415161718192021222324252627282930313233343536373839#include &lt;ESP32Servo.h&gt;Servo servo_x; // create servo object to control a servoServo servo_y; // 16 servo objects can be created on the ESP32int pos = 0; // variable to store the servo position// Recommended PWM GPIO pins on the ESP32 include 2,4,12-19,21-23,25-27,32-33 int servo_xPin = 15;int servo_yPin = 2;void setup() { // Allow allocation of all timers ESP32PWM::allocateTimer(0); ESP32PWM::allocateTimer(1); ESP32PWM::allocateTimer(2); ESP32PWM::allocateTimer(3); servo_x.setPeriodHertz(50); // standard 50 hz servo servo_y.setPeriodHertz(50); servo_x.attach(servo_xPin, 500, 2500); // attaches the servo on pin 25 &amp; 32 to the servo object servo_y.attach(servo_yPin, 500, 2500); // using default min/max of 1000us and 2000us // different servos may require different min/max settings // for an accurate 0 to 180 sweep}void loop() { for (pos = 0; pos &lt;= 180; pos += 1) { // goes from 0 degrees to 180 degrees // in steps of 1 degree servo_x.write(pos); // tell servo to go to position in variable 'pos' servo_y.write(180-pos); delay(5); // waits 5ms for the servo to reach the position } for (pos = 180; pos &gt;= 0; pos -= 1) { // goes from 180 degrees to 0 degrees servo_x.write(pos); // tell servo to go to position in variable 'pos' servo_y.write(180-pos); delay(5); // waits 5ms for the servo to reach the position }}","link":"/2020/10/19/ESP32-%EC%84%9C%EB%B3%B4%EB%AA%A8%ED%84%B0-%EC%A0%9C%EC%96%B4/"},{"title":"ESP32, 스텝모터","text":"스텝 모터, 28BYJ-48Specification 정격전압: 5VDC 기어비: 1/64$$\\frac {32}{9} \\times \\frac {22}{11} \\times \\frac {26}{9} \\times \\frac {31}{10} = 63.68395 \\fallingdotseq 64$$ 스트라이드 각도 스펙상 5.625º / 64 = 0.087890625 그러므로, 360º / 0.087890625 = 4096 스텝 실제로는 11.25º / 64 = 0.17578125 그러므로, 360º / 0.17578125 = 2048 스텝으로 1회전 Frequency: 100Hz 토크: 34.3mN,m 모터드라이브 ULN2003 스텝 모터의 구동schematic Pin Map 외부전원 모터드라이브 ESP32 INT1 19 INT2 18 INT3 5 INT4 17 (+) 5V GND (-) VCC ※ 모터드라이브에 연결하는 전원(VCC)는 외부전원 5V를 사용한다. (ESP32의 5V는, 전류가 부족하여 ESP32와 연결한 노트북에 영향을 줄 수 있으므로, 사용하지 않는 것이 좋다.) 스텝업 모듈 입력전압: 0.9~5V 출력전압: 5V 출력전류: 500~600mA 최대효율: 96% sketch12345678910111213141516171819202122232425262728293031#include &lt;Stepper.h&gt;const int stepsPerRevolution = 2048; // change this to fit the number of steps per revolution// ULN2003 Motor Driver Pins#define IN1 19#define IN2 18#define IN3 5#define IN4 17// initialize the stepper libraryStepper myStepper(stepsPerRevolution, IN1, IN3, IN2, IN4);void setup() { // set the speed at 5 rpm myStepper.setSpeed(5); // initialize the serial port Serial.begin(115200);}void loop() { // step one revolution in one direction: Serial.println(&quot;clockwise&quot;); myStepper.step(stepsPerRevolution); delay(1000); // step one revolution in the other direction: Serial.println(&quot;counterclockwise&quot;); myStepper.step(-stepsPerRevolution); delay(1000);} setSpeed(5); 외부 전원의 전력에 따라 최대값이 달라짐. 5V 전원 사용시 16이 최대값인 경우가 있었고. 그 이상은 안정적으로 회전이 안되며, 17을 넣으면 한바퀴 돌고 정지. 18을 넣으면 돌지 않음. 7.4V 전원 사용시 22가 최대값인 경우가 있었고, 그 이상은 안정적으로 회전이 안됨. (23을 넣으면 시계방향 회전 후, 반시계방향 회전이 안됨. 24를 넣으면 돌지 않음) 전압에 따라 수치가 고정된 것은 아닌 듯 하며, 외부 전원의 상태에 따라 달라질 수 있으므로 테스트가 필요함.","link":"/2021/09/25/ESP32-%EC%8A%A4%ED%85%9D%EB%AA%A8%ED%84%B0-%EC%A0%9C%EC%96%B4/"},{"title":"esp32 시작하기","text":"ESP32 시작하기Driver 설치: 처음 설치하는 경우ESP32는 USB-to-Serial bridge로 Silicon Labs의 CP210x를 사용한다. 제조사 홈페이지에서 자신이 사용하는 OS에 알맞는 CP210x 드라이버를 다운받아 설치한다. 1https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers Arduino IDE 설치Arduino IDE Download 1https://www.arduino.cc/en/software Arduino IDE 설정 Arduino IDE에서 파일&gt; 환경설정&gt; 설정 (File&gt; Preferences&gt; Settings) 추가적인 보드 매니저 URLs에 아래 내용을 추가한다. 1https://dl.espressif.com/dl/package_esp32_index.json ESP8266에 대한 URLs를 사용하고 있었다면, comma를 사용하여 구분하면 두가지를 모두 사용할 수 있다. 1https://dl.espressif.com/dl/package_esp32_index.json, http://arduino.esp8266.com/stable/package_esp8266com_index.json 툴&gt; 보드&gt; 보드 매니저… Tools&gt; Board&gt; Board Manager… 보드 매니저에서 “ESP32”를 검색하여 INSTALL (혹은 업데이트) ESP32를 컴퓨터에 연결한 뒤, 툴&gt; 보드 에서 ESP32 Dev Module 선택 툴&gt; 포트 에서 포트 선택 (단, ESP32용 포트가 선택이 되지 않으면 CP210x USB to UART Bridge VCP Drivers를 설치하여야 한다. Windows, Mac 등 사용하고 있는 OS에 적합한 드라이버를 클릭하여 설치한다. Testing InstallationExample 1. LED Blink12345678910111213141516171819#include &lt;Arduino.h&gt;const int R_ledPin = 19;void setup() { // put your setup code here, to run once: Serial.begin(115200); pinMode(R_ledPin, OUTPUT);}void loop() { // put your main code here, to run repeatedly: digitalWrite(R_ledPin, HIGH); Serial.println(&quot;LED is on&quot;); delay(1000); digitalWrite(R_ledPin, LOW); Serial.println(&quot;LED is off&quot;); delay(1000);} ESP32 GPIO 19 GND 저항 150Ω LED (+)극 (-)극 Upload스케치 업로드는 아래 3가지 방법 중 하나로 진행할 수 있다. 단축키: Ctrl-U Sketch&gt; Upload 업로드 아이콘 클릭 ※ 아두이노에 비해 컴파일 및 업로드 시간이 오래걸림 Serial Monitor Example 2. WiFiScan예제 선택: 파일 &gt; 예제 &gt; WiFi (ESP32) &gt; WiFiScan ※ 주의: ESP32보드를 연결한 상태에서만 위 예제를 선택할 수 있다. Upload아두이노에 비하여 업로드 시간이 많이 걸린다. “업로드 완료”라는 메세지가 나타날때까지 잠시 기다린다. Serial Monitor아두이노 IDE의 시리얼 모니터를 열고 Baud rate를 115200으로 설정하면 주변의 접속 가능한 WiFi의 SSID가 표시된다. 여기까지 진행이 되면 ESP32가 잘 설치된 것이다. Troubleshooting 업로드시, “A fatal error occurred: Failed to connect to ESP32: Timed out… Connecting…”이라는 메세지가 나오면서 업로드가 진행되지 않는다면, 우선 IDE의 보드와 포트가 알맞게 선택되어 있는지 확인해본다. 그럼에도 문제가 해결되지 않는다면 아래의 방법을 따른다. (※상기 문제가 해결되어 나온 보드의 경우에는 관계없음) ESP32 보드에 있는 Boot버튼을 누른채로 업로드 버튼을 클릭하고, Connecting…. 이라는 메세지가 나오면 Boot버튼에서 손가락을 뗀다. 일부 ESP32 보드의 경우 새로운 스케치를 업로드 할 때마다 “ENABLE”버튼을 눌러 ESP32를 다시 시작해야 하는 경우도 있는데, 이런 문제가 발생하는 보드의 경우 새 스케치를 업로드 할 때마다 해당 버튼 순서(BOOT-EN)를 반복해야합니다. 이러한 문제를 해결하기 위해서는 ESP32보드의 EN핀과 GND를 10uF 컨덴서를 사용하여 연결해주면 된다. Mac OS X &amp; Linux ​ 전체적인 설치방법은 Windows와 동일하다. 단, 첫번째 설치가 아닌 재설치 과정을 수행하는한 경우에는 다음 ​ 과정을 통해 espressif폴더를 지운 후 설치과정을 시작하여야 한다. Arduino&gt; Preferences&gt; Sketchbook Location에 표기되어 있는 폴더를 복사하여 해당 디렉토리로 진입한 후, Hardware 폴더 안에 있는 espressif 폴더를 삭제한다. 이후 Windows 설치과정과 유사한 과정을 통해 ESP32를 설치한다. PWM 제어 방법원문: https://randomnerdtutorials.com/esp32-pwm-arduino-ide/ PWM(Pulse Width Modulation) 그림과 같은 주기적인 펄스 신호를 생성하고 1로 되어있는 시간과 0으로되어있는 시간의 비율 (듀티 비)를 바꿈으로써 전송 전력을 변화시킨다. duty 값은 한 주기 내에서 ON 시간과 OFF 시간의 ‘비율’을 결정하는 값이다. PWM 주파수가 다르면 같은 duty 값이라도 ON 되어 있는 시간이 달라진다. 다만 전체적으로 ON 시간의 합과 OFF 시간의 합의 비율은 동일하다. 이런 방법을 LED의 점등에 적용하면, 1의 값을 갖는 시간이 짧을 수록 사람 눈에는 LED가 어둡게 보이고, 1의 값을 갖는 시간이 길 수록 밝아 보이게 된다. ESP32에서 PWM의 설정ESP32에는 16 개의 독립적인 채널을 가진 LED PWM 컨트롤러가 있으며 다른 속성으로도 PWM 신호를 생성하도록 구성할 수 있다. Arduino IDE를 사용하여 PWM으로 LED의 밝기를 조절해보도록 한다. 우선 PWM을 사용하기 위해 다음의 4가지를 설정해야 한다. Channel0~15까지 16 개의 채널 중 적당한 PWM 채널을 선택한다. FrequencyPWM 신호 주파수를 설정한다. (LED의 경우 5000Hz의 주파수를 사용) Resolution해상도는 output을 위한 값의 범위를 지정하는데 사용하며, 1~16비트 범위에서 선택한다. 만약 8비트 해상도를 사용한다면 0~255 사이의 dutyCycle 값을 사용하여 LED 밝기를 제어할 수 있다. 10비트를 사용하면 0~1023범위, 16비트로 사용한다면 0~65535 범위에서 세밀한 제어를 할 수 있도록 지정된다. 참고: 아두이노 우노의 경우, analogWrite()의 해상도는 8비트, 즉 0~255로 고정되어 있다. GPIO신호가 표시 될 GPIO를 지정한다. 코드 적용이러한 설정은 void setup()에서 다음의 코드로 지정한다. 12ledcSetup(ledChannel, freq, resolution); // 출력 채널에서 사용할 주파수와 해상도 지정ledcAttachPin(ledPin, ledChannel); // 위에서 설정한 출력 채널을, 지정된 GPIO핀에 매칭 출력 강도는 resolution과 dutyCycle 값으로 결정한다! resolution이 8bit이면, 0~255 범위 내에서 dutyCycle을 지정하여 출력강도를 설정하면 됨. resolution이 10bit이면, 0~1023 범위 내에서 dutyCycle을 지정하여 출력강도를 설정하면 됨. resolution이 16bit이면, 0~65535 범위 내에서 dutyCycle을 지정하여 출력강도를 설정하면 됨. LED Dimmingschematic sketch12345678910111213141516171819202122232425262728293031// the number of the Red LED pinconst int R_ledPin = 19; // corresponds to GPIO 19// setting PWM propertiesconst int ledChannel = 0;const int freq = 5000;const int resolution = 8; // 8bit 0~255 void setup(){ // configure LED PWM functionalitites ledcSetup(ledChannel, freq, resolution); // attach the channel to the GPIO to be controlled ledcAttachPin(R_ledPin, ledChannel);} void loop(){ // increase the LED brightness (8bit 0~255) for(int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++){ // changing the LED brightness with PWM ledcWrite(ledChannel, dutyCycle); delay(15); } // decrease the LED brightness for(int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle--){ // changing the LED brightness with PWM ledcWrite(ledChannel, dutyCycle); delay(15); }} RGB LED Dimming같은 channel에 있는 3개의 서로 다른 GPIO에는 같은 값의 signal을 줄 수 있다. schematic sketch1234567891011121314151617181920212223242526272829303132333435// the number of the 3 LED pinconst int R_ledPin = 2; // corresponds to GPIO 2const int G_ledPin = 4; // corresponds to GPIO 4const int B_ledPin = 17; // corresponds to GPIO 17// setting PWM propertiesconst int freq = 5000;const int ledChannel = 0;const int resolution = 8; // 8bit 0~255 void setup(){ // configure LED PWM functionalitites ledcSetup(ledChannel, freq, resolution); // attach the same channel to the 3 GPIO to be controlled ledcAttachPin(R_ledPin, ledChannel); ledcAttachPin(G_ledPin, ledChannel); ledcAttachPin(B_ledPin, ledChannel);} void loop(){ // increase the LED brightness for(int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++){ // changing the LED brightness with PWM ledcWrite(ledChannel, dutyCycle); delay(15); } // decrease the LED brightness for(int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle--){ // changing the LED brightness with PWM ledcWrite(ledChannel, dutyCycle); delay(15); }}","link":"/2019/10/19/ESP32-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"ESP32, 온도측정(DS18b20), PLX_DAQ","text":"DS18b20 온도센서DS18b20 온도 센서를 이용하여 온도를 측정한다. one-wire 버스 통신 공급전압: 3.0V ~ 5.5V 작동온도: -55ºC ~ +125ºC 오차: +/-0.5 ºC (-10ºC ~ 85ºC 범위에서) Pinout schematicDS18b20 센서는 두 가지 연결방법을 제공하는데, 하나는 VCC를 5V에 연결하는 Normal Mode이고 다른 하나는 VCC를 GND에 연결하는 Parasite Mode이다. 두가지 방법 모두 지원되지만 (경험상) Normal를 추천하며 (원인은 잘 모르겠지만) Parasite Mode에서는 온도센서가 작동이 되지 않는 경우도 가끔 있었다. 회로 구성을 위해 4.7㏀ 저항 1개가 필요하며 Normal Mode 구성을 위해 다음 그림과 같이 연결한다. 3가닥의 선에 브레드보드에 연결할 수 있는 핀을 납땜하고, 노란색선과 빨간색선의 연결부위에 4.7㏀ 저항을 추가로 납땜하여 연결한다. 수축튜브를 사용하여 연결부위를 절연한 뒤, 구경이 조금 더 큰 수축튜브를 사용하여 3가닥을 하나로 감싸 마무리한다. Normal Mode 라이브러리 준비하기Sketch&gt; Include Library&gt; Manage Libraries&gt; OneWire (by Jim Studt etc.) DallasTemperature (by Miles Burton) sketch1234567891011121314151617181920212223242526#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 4OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);void setup() { Serial.begin(115200); Serial.println(&quot;DallasTemperature IC Control&quot;); // Start up the library sensors.begin();}void loop() { sensors.requestTemperatures(); float temperatureC = sensors.getTempCByIndex(0); float temperatureF = sensors.getTempFByIndex(0); Serial.print(temperatureC); Serial.println(&quot;*C&quot;); Serial.print(temperatureF); Serial.println(&quot;*F&quot;); delay(2000);} PLX-DAQESP32를 사용하여 센서데이터를 Excel로 보내고 실시간 그래프를 그려주는 Excel 매크로 파일이다. Parallax에서 만든 것이지만, 현재 공식적인 업데이트는 중지되어 있다. 이런 이유로 Parallax 홈페이지에서 다운로드 받을 수 있는 PLX-DAQ는 최신 버전의 Excel에서 활용이 불가능하며, ESP32에서의 활용도 불가능하다. 현재는 아두이노 포럼 등에서 최신 버전의 Excel과 ESP32 등에서 활용 가능하도록 업데이트를 진행하고 있으므로 Parallax 홈페이지가 아닌, 아두이노 포럼에서 다운로드 받도록 한다. downloadPLX-DAQ version 2 - now with 64 bit support! (and further new features) - Using Arduino / Interfacing w/ Software on the Computer - Arduino Forum) sketch void setup() Excel Sheet Clear 1Serial.println(&quot;CLEARDATA&quot;); Label 만들기 (콤마(,)로 구분) 1Serial.println(&quot;LABEL,Date,Time,Millis,SensorValue&quot;); void loop() Data 출력 12Serial.println( (String) &quot;DATA,DATE,TIME,&quot; + millis() + &quot;,&quot; + SensorValue ); delay(200); (혹은, 아래와 같이 라인을 구분하는 것도 좋은 방법이다. 123456Serial.print(&quot;DATA,DATE,TIME,&quot;);Serial.print(millis());Serial.print(&quot;,&quot;);Serial.print(i);Serial.print(&quot;,&quot;);Serial.println(SensorValue); DATA 출력시작은 Serial.print(“DATA,”); 로 하며, DATA 출력종료는 println을 통해 개행한다. delay를 500이상 주어야 안정적으로 데이터를 수신한다. 전체 sketch GPIO4 데이터를 엑셀 파일에 기록한다. 123456789101112131415161718192021int i = 0;const int SensorPin = 4;float SensorValue;void setup() { Serial.begin(115200); Serial.println(&quot;CLEARDATA&quot;); Serial.println(&quot;LABEL,Date,Time,Millis,Times,SensorValue&quot;);}void loop() { SensorValue = analogRead(SensorPin)/100.00; Serial.print(&quot;DATA,DATE,TIME,&quot;); Serial.print(millis()); Serial.print(&quot;,&quot;); Serial.print(i); Serial.print(&quot;,&quot;); Serial.println(SensorValue); i++; delay(5000); // 5초마다 1번씩 측정} 온도센서의 온도값 기록하기sketch1234567891011121314151617181920212223242526272829303132333435#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;int i = 0;const int SensorPin = 4;float temperatureC;//float temperatureF;OneWire oneWire(SensorPin);DallasTemperature sensors(&amp;oneWire);void setup() { Serial.begin(115200); Serial.println(&quot;DallasTemperature IC Control&quot;); // Start up the library sensors.begin(); Serial.println(&quot;CLEARDATA&quot;); Serial.println(&quot;LABEL,Date,Time,Millis,Times,SensorValue&quot;);}void loop() { sensors.requestTemperatures(); temperatureC = sensors.getTempCByIndex(0); // temperatureF = sensors.getTempFByIndex(0); Serial.print(&quot;DATA,DATE,TIME,&quot;); Serial.print(millis()); Serial.print(&quot;,&quot;); Serial.print(i); Serial.print(&quot;,&quot;); Serial.println(temperatureC); i++; delay(5000); // 5초마다 1번씩 측정} PLX-DAQ 엑셀파일 실행 다운로드 받은 PLX-DAQ 엑셀 매크로 파일을 더블 클릭하여 불러들인다. Settings에서 ESP32가 연결된 Com port와 Baud rate 설정 Port: 6 (장치 관리자&gt; 포트&gt; 에서 확인) Baud: 115200 (ESP32의 경우 115200, 아두이노는 9600으로 셋팅) 스케치를 업로드 한 뒤, Connect를 누르면 실시간으로 데이터를 받아서 기록함 기본적으로 셋팅되어 있는 차트가 실시간으로 그려진다. 단, 차트가 그려지지 않거나 잘못된 형태로 표현되는 경우, 엑셀 차트의 데이터 범위를 재설정하여야 한다. Microsoft Data StreamerPLX-DAQ와 비슷한 역할을 하는 Microsoft Data Streamer가 있으나, 현재 아두이노만 지원하며 ESP32에서는 데이터를 전송받지 못하는 문제가 있음.","link":"/2021/09/16/ESP32-%EC%98%A8%EB%8F%84%EC%B8%A1%EC%A0%95-DS18b20/"},{"title":"Processing 기초","text":"processing.org 에서 다운로드 (다운로드 페이지) arduino sketch는 C++기반이고, processing sketch는 java기반입니다. processing sketch 예제 예제1 : 프로세싱 윈도우 크기, 배경색, 점, 선, 사각형, 원, 텍스트, 폰트, 사진 입력 123456789101112131415161718192021222324void setup() { size(400,400); background(100); // background(0,255,0); strokeWeight(10); // dot/line width stroke(0,255,0,100); // dot/line color and transparency, noStroke(); point(200,200); // draw dot line(0,0,200,150); // draw line ellipse(300,300,50,80); // draw circle(x,y,xr,yr) fill(0); // rect/text color, nofill(); rect(100,250,150,300); // draw rectangle(x1,y1,x2,y2) textSize(20); PFont font = createFont(&quot;NanumGothic&quot;, 32); textFont(font); text(&quot;Hello World!&quot;,200,100); // text(string,x1,y2) PImage img = loadImage(&quot;sks.jpg&quot;); // file in '/sketch_XXXXXXa/data/' folder image(img,20,50); // image(img,x,y,width,height); }void draw() {} 예제2 : 마우스와 키보드 이벤트 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void setup() { size(400,400);}void draw() { }void mousePressed() { if(mouseButton == LEFT) { println(&quot;left button Pressed!&quot;); } else if(mouseButton == RIGHT) { println(&quot;right button Pressed!&quot;); } else if(mouseButton == CENTER) { println(&quot;center button Pressed!&quot;); }}void keyPressed() { println(&quot;key Pressed!&quot;); // Key event println(key); // Key String println(keyCode); // ASCII Code}void mouseReleased() { println(&quot;button Released!&quot;);}void keyReleased() { println(&quot;key Released!&quot;);}void mouseClicked() { println(&quot;button Clicked!&quot;);}void mouseMoved() { println(&quot;mouse Moved!&quot;);}void mouseDragged() { println(&quot;mouse Dragged!&quot;);}void mouseWheel() { println(&quot;mouse Wheel!&quot;);} 예제3 : 마우스 움직이는 대로 원 그리기 12345678910void setup() { size(400,400);}void draw() { }void mouseMoved() { ellipse(mouseX,mouseY,50,50); } 예제4 : 자유선 그리기 12345678910void setup() { size(400,400);}void draw() { }void mouseMoved() { line(pmouseX,pmouseY,mouseX,mouseY); } Arduino와 Processing을 통해 arduino 보드의 기본 led blink 하기schematic아두이노의 기본 LED를 사용할 것이므로 별도의 회로 연결없이 아두이노만 연결한다. library 등록 아두이노 사이트에서 프로세싱 라이브러리를 다운받은 후 압축을 풀었을 때 나오는 arduino폴더를 c:\\Users\\userID\\processing\\libraries\\ 폴더에 복사한다. 프로세싱 프로그램에서 스케치 → 내부라이브러리 → Arduino (firmata)를 선택하면, 123import cc.arduino.*;import org.firmata.*;import processing.serial.*; 가 등록된다. processing sketch1234567891011121314151617181920import cc.arduino.*;import org.firmata.*;import processing.serial.*;Arduino arduino;int ledPin = 13;void setup() { size(400,400); println(Arduino.list()); arduino = new Arduino(this, Arduino.list()[0], 57600); // Arduino.list()[0] or &quot;COM3&quot; arduino.pinMode(ledPin, Arduino.OUTPUT);}void draw() { arduino.digitalWrite(ledPin, Arduino.HIGH); delay(1000); arduino.digitalWrite(ledPin, Arduino.LOW); delay(1000);} arduino sketch arduino IDE에서 파일 → 예제 → firmata → standard firmata를 불러들인 후 컴파일하고 업로드한다. processing에서 실행하기 processing에서 실행버튼을 눌러 실행해보기 파일 → 어플리케이션으로 내보내기를 선택하여 윈도우, Mac, Linux용 실행파일을 만들어보기 ※ 어플리케이션으로 내보내기를 하기전에 processing sketch를 저장하여야 한다. Processing으로 led 제어하기processing sketch : 사각형 스위치1234567891011121314151617181920212223242526272829303132import cc.arduino.*;import org.firmata.*;import processing.serial.*;Arduino arduino;int ledPin = 13;void setup() { size(400,400); background(0); fill(255); noStroke(); rect(width/2, 0, width/2, height); text(&quot;LED OFF&quot;, 30, 30); fill(0, 0, 0); text(&quot;LED ON&quot;, 230, 30); println(Arduino.list()); arduino = new Arduino(this, Arduino.list()[0], 57600); arduino.pinMode(ledPin, Arduino.OUTPUT);}void draw() {}void mouseMoved() { if(mouseX &lt; width/2) { arduino.digitalWrite(ledPin, Arduino.LOW); } else { arduino.digitalWrite(ledPin, Arduino.HIGH); }} processing sketch : 그라데이션 가변저항12345678910111213141516171819202122232425import cc.arduino.*;import org.firmata.*;import processing.serial.*;Arduino arduino;int ledPin = 13;void setup() { size(400,400); for(int i=0; i&lt;width; i++) { stroke(map(i, 0, width-1, 0, 255)); // 색깔을 점차 변화시키면서 line(i, 0, i, height); // 선을 그려, 그라데이션 효과를 만들어 냄 } println(Arduino.list()); arduino = new Arduino(this, Arduino.list()[0], 57600);}void draw() {}void mouseMoved() { arduino.analogWrite(ledPin, int(map(mouseX, 0, width-1, 0, 255)));}","link":"/2018/11/30/Processing-%EA%B8%B0%EC%B4%88/"},{"title":"STEM, Solar Tracker","text":"Solar Tracker 만들기팬(도리도리) &amp; 틸트(끄덕끄덕)가 가능한 2축 서보모터 거치대와 2개의 서보모터를 사용하여 Solar Tracker를 만들어 보자. 단계1: Solar Tracker Frame 3D Printing .stl 파일 .gcode 파일 3D 프린팅 후, 조도센서를 설치할 4곳에 1mm 드릴을 이용하여 각각 2개씩 구멍을 뚫는다 (총 8개). 단계2: 조도센서 조립하기조도센서 삽입 조도센서의 다리를 위에서 뚫은 구멍을 통해 넣은 뒤, 뒤쪽에 글루건을 쏘아 고정시킨다. (조도센서는 극성을 구분할 필요가 없으므로, 서로 선이 맞닿지만 않으면 된다.) 4개의 조도 센서를 위와 같은 방식으로 고정한다. 10kΩ 저항 연결아래 그림과 같이 연결한다. 각 조도센서에 연결된 2개의 선 중 하나를 골라 10k 저항을 연결하고 한 뒤, 저항의 다른 쪽 끝을 모두 맞붙여서 GND에 연결한다. 조도센서의 다른 한쪽 끝을 모두 맞붙여서 ESP32의 3.3V에 연결한다. GND와 3.3로 연결되는 선들이 서로 붙지 않도록 절연테이프를 붙여준다. 각 조도센서와 10k 저항의 사이에 ESP32에 연결할 GPIO선을 하나씩 납땜하여 연결한다. ESP32의 3.3V와 GND에 연결할 선도 함께 납땜하여 연결한다. 선 모양을 잡아 정리한다. (위 사진에는 하트 모양처럼 양 옆으로 선이 나와 있지만, 추후 거치대 장착을 위해서는 아래 사진처럼 모두 오무려주어야 한다.) 단계3: 2축 서보모터 거치대에 장착하기 schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/************ ESP32 SKETCH FOR SOLAR TRACKER *************************************** Author: K. Jun, Lee Blog: https://stemwith.github.io 2020-12-04// Use 3.3V for LDR sensor VCC// Edit your sensor sensitivity: tolh, tolv// Edit your sensor GPIO pin: ldr_lt, ldr_rt, ldr_ld, ldr_rd// Edit initial sensor calibration value: avlt_cali, avrt_cali, avld_cali, avrd_cali ***********************************************************************************/// for horizontal Servo PWM propertiesconst int ledPin_hori = 19; // corresponds to GPIO 19const int ledChannel_hori = 1;const int freq_hori = 50;const int resolution_hori = 16;// for vertical Servo PWM propertiesconst int ledPin_vert = 18; // corresponds to GPIO 18const int ledChannel_vert = 0;const int freq_vert = 50;const int resolution_vert = 16;int deg_hori = 90; // default horizonint deg_vert = 45; // default verticalint duty;// LDR sensor pinint ldr_lt = 32; // Left_Top LDR pinint ldr_rt = 33; // Right_Top LDR pinint ldr_ld = 34; // Left_Down LDR pinint ldr_rd = 35; // Right_Down LDR pin// LDR sensor valueint lt[10];int rt[10];int ld[10];int rd[10];// Sensitivity (tolerance)int tolh = 150; // horizon toleranceint tolv = 150; // vertical tolerance// initial sensor correction value int avlt_cali = 0; // 초기값 보정int avrt_cali = 350; // (센서에 밝은 빛을 직접 가하여 최대값을 측정한 뒤 편차를 사용)int avld_cali = 330;int avrd_cali = 430;void setup() { Serial.begin(115200); // Servo PWM Setup ledcSetup(ledChannel_hori, freq_hori, resolution_hori); // PWM CH1, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_hori, ledChannel_hori); // PWM CH1을 GPIO 19번으로 출력 ledcSetup(ledChannel_vert, freq_vert, resolution_vert); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin_vert, ledChannel_vert); // PWM CH0을 GPIO 19번으로 출력}void loop() { int avlt = 0; int avrt = 0; int avld = 0; int avrd = 0; for (int i=0; i&lt;10; i++) { lt[i] = analogRead(ldr_lt); // Left Top avlt = avlt + lt[i] - avlt_cali; rt[i] = analogRead(ldr_rt); // Right Top avrt = avrt + rt[i] - avrt_cali; ld[i] = analogRead(ldr_ld); // Left Down avld = avld + ld[i] - avld_cali; rd[i] = analogRead(ldr_rd); // Right Down avrd = avrd + rd[i] - avrd_cali; } avlt = avlt / 10; avrt = avrt / 10; avld = avld / 10; avrd = avrd / 10; int avt = (avlt + avrt) / 2; // Average of Top value int avd = (avld + avrd) / 2; // Average of Down value int avl = (avlt + avld) / 2; // Average of Left value int avr = (avrt + avrd) / 2; // Average of Right value. int dvert = avt - avd; // Difference Top, Down int dhoriz = avl - avr; // Difference Left, Right Serial.println(&quot;LT\\tRT\\tLD\\tRD\\tav.T\\tav.D\\tav.L\\tav.R\\td.ver\\td.hor&quot;); Serial.print(avlt);Serial.print(&quot;\\t&quot;);Serial.print(avrt);Serial.print(&quot;\\t&quot;); Serial.print(avld);Serial.print(&quot;\\t&quot;);Serial.print(avrd);Serial.print(&quot;\\t&quot;); Serial.print(avt);Serial.print(&quot;\\t&quot;);Serial.print(avd);Serial.print(&quot;\\t&quot;); Serial.print(avl);Serial.print(&quot;\\t&quot;);Serial.print(avr);Serial.print(&quot;\\t&quot;); Serial.print(dvert);Serial.print(&quot;\\t&quot;);Serial.print(dhoriz);Serial.println(&quot;\\t\\n&quot;); if (abs(dvert) &gt; tolv) { // sensitivity if (avt &lt; avd) { // 아래쪽 센서가 더 밝으면 deg_vert = ++deg_vert; if (deg_vert &gt; 90) { deg_vert = 90; } } else if (avt &gt; avd) { // 윗쪽 센서가 더 밝으면, deg_vert = --deg_vert; if (deg_vert &lt; 0) { deg_vert = 0; } } servoWrite(ledChannel_vert, deg_vert); } if (abs(dhoriz) &gt; tolh) { // sensitivity if (avl &gt; avr) { // 왼쪽 센서가 더 밝으면 deg_hori = --deg_hori; if (deg_hori &lt; 0) { deg_hori = 0; } } else if (avl &lt; avr) { // 오른쪽 센서가 더 밝으면 deg_hori = ++deg_hori; if (deg_hori &gt; 180) { deg_hori = 180; } } else if (avl == avr) { // nothing } servoWrite(ledChannel_hori, deg_hori); } delay(500);}// deg는 0~180도 까지void servoWrite(int ch, int deg){ duty = map(deg, 0, 180, 1638, 8192); ledcWrite(ch, duty); delay(50); // delay를 줄이면 180도가 완전히 돌지 않음 (최소값 15)} 태양광 패널의 전압 측정하기MPPT모듈을 만들기 전, 태양광패널에서 만들어지는 전기의 전압을 측정해본다. ESP32의 경우 내부전압 3.3V, 12bit ADC이므로 12// ESP32 3.3V -&gt; 3.21 , Arduino 5.0V -&gt; 4.89const float referenceVolts = 3.21; 12// ESP32 12bit_ADC (4095.0), Arduino 10bit_ADC (1023.0)float volts = (referenceVolts/4095.0)*val*1000; 를 사용한다. schematic sketch123456789101112131415161718192021222324// ESP32 3.3V -&gt; 3.21 , Arduino 5.0V -&gt; 4.89const float referenceVolts = 3.21; void setup() { Serial.begin(9600);}void loop() { float volts_sum = 0; for (int i=0; i&lt;=10; i++) { int val = analogRead(32); // ESP32 12bit_ADC (4095.0), Arduino 10bit_ADC (1023.0) float volts = (referenceVolts/4095.0)*val*1000; volts_sum = volts_sum + volts; delay(100); } volts_sum = volts_sum / 10; Serial.print(&quot;V = &quot;); Serial.print(volts_sum); Serial.println(&quot; mV&quot;); delay(100);}","link":"/2020/11/22/STEM-Solar-Tracker/"},{"title":"전자기파 검출기 만들기","text":"전자기파 검출콘센트, 멀티탭, 전자제품 등에서 나오는 60Hz 정도의 전자파를 검출하여 증폭시킨 뒤, 이를 스위칭 신호로 만들어 LED를 켜는 회로를 구성해본다. ※ 참고: 눈이 즐거운 물리 (www.phys.pe.kr) schematic 작동원리 안테나에 전자기파가 잡히면 C1815 트랜지스터로 신호를 증폭 1N4148 다이오드는 반대 방향으로 흐르는 노이즈 신호를 제거하여, 안테나에 잡힌 전자기파만을 유효 신호로 처리하도록 함 증폭된 신호를 A1015 트랜지스터를 스위치 삼아 LED를 켬 준비물개별 준비물 LED 1개 0.01uF (103) 세라믹 캐패시터 1개 A1015 트랜지스터 1개 C1815 트랜지스터 1개 10uH 인덕터 코일 (갈-검-검-금) 1개 1N4148 스위칭 다이오드 1개 CR2032 3V 리튬전지 1개 듀퐁 케이블 10P (9P 사용 가능) 1개 기타 준비물스트리퍼, 가위, 스카치테이프 듀퐁 케이블 준비 듀퐁 케이블은 40P 형태로 판매되는 것이 많으므로, 40P 10cm 듀퐁 케이블 구입한다. 갈색과 검은색 사이를 갈라내어 10P 4세트로 만든다. 이제, (갈-빨-주-노-초-파-보-회-흰-검) 10P가 1세트가 된다. 준비한 10P 케이블을 가위를 사용하여 반으로 잘라, 10P 8세트로 만든다. 1명당 1세트만 사용하면 되므로, 40P 듀퐁케이블 1개를 구입하면 학생 8명이 사용할 수 있다. 준비 완료 제작 방법듀퐁 케이블을 사용하여 회로 구성하기 10가닥의 케이블을 (갈-빨-주-노-초-파-보-회-흰-검) 번호 순서대로 나열한 뒤, 스카치 테이프로 단단히 고정한다. 번호 1 2 3 4 5 6 7 8 9 0 색깔 갈 빨 주 노 초 파 보 회 흰 검 케이블의 중간 위치 정도까지 스카치 테이프를 붙여 단단히 고정한다. 케이블 아래쪽을 모두 갈라 10가닥으로 만든다. 빨간색(2번), 초록색(5번), 보라색(7번), 검은색(0번) 케이블을 짧게 자른다. 남아있는 케이블(갈(1번), 주(3번), 노(4번), 파(6번), 회(8번), 흰(9번))의 끝부분 7~8mm 정도를 스트리퍼의 22AWG 부분으로 집은 뒤에 힘을 주어 벗겨낸다. (흰색(9번)은 벗겨내지 않아도 됨) 주황색(3번)선과 파란색(6번)선의 끝부분을 모은 뒤, 함께 꼬아 하나로 만든다. 같은 방법으로, 노란색(4번)선과 회색(8번)선의 끝부분을 모아 하나로 만든 뒤, 다른 곳에 닿지 않도록 스카치테이프로 절연처리한다. 스카치테이프를 사용하여 CR2032 배터리를 붙인다. CR2032 (+)극 (CR2032 레터링 된 면) : 갈색(1번) 선을 스카치테이프로 단단히 붙임 CR2032 (-)극 (검은색 테두리가 보이는 면) : 주황색(3번)/파란색(6번) 선을 하나로 묶어낸 선을 붙임 부품 꼽기 LED (LED는 극성이 있으므로 주의한다.) (+)극 (다리가 긴 쪽) : 갈색(1번)에 삽입 (-)극 (다리가 짧은 쪽) : 빨간색(2번)에 삽입 A1015 트랜지스터 (글씨가 써 있는, 평평한 부분을 바라보았을 때를 기준으로) 왼쪽 핀 (Emitter) : 빨간색(2번)에 삽입 가운데 핀(Collector) : 주황색(3번)에 삽입 오른쪽 핀(Base) : 노란색(4번)에 삽입 0.01uF (103) 세라믹 캐패시터 (극성 없음) : 노란색(4번)과 파란색(6번)에 삽입 10uH 인덕터 코일 (극성 없음) : 파란색(6번)과 보라색(7번)에 삽입 C1815 트랜지스터 (글씨가 써 있는, 평평한 부분을 바라보았을 때를 기준으로) 왼쪽 핀 (Emitter) : 보라색(7번)에 삽입 가운데 핀(Collector) : 회색(8번)에 삽입 오른쪽 핀(Base) : 흰색(9번)에 삽입 1N4148 스위칭 다이오드 (방향에 주의!) 흰색(9번)선은 안테나의 역할을 한다. 완성!! 테스트 전자파가 나올 만한 곳에 가져가 본다. 핸드폰 충전기가 꼽혀있는 콘센트 근처에 가져가 보았더니, 다음과 같이 LED에 불이 들어왔다.","link":"/2021/11/02/STEM-%EC%A0%84%EC%9E%90%EA%B8%B0%ED%8C%8C-%EA%B2%80%EC%B6%9C%EA%B8%B0/"},{"title":"엑셀, 다중조건을 사용하여 랭킹 구하기","text":"1가지 조건으로 랭킹을 구하는 경우, rank.eq() 함수를 사용하면 되지만, 2가지 이상의 조건이 부합하는 경우에는 rank.eq() 함수로는 구할 수 없습니다. 이처럼 다중 조건이 주어졌을 때 랭킹을 구하는 방법입니다. 예시 위 예시에서 ‘자격’과 ‘계열’ 조건에 따라 각각의 랭킹을 구하는 함수는 3년인문 랭킹의 경우 1=IF(AND($E3=L$1,$F3=L$2),SUMPRODUCT(($E$3:$E$27=$E3)*($F$3:$F$27=$F3)*($J$3:$J$27&gt;$J3))+1,&quot;&quot;) 입니다. L1, L2에 ‘3’, ‘인문’이라는 조건을 넣고 AND($E3=L$1,$F3=L$2) 부분을 통해 E, F열의 값이 각각 ‘3’과 ‘인문’인 경우에만 J3:J27 까지의 국어영어 합계점수에 따라 랭킹을 부여합니다. 동석차인경우 높은 순위의 값을 부여합니다.","link":"/2018/06/01/%EC%97%91%EC%85%80-%EB%8B%A4%EC%A4%91%EC%A1%B0%EA%B1%B4%EB%9E%AD%ED%82%B9/"},{"title":"드론의 비행 원리","text":"드론의 비행 원리를 이해하기 이전에, 먼저 헬리콥터의 비행원리를 알아보는 것이 좋습니다. 헬리콥터의 비행 원리헬리콥터의 비행과 관련된 4가지 힘은 그림과 같습니다. 양력: 로터의 회전에 의해 발생하는 힘으로, 이를 조절하여 상승, 하강, 호버링을 할 수 있습니다. 추력: 로터 회전면의 기울기를 조절하여 전진하려는 힘인 추력을 발생시키고, 이를 조절하여 가속 또는 감속을 조절합니다. 항력 중력 헬리콥터의 토크와 반토크헬리콥터 블레이드의 회전반시계 방향으로 회전하는 블레이드가 있다고 가정합니다. 이 블레이드가 빠른 속도로 회전하면 양력이 발생하여 상승하게 됩니다. 헬리콥터의 토크그런데 블레이드 회전에 의해 생기는 토크(회전체에 매달려 있는 물체가 회전체의 반대방향으로 회전하려는 힘)도 함께 발생하죠. 즉, 블레이드가 (반시계방향으로) 빠른속도로 회전하면 양력이 발생하여 상승하게 되는데요. 이때 발생하는 토크(회전체에 매달려 있는 물체가 회전체의 반대방향으로 회전하려는 힘)로 인해 (양력에 의해 상승함과 동시에) 동체는 시계방향으로 회전하며 빙글빙글 돌게 됩니다. 토크에 대한 반토크그러므로 동체가 회전하지 않도록 토크를 상쇄할 수 있는 반토크(anti-torque)를 만들어 주어야 합니다. 이를 위해 일반적으로 꼬리쪽에 작은 블레이드를 추가합니다. 꼬리블레이드가 회전하면 반토크를 만들 추진력이 생기고 이 힘으로 반토크를 만들어 낼 수 있습니다. 이렇게 되면 동체가 회전하지 않고 안정적으로 상승이 가능해지게 되는 것입니다. 모든 헬리콥터는 토크와 반토크를 조절하여 동체가 회전하지 않고 안정적으로 운용될 수 있도록 하는 것이 가장 중요합니다. 동축반전식 헬기반토크를 만들어내는 또 다른 방식은 동축반전식 헬기입니다. 두 개의 블레이드를 위아래로 배치하고 서로 반대방향으로 회전시켜 양력을 얻음과 동시에 서로간의 토크를 상쇄하는 방식입니다. 텐덤날개회전식 헬기대형 헬리콥터에서는 동체 앞뒤로 2개의 로터로 회전방향을 반대로 하여 서로의 토크를 반토크로 이용하는 텐덤날개회전방식을 이용하기도 합니다. 텐덤날개회전식 헬기의 원리이것을 Top View로 나타내면 다음과 같습니다. 두개의 블레이드가 서로 반대방향으로 회전하면서 서로의 토크를 상쇄시켜주게 되는 것이죠. 드론드론의 경우도 마찬가지 입니다. 쿼드콥터 드론은 4개의 프롭를 사용하여 토크-반토크의 균형이 이루어집니다. 이 상태에서 프롭의 회전속도를 빠르게 증가시키면 양력이 발생하여 수직 상승이 이뤄지고 회전속도를 느리게 하면 양력과 중력이 균형을 이루는 호버링 상태를 만들 수 있습니다. 물론 회전속도를 보다 더 느리게 만들면 양력보다 중력이 커지게 되어 수직 하강하게 됩니다. 여기서 한가지 유의할 점은 프롭의 회전방향은 실제 모터의 SPEC에 표기된 회전방향과는 반대라는 것입니다. 즉, 위 그림에서 1,2번 프롭의 회전방향은 CCW이지만 실제로는 CW규격의 모터를 사용해야 합니다. 이것은 모터의 실제 회전방향과 모터에 끼워져있는 프롭의 회전방향을 외부에서 관측하는 방향이 서로 반대이기 때문입니다. 옛날에 사용한 단발프롭 비행기를 생각해보세요. 비행기 조종사가 조종석에 앉아 앞쪽의 프롭을 바라볼 때 관측되는 프롭의 회전방향이 실제 모터의 SPEC상 회전방향이며, 이 방향이 CCW라고 가정합니다. 이 상황을 프롭을 비행기에 끼우는 정비사가 (조종석을 마주보며 정면에서) 관측해보면 프롭 회전방향이 CW가 되겠지요. 조종사는 프롭이 CCW로 돈다고 이야기하고(실제 모터의 SPEC상 회전 방향), 프롭을 끼운 사람은 CW로 돌아가는 상태로 보고있으니 같은 상황을 서로 반대가 되는 것입니다. 또 다른 이유는 모터를 판매할 때에는 모터캡(프롭너트)이 나사산을 따라 조여지는 방향으로 표기하기 때문입니다. 그러므로 1,2번 모터에 모터캡(프롭너트)을 돌려 끼울때에는 CW방향으로 돌려서 끼워야 하고, 3,4번 모터에 돌려 끼울때에는 CCW방향으로 돌려서 끼워야 합니다. 1,2번 모터가 실제로 CCW방향으로 회전하고, 프롭 나사산은 CW방향으로 돌려서 끼워지기 때문에, 프롭이 회전할 때 절대로 풀릴 위험이 없습니다. 만약 두 방향이 똑같다면 프롭이 고속으로 회전하면서 빠질 위험이 있으므로 주의해야 합니다. 만약 보유하고 있는 4개 모터의 나사산 방향이 모두 똑같다면 두 가지 방법으로 문제를 해결할 수 있습니다. 첫째, 나사산 방향이 반대인 프롭어댑터를 2개 구입하거나, 둘째, 나이록(niloc, nilon)너트 혹은 나이록후렌지 너트를 사용하여 조여주어야 합니다. 모터의 한글표기도 주의해야 하는데요. 예를 들어 1,2번 모터에 표기된 SPEC이 CW인데, 이 모터를 한글로 표기하거나 지칭할 때에는 SPEC에 표기된 방향이 아니라 (위에서 내려다 볼 때 보이는) 프롭의 회전방향에 맞춰 ‘역방향모터’라고 부릅니다. 마찬가지로 3,4번 모터를 ‘정방향모터’라고 합니다. 표기방법이 혼란스러운 면이 있다보니 역방향, 정방향을 반대로 표기하는 경우도 많아요. 그러므로 모터 구입시에는 모터에 표기된 SPEC을 보고 구입하는 것이 좋습니다. 이와 더불어 드론 조립 시에는 각 모터별로 어떤 모양의 프롭을 사용해야 하는지 유의해야 합니다. 프롭을 모터축에 꼽은 상태에서 프롭면을 보면 프롭면이 위로 올라온 부분과 아래로 내려간 부분이 있는데 이 방향을 주의해서 보아야 합니다. 기본 원칙은 드론의 프롭회전을 위에서 내려다보는 입장에서 프롭면이 위로 올라온 부분으로 회전이 이루어져야 양력이 발생한다는 것입니다. 드론의 운행 모드이제 드론의 운행이 어떻게 이루어지는지 알아보겠습니다. 상승(Ascend) 모드: 4개의 모터가 고석으로 회전하면 수직으로 상승 호버링(Hovering) : 4개의 모터가 중력과 평형인 양력을 만들어내는 정도의 속력으로 회전하며 상하고도를 안정적으로 유지 하강(Descend) 모드: 4개의 모터가 저속으로 회전하면 수직으로 하강 상승, 하강과 같은 수직 운행은 조종기의 왼쪽 스틱인 Throttle을 사용합니다. (Mode2 기준) 상승 호버링 하강 전진전방의 1,3번 모터보다 후방의 2,4번 모터를 빠르게 회전시키면 토크가 상쇄된 상태에서 후방모터에서 생긴 추력에 의해 전방으로 날아가게 됩니다. 이때 드론의 모습을 측면에서 보면 2,4번 후방모터가 고속으로 회전하며 드론의 동체가 전방으로 기울진 형태가 됩니다. 이렇게 드론면이 기울어지게 되면 드론이 수평을 이루고 있을 때보다 상승하려는 양력이 약해지는데, 이 양력이 중력과 평형을 이루게 되면서 일정한 고도를 유지하게 됩니다. 이때 앞으로 전진하려는 추진력이 남게 되므로 드론이 전방으로 전진하게 되는 것입니다. 기울어진 정도를 더 크게 하면 어떻게 될까요? 위로 떠오르려는 양력은 더 작아지고 전진하려는 추력은 커지므로, 하강하면서 더 빠르게 전진하는 형태가 될 것입니다.’ 만약 고도를 유지하며 더 빠른 전진형태를 만들려면 양력을 보충해야 하므로 기울기를 크게 하고 모터의 회전을 더 빠르게 해주면 됩니다. 후진 전진, 후진 같은 수평 운행은 조종기의 오른쪽 스틱을 위아래로 움직이며, 이를 Pitch(=Elevator)라고 합니다. (Mode2 기준) 왼쪽으로 이동(Roll Left) 오른쪽으로 이동(Roll Right) 왼쪽, 오른쪽 이동 같은 수평 운행은 조종기의 오른쪽 스틱을 좌우로 움직이며, 이를 Roll(=Aileron)이라고 합니다. (Mode2 기준) 좌회전 비행CCW로 회전하는 1,2번 모터가 저속으로 회전할 때, CW로 회전하는 3,4번 모터가 고속으로 회전하면 알짜회전이 CW가 되므로, CCW방향으로 토크가 발생하여 드론 동체가 CCW방향으로 회전한다. 우회전 비행CW로 회전하는 3,4번 모터가 저속으로 회전할 때, CCW로 회전하는 1,2번 모터가 고속으로 회전하면 알짜회전이 CCW가 되므로, CW방향으로 토크가 발생하므로 드론 동체가 CW방향으로 회전한다. 이러한 제자리 회전은 조종기의 왼쪽 스틱을 좌우로 움직이며, 이를 Yaw(=Rudder)라고 합니다. (Mode2 기준) 조종기 MODEMODE1은 MODE2와 Throttle과 Pitch가 서로 반대입니다. MODE1은 과거에 많이 사용되었으나 요즘은 MODE2를 주로 사용합니다. 어떤 것이 더 좋다기 보다는 각기 운용의 장단점이 있으므로 사용자가 판단하여 사용하면 됩니다.","link":"/2018/11/01/%EB%93%9C%EB%A1%A0%EC%9D%98-%EB%B9%84%ED%96%89-%EC%9B%90%EB%A6%AC/"},{"title":"엑셀, 데이터 유효성 검사의 목록 구성시 동적 범위 설정","text":"데이터 유효성 검사를 할 때, 상황에 따라서 목록 구성이 다르게 표시되는 방법을 알아보겠습니다. 일단 다음의 경우를 예로 들면, 학교급(초등, 중등, 고등 등)을 선택하였을 때, 초등을 선택하면 학년을 선택하는 셀에서 16학년까지 6개의 목록을 선택할 수 있도록 표시되고, 중등을 선택하면 79학년, 고등을 선택하면 10~12학년을 선택할 수 있는 목록이 표시되도록 하는 것을 의미합니다. 또 학년마다 학급수가 다르기 때문에 각 학년을 선택하였을 때, 그 학년의 학급수만큼 학급 목록이 뜨도록 하면 더 좋겠죠. 이렇게 상황에 따라 목록이 유동적으로 표시되도록 하면, 데이터를 취합하는 입장에서 오류를 줄일 수 있는 상황을 기대할 수 있습니다. 목록 구성 설정먼저 설정 시트를 만들고 조건으로 사용할 목록을 구성해보겠습니다. 여기서는 두가지가 필요한데 학교급에 따른 학년범위 설정 : 초등은 16학년, 중등은 79학년, 고등은 10~12학년, 국제와 유치는 학년개념이 없으므로 그대로 국제와 유치로 설정 학년에 따른 학급범위 설정 : 국제는 국제반, 유치는 토끼/사슴/기린반으로 나뉘고 그밖의 1~12학년까지 각 학년별 학급수를 나타냅니다. 이름 만들기예를 들어서 설명하는 것이 가장 좋을 것 같네요. 수식&gt; 이름 관리자를 클릭한 후 새로 만들기를 클릭 이름 : 학교급_초등 참조 대상 : 설정!$C$3:$C$8 즉, C2셀을 이름으로 하고, 학년의 범위를 나타내는 C3~C8셀까지를 참조 대상으로 하는 이름을 만드는 것이죠. 반복하여 이름 만들기이제 같은 방법으로, A2, B2, D2, E2, A11~N11 셀을 이름으로 반복하여 새 이름을 만듭니다. ※ 이름 만들기 할 때 고려할 점예를 들어 6학년의 경우 1~4반까지 있지만, 차기 학년도에 학급수가 6개반으로 증가하게 되면 참조 대상을 다시 수정해주어야 하는 불편한 점이 생길 수 있습니다. 그러므로 학급수 같이 유동적인 데이터는 참조 대상을 여유있게 지정해두는 것이 좋습니다. 이름 : 학년6_반 참조 대상 : 설정!$H$12:$H$22 (설정!$H$12:$H$15 로 지정하지말고 여유있게 지정하는 것을 추천) 적용실제 적용될 부분을 만듭니다. 여기서는 J4~L6 부분이 되겠네요. 데이터 유효성 검사학교급 J4셀 : 학교급이라는 제목을 쓰고 J5셀 : 데이터&gt; 데이터 유효성 검사를 클릭한 뒤 제한 대상 : 목록 원본 : 국제,유치,초등,중등,고등 J6셀 : =”학교급_”&amp;$J$5 (J5셀이 초등으로 선택이 되면, 학교급_초등 으로 바꿔주는 수식입니다.) 학년 K4셀 : 학년이라는 제목을 쓰고 K5셀 : 데이터&gt; 데이터 유효성 검사를 클릭한 뒤 제한 대상 : 목록 원본 : =INDIRECT($J$6) - J5셀이 **초등**으로 선택되면 J6셀이 **학교급_초등**으로 바뀌는데, J6셀을 목록 원본으로 지정하므로 이름 지정시 **학교급_초등**의 참조범위인 C3~C8 부분을 목록으로 불러옵니다. 그러므로, 아래와 같은 형태로 목록이 뜨게 됩니다. K6셀 : =”학교급_”&amp;$K$5 (K5셀이 6으로 선택이 되면, 학년6_반 으로 바꿔주는 수식입니다.) 반 L4셀 : 반이라는 제목을 쓰고 L5셀 : 데이터&gt; 데이터 유효성 검사를 클릭한 뒤 제한 대상 : 목록 원본 : =INDIRECT($K$6) K5셀이 6으로 선택되면 K6셀이 학년6_반으로 바뀌는데, K6셀을 목록 원본으로 지정하므로 이름 지정시 학년_반의 참조범위인 H12~H22 부분을 목록으로 불러옵니다. 그러므로, 아래와 같은 형태로 목록이 뜨게 됩니다. (선택사항) L6셀 : =K6&amp;L5 (K6셀이 6, L5셀이 1로 선택이 되면, 학년6_반1 과 같이 바꿔주는 수식입니다.) 예시파일 첨부 데이터유효성검사 동적범위설정.xls","link":"/2019/11/01/%EC%97%91%EC%85%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9C%A0%ED%9A%A8%EC%84%B1%EA%B2%80%EC%82%AC-%EB%8F%99%EC%A0%81%EB%B2%94%EC%9C%84%EC%84%A4%EC%A0%95/"},{"title":"엑셀, 빈셀 채우기","text":"아래와 같이 학년, 반, 번호를 채워 넣으려고 할 때, A3~A31셀이 빈 셀로 되어 있네요. 이럴때 모든 셀을 1학년을 나타내는 숫자 1을 채워 넣으려면 어떻게 해야 할까요? A2셀을 클릭하고 A31셀까지 아래쪽으로 쭉 드래그를 하면 되겠죠? 그런데, 문제는 ‘반’의 숫자를 넣을 B열입니다. 1~3반까지의 숫자가 나뉘어 있으므로 드래그를 세번 나누어서 해야 하는 것이죠. 세개의 반만 있으면 다행이지만, 학급수가 많다면 이것도 쉬운일이 아닙니다. 이럴때, 한번의 작업으로 빈셀을 채우는 방법을 알아보겠습니다. 먼저 A2~B31까지 블럭을 설정합니다. 이 상태에서 F5키를 누르고, 옵션을 클릭합니다. 빈셀을 선택하고 확인을 클릭하면 블럭으로 잡았던 부분이 빈셀로 바뀝니다. 이 상태에서 ‘=‘ 을 누른 뒤 키보드의 위화살표 키 (↑)를 눌러, 빈셀의 바로 위 셀을 가리키게 한 뒤 곧바로 Ctrl-Enter를 누르면, 빈 셀이 모두 채워지게 됩니다. ※ 주의 할 점 빈 셀이 채워질 때, 수식의 형태로 채워집니다. 그러므로 행 삭제 등의 작업이 필요한 경우에는 다시 A2~B31 셀까지 블럭으로 설정한 뒤, Ctrl-C로 복사하고 텍스트로 붙여넣기를 해두는 것이 좋을 수도 있습니다.","link":"/2016/11/01/%EC%97%91%EC%85%80-%EB%B9%88%EC%85%80-%EC%B1%84%EC%9A%B0%EA%B8%B0/"},{"title":"엑셀, 사진으로 vlookup 효과 구현하기","text":"엑셀의 vlookup 함수는 사진파일을 데이터형으로 다룰 수 없어요. 여기서는 사전에 준비된 사진파일(.jpg, .gif, .png, .bmp 등)을 보다 쉽게 엑셀파일에 삽입하고, 삽입된 사진을 몇가지 함수를 조합하여 vlookup 효과를 구현하는 방법을 알아보도록 하겠습니다. 예시담임 선생님이라면 매 학년초마다 연락처 등을 포함한 학생인적사항 관련 조사를 하게 됩니다. 일반적인 경우라면 관련 부서에서 한글워드프로세서나 엑셀, 한셀 등으로 양식을 만들어서 보내주고 그것을 이용하여 작업을 하는데, 사실 여러 부서에서 중복된 데이터를 다양한 형태의 폼으로 원하기 때문에 그때마다 재입력해야하는 엄청난 비효율을 매년마다 경험하게 되요. 그렇기 때문에 조금 어렵고 귀찮기는 하지만 한글워드프로세서보다는 엑셀, 한셀 등의 스프레드시트를 통해 관리하는 것을 강력히 추천합니다. 엑셀로 RAW데이터를 만들어두면, 이 데이터를 활용하여 한글워드프로세서의 메일머지를 이용하기도 쉽고 엑셀이나 한셀을 사용하여 통계를 내기도 쉬워지기 때문이죠. 이렇게 RAW데이터를 엑셀로 만들어두었다고 치고, 이를 활용하여 학적부를 만들어보겠습니다. 특정 데이터의 형태가 학생에 따라 반복되어 출력되는 형태이기때문에, 메인이 되는 한 페이지를 만들고, 원하는 학생을 선택하여 vlookup 함수를 써서 RAW데이터시트의 데이터를 메인페이지로 불러와 학생에 따른 데이터를 띄우는 방법이 가장 좋겠지만… 여기서는 학급 시트를 만들고, 해당 학급의 모든 학생의 학적부가 동일 시트에 연속적으로 이어져 나오는 형태를 만들어 보려고 합니다. 좋은 방법이 아닌것 같은데 왜 이렇게 하냐고요? 왜냐하면 현장에서는 실제로 이런 방법을 더 좋아하는 분들이 많기 때문이죠. 20~30여명 정도만 관리하면 되는 담임선생님 입장에서는 보다 직관적이고 명확하기 때문입니다. (※조금 어렵네? 혹은 복잡하네? 왜 이런것을 하지? 라고 느끼는 사람이 한 명이라도 있다면, 현장에서 적용하기는 어렵다는 점을 고려하세요. 쉽게 이용할 수 있도록 어느 정도의 배려를 해주어야 모두 함께 이용할 수 있습니다.) 어쨋든, 이 과정에서 가장 어려운 부분이 사진을 넣는 것입니다. 다른 데이터는 RAW데이터가 있는 시트에서 vlookup 함수를 사용하여 불러오면 되지만 서두에서 이야기한대로 사진의 경우는 vlookup으로 호출할 수 없기 때문입니다. 예를 들어 아래와 같이 학적부 형태를 만들고 ①, ②이라고 쓰여있는 곳에 1번 학생과 2번학생의 사진을 자동으로 불러오도록 하는 것이 vlookup으로 불가능하다는 것이죠. 여기에는 ②까지 표시되어 있지만 실제 한 학급에 20여명의 학생이 있으므로 하나의 시트에 20여개의 사진이 번호에 맞는 위치에 정확하게 배치를 해야하는데, vlookup이 안된다니 왜 엑셀을 이따구로 만들었는지 모르겠네요. ^^; 그렇다고 사진을 하나씩 수동으로 넣는 것도 쉬운 일은 아닙니다. 물론 20여명의 학생만 있다면 약간의 시간과 노동력 투자를 통해 가능은 하겠지요. 하지만 한번 해보시면 바로 느끼게 될 것입니다. 해당 셀의 사이즈에 맞도록 사진 크기를 수동으로 조절해가면서 사진을 하나씩 하나씩 넣는 것이 엄청 귀찮은 일이라는 것을… 그러므로 여기서는 사진입력을 손쉽게 하는 방법을 포함하여 사진으로 vlookup과 같은 기능을 구현하는 방법을 알아보겠습니다. (‘’사진(1학년)’’ 시트를 만들어) VBA코드 삽입하기 1) ‘’개발 도구’’ 메뉴 활성화VBA코드를 넣기 위해서는 개발 도구라는 메뉴 내의 Visual Basic를 활성화시켜야 하는데요. 위 그림과 같이 개발 도구 메뉴가 보이지 않는 경우라면 아래의 방법대로 메뉴를 활성화 시켜주어야 합니다. 파일&gt; 옵션&gt; 리본 사용자 지정 오른쪽에 있는 리본 메뉴 사용자 지정의 개발도구에 체크 합니다. 2) 사진을 모아두기 위한 시트 생성학생 사진이 들어갈 시트를 만듭니다. 예를들어 **사진(1학년)**이라는 시트를 만듭니다. 예시로 만든 시트의 형태는 다음과 같습니다. 이때 사진이 들어갈 셀의 크기를 실제 사진이 사용될 크기대로 조절합니다. (행과 열 블럭을 잡아 각각 한번에 조절해야 모든 셀의 크기가 같아집니다.) 그리고 사진이 들어갈 부분만 셀 색상을 지정합니다. (아무 색상이나 가능. 단, 흰색은 색깔이 없는 셀과 구별이 되지 않으므로 추천하지 않아요.) 3) VBA코드 붙여넣기이제 ‘’개발 도구’’의 ‘’Visual Basic’’ 메뉴를 열고 **사진(1학년)**시트에 해당하는 부분(아래 예시 그림에서 Sheet3 부분)을 더블클릭한 뒤 아래의 VBA코드를 붙여넣고 저장합니다. 알면 좋겠지만, 코드의 의미를 전혀 모른다고 해도 상관없습니다. 그냥 복사하여 붙여넣기만 하면 돼요. basic12345678910111213141516171819202122232425262728293031Private Sub Worksheet_SelectionChange(ByVal Target As Range)Dim strResult As StringDim fd As FileDialogIf Target.Interior.ColorIndex &lt;&gt; -4142 ThenOn Error GoTo n:Set fd = Application.FileDialog(msoFileDialogFilePicker)extImages = &quot;&quot;*.gif; *.jpg; *.jpeg; *.bmp, *.png&quot;&quot;With fd.Filters.Clear.Filters.Add &quot;&quot;Images&quot;&quot;, extImages, 1.AllowMultiSelect = False.ShowstrResult = .SelectedItems(1)End WithActiveSheet.Shapes.AddPicture(strResult, False, True, 0, 0, 0, 0).SelectWith Selection.ShapeRange.LockAspectRatio = msoFalse.Top = Target.Top.Left = Target.Left.Width = Target.Width.Height = Target.Height.Placement = xlMoveAndSizeEnd WithEnd Ifn:End Sub (‘’사진(1학년)’’ 시트에) 사진 파일 등록 사진 파일 만들기사진 파일은 *.gif; *.jpg; *.jpeg; *.bmp, *.png 형식으로 등록할 수 있습니다. 사진을 넣을 셀의 크기를 고려하여 적당한 비율의 사진파일을 미리 만들어 둡니다. 사진 파일 등록사진이 준비가 되었으면 셀색상을 입힌 부분을 마우스로 클릭하면 사진 파일을 선택하는 창이 나오는데, 이때 해당 학생의 사진을 선택하면 사진이 등록됩니다. 이때 사진의 크기는 자동으로 조절되어 셀의 크기에 딱 맞게 등록이 되고, 실제 사용할 학적부 페이지에도 이 부분에서 지정한 셀의 크기대로 삽입이 되기때문에, 셀의 크기를 조절하여 만들 때 가능한 최선을 다해(?) 잘 만들어두는 것이 중요해요. (선택사항) dummy 사진 파일 등록(꼭 해야하는 것은 아니지만 경험상…) 사진이 없는 학생을 위해 사용할 더미 사진을 추가로 등록해두는 것이 좋습니다. 사진 등록하는 곳 맨끝번호에(예를들어 반 학생이 19명이라면 20번에) 아무 사진이나 똑같은 크기로 준비하여 등록을 해주세요. 예를 들면 이런거죠. (‘’사진(1학년)’’ 시트에서) 이름 정의하기사진을 등록했던 시트를 다시 봅니다. 사실 이 시트에는 A열이 숨겨져 있었습니다. B~E열까지의 내용을 모두 합쳐서 만든 학적번호라는 제목을 가진 열입니다. 이것이 왜 필요하냐하면…vlookup과 같은 효과로 사진을 찾기 위해서는 특정 자료를 매칭시켜야 하기 떄문이죠. 여기서는 학적번호 열을 통해 매칭을 시키는 것으로 가정합니다. ‘’학적번호 열’’에 대한 이름 지정이제 수식&gt; 이름 정의를 클릭합니다. 아래와 같이 새 이름을 등록할 수 있는 창이 뜨면 이름과 참조 대상을 위와 같이 지정합니다. 이름 : 학적번호1학년1반 참조대상 : =’사진(1학년)’!$A$2:$A$21 A2에서 A21셀까지 참조 대상이 지정되어 있으므로 더미 포함 총 20개의 사진이 등록되어 있다는 뜻이겠네요. 만약에 인원이 더 많다면 그에 맞게 숫자를 조절하면 됩니다. ※ 학기중 전입생이 올 수 있기 때문에 조금 여유있게 지정을 해두는 것이 좋습니다. 즉, 현재 학급의 학생이 19번까지 있다고해서 더미를 포함하여 딱 20개의 사진만 등록할 수 있게 만들면 나중에 힘들어 질수도 있어요. 여유있게 30~40개의 사진을 등록할 수 있게 참조대상을 지정하세요. 예를들어 참조대상을 =’사진(1학년)’!$A$2:$A$41 이렇게 지정해 두는 것을 추천합니다. ‘’사진 열’’에 대한 이름 지정이번에는 사진 열에 대한 이름을 지정하기 위해 다시 수식&gt; 이름 정의를 클릭합니다. 이전과 같이 새 이름을 등록할 수 있는 창이 뜨면, 이름 : 사진1학년1반 참조대상 : =’사진(1학년)’!$G$2:$G$21 (이것도 마찬가지로 여유있게 지정해 두는 것을 추천합니다.) (선택사항) (‘’학적부(1학년) 시트에서’’) 매칭 조건으로 사용될 셀의 데이터 유효성 검사 데이터 유효성 검사매칭 **조건으로 사용될 셀(혹은 셀 전체)**에 대하여 데이터 유효성 검사를 합니다. 그런데 위에서 매칭시킬 조건으로 학적번호를 사용하기로 하고 이름을 지정하였으니 이것을 이용하는 것입니다. 먼저 실제 사진이 위치할 시트인 학적부(1학년) 시트를 보면, **조건으로 사용될 셀(혹은 셀 전체)**이 A2, A32, A62 …. 이고 20명의 학생을 등록한다면 A572 까지 입니다. 이 셀들을 블록설정한 뒤에 데이터&gt; 데이터 유효성 검사 메뉴를 이용하여 검사조건을 설정하는 것입니다. (※ A2, A32 등의 셀에는 학적번호 내용을 써야 합니다. 예를들어 A2셀은 초등 1학년 1반의 1번 학생에 대한 학적번호가 들어가야 하므로, 초등1학년1반1이라는 내용이 들어가야 하는 것이지요) 제한 대상 : 목록 원본 : 학적번호1학년1반 (‘학적번호 열’에 대한 이름 지정 과정에서 만들었던 이름을 사용) (‘’사진(1학년)’’ 시트에서) 개별 학생 사진에 대한 이름 정의하기※ 이 과정은 반드시 사진(1학년) 시트에서 진행해야 하는 것은 아니며, 사진이 입력되지 않은 상태에서 진행해도 됩니다. 개별 학생 사진에 대한 이름 정의하기이제 학생 개인별 사진 하나하나에 대한 이름을 정의하겠습니다. 수식&gt; 이름 관리자 메뉴를 클릭하면 이름 관리자 창이 나타나는데 여기서 새로 만들기를 선택합니다. 이름 : 사진1학년1반1번 참조대상 : =INDEX(사진1학년1반,MATCH(‘’학적부(1학년)’’!$A$2,학적번호1학년1반,0)) 참조대상의 INDEX 수식에 들어간 내용의 의미는 다음과 같습니다. 학적번호1학년1반 : 학적번호 열’’에 대한 이름 지정 과정에서 만들었던 이름을 사용 사진1학년1반 : 사진 열’’에 대한 이름 지정 과정에서 만들었던 이름을 사용 학적부(1학년)!$A$2 : 현재 지정하고 있는 개별 학생 사진의 이름이 사진1학년1반1번이므로, 사진이 입력될 시트인 학적부(1학년) 시트의 A2셀에 있는 매칭 조건과 같으면 이 사진을 연결하라는 의미 (학적부(1학년) 시트에) 더미 사진 붙여넣고 수식으로 연결하기이제 학적부(1학년) 시트의 사진이 들어갈 셀에 사진(1학년) 시트에 입력한 사진 중 더미 사진을 붙여넣습니다. (원래는 더미 사진이 아니라 아무 학생의 사진을 붙여넣어도 관계없지만, 혼동이 될 수 있으므로 더미 사진을 넣는 것을 추천합니다.) 더미 사진 복사아래와 같은 상태에서 학생이 19명이 있고 20번째에 더미 사진을 붙여넣은 상태라고 가정하면, 더미 사진이 G21셀에 위치해 있겠죠? 이 사진을 선택한 후 Ctrl-C을 눌러 복사합니다. 더미 사진 붙여넣기학적부(1학년) 시트에서 실제 사진이 들어갈 부분이 1번 학생의 경우 N3~Q8셀까지 병합이 되어 있는데요. 여기서 N3셀에 커서를 두고 Ctrl-V로 붙여넣기하면 더미 사진이 들어가게 됩니다. ※ 이미지를 붙여넣어 정의된 이름과 연결하면 불필요한 여백이 생기면서, 이미지의 크기가 원래 크기보다 작아지게 되므로, 사전에 자르기 기능을 통해서 필요없는 부분을 삭제해주어야 합니다. (붙여넣은 사진이 문제가 없다면 신경쓰지 않아도 됨.) 수식 입력하여 연결하기더미 사진을 붙여넣은 후, 붙여넣은 사진을 클릭한 상태에서 수식입력창에 “=사진1학년1반1번” 이라고 입력한 뒤 엔터를 누릅니다. 개별 사진 이름 정의 반복하기1번 학생에 대한 과정이 모두 완료되었으므로, 2번 이후의 학생에 대하여 동일한 과정을 반복합니다. 더미사진 붙여넣기 수식 입력하여 연결하기 ※ 단, 메인이 되는 한 개의 페이지만 만드는 경우라면 개별 사진에 대한 이름 정의를 반복하지 않아도 됩니다. 사진 매칭 확인하기전체 과정이 마무리 되었으므로, 사진(1학년) 시트에 사진을 입력하였을 때, 학적부에 각 학생의 사진이 바뀌어 나타나는지 확인합니다. 간단한 설명 및 예시 파일위 전체 과정에 대한 설명이 좀 복잡하므로, 간단한 설명과 그에 따른 예시 파일을 덧붙입니다. 사진조회.xlsx","link":"/2018/01/05/%EC%97%91%EC%85%80-%EC%82%AC%EC%A7%84%EC%9C%BC%EB%A1%9C-vlookup-%ED%9A%A8%EA%B3%BC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"},{"title":"역삼투압 정수기 DIY","text":"몸에 좋은 미네랄까지 걸러낸다고 하여 역삼투압정수기를 싫어하시는 분도 많지요? 그러나 여기는 중국입니다. 미네랄이고 뭐고, 그냥 거를 수 있는 것은 다 걸러내는 것이 좋습니다. 역삼투압정수기의 경우 2)번이 정석입니다. 그런데, 폐수가 너무 많이 버려지기때문에, 1)번과 같이 작업하는 분도 계시죠. 정수 성능은 조금 떨어지겠지만 폐수가 전혀 없기도 합니다. 그렇지만 역삼투압정수기의 원리에 맞추어 생각해보면, 1)번 구성은 가장 비싼 RO필터 성능을 급격히 저하시키는 원인이 될 수 있습니다. 1)번과 같이 설치하는 것보다는 2)번 구성대로 하고, 대신 폐수라인을 적절히 빼내어 설거지 용도로 사용하는 것이 좋습니다. 솔레노이드밸브와 모터펌프, 압력센서스위치는 24V 아답터와 아래와 같이 결선하면 됩니다. (※솔레노이드밸브와 압력센서스위치는 극성이 없으나, 모터펌프는 극성을 맞추어 연결!) 부품 구입필요한 부품은 모두 타오바오에서 구입할 수 있었는데, 부품의 간체표기법을 몰라 검색어에 이것저것 넣어가며 이름을 알아가면서 검색하느라 조금 고생을 했습니다. ㅋㅋ 수도아답터(원수밸브)(4分金属进水三通+2分球阀) 1개 : 13원 (※수도 원수 밸브 규격 : 4分=1/2인치) 원터치 T피팅(1/4인치)(2分管+2分管+2分管T型三通快接) 2개 : 개당 1.5원 원터치 L피팅(1/4인치)(2分管+2分管弯头快接) 11개 : 개당 1.2원 솔레노이드밸브(快接式 2分管 进水电磁阀 24V) 1개 : 9원 모터펌프(50G邓元增压泵 TYP-2500) 1개 : 63원 펌프용피팅(3分外牙+2分管接头) 2개 : 개당 4원 테프론테이프(生料带) : 1.5원 폐수저항(废水比) 1개 : 5원 체크밸브(2头插2分管 一字型快接逆止阀) 2개 : 개당 4원 볼밸브(2分球阀快接) 1개 : 5원 피팅마개(1/4인치)(2分堵头) 1개 : 0.4원 압력탱크 3.2갤런(压力桶储水桶)+압력밸브(压力桶球阀) 1개 : 42.5원 압력센서스위치(快接式高压开关) 1개 : 9.5원 압력센서스위치 접속단자(插线) 1개 : 2원 조리수밸브(直颈龙头, 304, 3M유사품) 1개 : 31원 조리수밸브 구멍마개 1개(이사갈때 구멍마개용) 1개 : 10원 아답터(DC24V 2A)(水泵电源) 1개 : 5원 정수기용 호스 PE관(2分PE管水管) 10미터 : 미터당 0.52원 호스커터기(切管刀) : 7원 필터는 한국식접속필터(韩式快接滤芯)형으로 2년 교체분량 구매 세디멘트(3개월-6개) : 熔喷PP棉滤芯(분홍색) : 개당 12원 프리카본(3개월-6개) : CTO压缩活性碳滤芯(남색) : 개당 12원 RO(24개월-1개) : RO反渗透膜滤芯(파랑) : 개당 110원 포스트카본(6개월-4개) : 后置载银颗粒活性碳滤芯(보라) : 개당 15원 코코넛입상활성탄(6개월-4개) : UDF颗粒活性碳滤芯(초록) (TCR대용) : 개당 13원 정수기 케이스(RO纯水机外壳 5级) 1개 : 68원 (아래 사진과 같이) 필터 5개와 모터펌프가 함께 수납가능한 크기의 케이스를 선택 필터 고정대(净水器 5连 大单夹) 2개 : 개당 1.8원 그밖에 십자드라이버, 니퍼, 절연테이프 등의 간단한 공구와 전기재료 조리수밸브 구멍이 없는 경우 드릴과 14mm 드릴비트가 필요 설치 상황에서 어떻게 될지 몰라서 피팅류는 여유분을 더 구매 DIY 소요비용필터(2년교환분량) 366위안 + 부품 308위안 = 674위안, 한국돈으로 115,000원 정도입니다. DIY시 주의사항정수기 DIY의 실제 과정은 매우 간단하여, 필터의 양쪽 끝단에 L피팅을 붙이고 구상도대로 호스를 잘라 연결만 하면 되는데요. 연결시 몇가지 주의할 점은, 필터는 되도록 입수구가 아래쪽, 출수구가 위쪽을 향하도록 조립하는 것이 좋고, 필터를 케이스에 끼우기전에 반드시 후레싱(필터에 물을 2~3L정도 통과시키는 과정)을 거쳐야 합니다. 체크밸브, 솔레노이드밸브, 모터펌프와 필터류는 물의 흐름방향을 잘 보고 조립하세요. 배선 연결시 솔레노이드밸브와 압력센서스위치는 (+)(-)극성이 없지만, 모터펌프는 극성을 지켜야 합니다. DIY 결과완성후 아답터를 콘센트에 꼽고 조리수밸브를 열어보니 모터가 돌아가면서 물이 졸졸졸 나오는 것이 RO정수기 답네요. 처음에는 조리수밸브를 닫고 압력탱크에 물이 꽉찰때까지 기다려야 합니다. 이후에 조리수밸브를 열면 기성품 못지않게 잘 나오게 되죠. 압력탱크 용량이 웅진에서 쓰는 것보다 더 큰 3.2갤런(약 12.1리터)이어서 한번에 더 많은 양을 쓸 수도 있습니다. 며칠동안 테스트를 하였는데, 초반에 침전물같은 것이 눈에 보이지만, 작은 공기기포이므로 걱정할 필요가 없습니다. 이틀정도 지나고 나면 기포도 발생하지 않습니다. 다만 모터펌프와 연결된 호스가 진동에 의해 덜덜거리며 떨리는 소음이 조금 거슬리긴 합니다. 문제없이 잘 작동되는 것이 확인되면 케이블타이로 고정하여 진동을 제거해주세요. (참고) 필터 후레싱 방법 역삼투압 필터 (원자재 공급사에 따라 후레싱방법이 다름) 미국 필림테크 다우케미칼 제품 : 보존액이 전혀 없는 건식이므로 후레싱 생략가능. 단, 후레싱을 하고자 할 경우에는 배출수쪽을 막지 않고 물을 2리터정도 흘려보냄. 웅진케미칼(옛 삼성제일합섬) 공급 CSM역삼투압 멤브레인 : 1차로 배출수쪽을 막지 않고 물을 2리터정도 흘려보낸 뒤, 2차로 배출수쪽을 막고서 정수쪽으로 약간만 흘러보내면 됨 나머지 필터의 경우 2리터정도 흘려보내면 됨. &nbsp;","link":"/2012/10/20/%EC%97%AD%EC%82%BC%ED%88%AC%EC%95%95-%EC%A0%95%EC%88%98%EA%B8%B0-DIY/"},{"title":"연수기 DIY","text":"연수기의 원리연수기는 Ca2+, Mg2+, Fe2+ 같은 양이온을 포함한 센물을, (이러한 양이온을 제거한 형태의) 단물로 만들어주는 장치입니다. 이렇게 만들어 주는 방법은 크게 두가지인데, 하나는 전기적인 방법이고, 다른 하나는 센물에 포함되어 있는 양이온을 다른 형태의 양이온으로 치환시켜주는 방법입니다. 전자는 전기연결이 필요하므로, 보통 집에서 사용하는 연수기는 후자의 방법을 사용하지요. 이를 위해 기본적으로 양이온교환수지를 사용합니다. 양이온 교환수지는 보통 날치알 같은 작은 알갱이 형태로 되어 있는데, 이 알갱이에 수많은 Na+이 붙어 있다고 생각하면 되요. 이 상태에서 센물(수돗물)이 들어오면, 센물의 Ca2+, Mg2+, Fe2+ 등의 이온이 Na+가 붙어 있던 자리에 대신 들어가게 되고, 대신 Na+가 수도물에 포함되어 나오게 되는데, 이렇게 되면 물 속에 Ca2+, Mg2+, Fe2+ 등의 성분이 사라지게 되어, 연수(단물)가 나오게 되는 것입니다. 말로 표현하자니 엄청 복잡한데요. 그러나, 고등학교 화학시간에도 이러한 원리를 이미 배웠다는 사실…교과서에 나와있는 그림으로 표현하면 아래와 같아요. 그러므로, 연수기는 양이온 교환수지가 기본이되며, 여기에 세디멘트필터나 KDF필터 등을 덧붙이면 보다 성능 좋은 연수기를 만들 수 있는 것입니다. 양이온 교환수지 재생의 원리또 하나! 위의 그림에서 보면 양이온 교환수지에 붙어 있는 Na+가, Ca2+나 Mg2+로 바뀌고 있는데요. 이러한 과정이 반복되어 Na+가 Ca2+나 Mg2+로 모두 바뀌게 되면, 더이상 연수기의 역할을 하지 못하게 되겠죠. 바로 이때가 양이온교환수지를 재생해주어야 하는 시점입니다. 눈으로는 볼 수는 없기 때문에 대략 1~2달정도 뒤에 재생하면 됩니다. 재생하는 원리는 연수기 원리와 반대로, 양이온 교환수지에 붙어있는 Ca2+, Mg2+ 등의 이온을 Na+로 바꿔주면 됩니다. 이를 위해 Na+가 다량 포함된 소금물에 담궈두는 것이에요. 이제 연수기를 만들어 보겠습니다. 이런 재료들은 중국이 매우 저렴해요. 똑같은 부품을 한국에서 사려면 거의 두 배이상 비용이 소요됩니다. 연수기 DIY에 필요한 부품 &amp; 필터 부품(중국어) 규격 수량 가격(元) 구입처 투명 하우징(透明 滤瓶) 10寸(33.3cm), 4分(½ inch) 3 23 * 3 타오바오 링크 하우징 연결니플(4分 外牙对接头) M44(½ inch) 4 1.5 * 4 타오바오 링크 하우징 고정브라켓(铁板) 10寸(33.3cm), 3级, 台式 1 18 타오바오 링크 고정브라켓 받침대(台式滤瓶托盘) 10寸专用(孔距 3cm*4cm) 3 3 * 3 타오바오 링크 스텐나사(滤瓶安装 不锈钢 螺丝) 5*16 12 0.25 * 12 타오바오 링크 하우징 오프너(滤瓶 扳手) 10寸(33.3cm) 1 1.5 타오바오 링크 테프론 테이프(生料带) 1 1.4 타오바오 링크 세디멘트침전필터(PP棉滤芯) 10寸(33.3cm) 6 3 * 6 타오바오 링크 KDF,활성탄필터(KDF活性炭滤芯) KDF55 1000g, 활성탄 300g 1 150 타오바오 링크 양이온교환수지(阳离子交换树脂) 양이온교환수지 500g 1 25 타오바오 링크 연수기부품 구입비 : 107.9元 필터 구입비 : 193元 ∴총비용 = 300.9元 (필요시 선택사항) 수전 연결관(波纹进水软管) 4分, 100cm, 304不锈钢 2 9 * 2 타오바오 링크 연결니플(4分 外牙对接头) M44(½ inch) 1 1.5 타오바오 링크 ※ 모두 같은 판매자이므로 장바구니에 수량맞춰 담아 한번에 주문하세요. (단, 선택사항에 있는 수전 연결관은 판매자가 다릅니다.) ※ (필요시 선택사항) 기존에 사용하던 연수기가 있으세요? 사용하던 연수기의 수전 연결호스의 규격이 4分 (½ inch)인 경우에는 수전 연결관을 추가로 구입할 필요가 없습니다. 그러나, 연수기를 처음 설치하는 경우에는 수전(주로 샤워기가 달려있는 부분에서 원수를 연결)과의 거리를 생각하여 연결관과 연결니플을 추가로 구입해야 합니다. 이에 대해서는 아래에서 추가로 설명합니다. 필터 역할 및 교환주기 단계 필터종류 역할 교환주기 1단계 세디멘트(PP) 녹물, 염소 제거 1~2개월 2단계 KDF, 활성탄 중금속, 염소 제거 1년~2년 3단계 양이온 교환수지 Ca2+, Mg2+ 제거 1-2개월 마다 소금물 처리, 1년 뒤 완전 교환 ​ 1) 세디멘트필터를 6개 구입해두면, 2개월에 한 번씩 교환하여 총 1년을 사용할 수 있습니다. ​ 2) KDF필터는 최소 1년~2년간 사용가능 합니다. ​ 3) KDF필터를 1년마다 교체한다고 하면, 1년 유지비가 193원이 되겠죠. ​ 4) 양이온 교환수지는 1개만 구입한 뒤에, 12개월마다 한번씩 집에서 사용하는 굵은 소금으로 재생하면 되므로, 여러 개를 구입할 필요가 없어요. 재생하는 방법은, 1L의 물에 굵은 소금을 400g정도를 넣어 소금물을 만들고, 소금물에 양이온 교환수지 필터를 필터통채로 넣어 담근 뒤, 12시간 후에 꺼내어 재설치하면 됩니다. 소금물로 5회 재생하려면 2000g의 소금(海盐)이 필요한데, 타오바오에서 16원정도 합니다. ​ 5) 물론, 이러한 과정이 귀찮으면 양이온교환수지필터를 추가로 구입하면 됩니다. 1년에 5개씩 추가로 소모한다고 해도 유지비가 125원 추가되는 정도입니다. 어떻게 할지는 잘 생각하셔서… 조립방법하우징 만들기 하우징은 윗쪽 머리부분(흰색으로 된 입출수 구멍이 있는 부분)과 아래쪽 몸통부분(필터를 넣는 곳)으로 나눠집니다. 일단 윗부분과 아래부분을 분리하여 둡니다. 하우징 머리부분에 표기되어 있는 입출수 방향 화살표를 잘 보고, 일정한 방향으로 3열로 배열합니다. 하우징 연결니플 2개를 사용하여 하우징 머리부분 3개를 서로 연결합니다. (주의! 연결니플이 헐겁게 연결되거나, 추후 사용시 연결부분에서 물이 새어나오면, 니플의 나사산을 테프론테이프로 12바퀴 정도 감은 뒤 다시 연결합니다.) 연결된 하우징 머리부분을 바닥에 내려놓고, 하우징의 구멍에 맞추어 하우징 고정브라켓을 올려놓습니다. (구멍이 맞지 않는 경우, 니플 연결 부위를 조절하여 구멍을 맞춥니다.) 하우징 고정브라켓 위에, 고정브라켓 받침대를 구멍에 맞추어 올려놓습니다. 스텐나사를 사용하여 “고정브라켓 받침대+하우징 고정브라켓+하우징 머리부분”을 단단히 고정합니다. 대략 아래 사진과 같은 모양으로 조립하면 됩니다. 남아 있는 2개의 하우징 연결니플을, 연결된 하우징 머리 양쪽 끝에 돌려 끼워넣습니다. 필터 조립하기 조립된 하우징의 입수 부분과 출수 부분을 찾은 뒤에, 뒤집어 바닥에 내려놓습니다. 입수 부분쪽에 **1번필터(세디멘트/PP필터)**를 끼우고, 맨처음 빼두었던 하우징 아래쪽 몸통부분을 돌려 끼웁니다. 그리고, 하우징 오프너를 사용하여 꽉 조입니다. 가운데 부분에 **2번필터(KDF+활성탄필터)**를 끼우고, 동일한 방법으로 몸통부분을 조립합니다. 출수 부분쪽에 **3번필터(양이온교환수지필터)**를 끼우고, 동일한 방법으로 몸통부분을 조립합니다. 수전연결수전연결을 위해서는 연결관이 필요합니다. 아래 그림을 보세요. 위 그림처럼 최소 2개의 연결관이 필요한데요. 수전과 연수기의 거리를 생각하셔서 연결관을 주문하셔야 합니다. 예를 들어서 설명하면, ​ 1) 먼저 연수기를 놓을 위치를 정하세요. ​ 2) 그 후에, 수전과 연수기의 거리를 대략적으로 재어 봅니다. ​ 3) 만약, 연수기와 입수구(or 출수구)의 거리가 1m보다 짧으면 2개의 연결관을 주문하면되고 ​ 4) 만약, 거리가 1m보다 길면 연결관을 추가로 주문하여 연결관의 길이를 연장하여야 합니다. 이때, 연결관과 연결관을 서로 맞붙여 연결하기 위해서는 연결니플이 필요합니다. 사용하는 연결니플의 형태는 하우징 연결니플과 똑같은 것을 주문하면 되므로, 전체 재료를 주문하기 전에 연결니플이 총 몇개가 필요한지 잘 생각하셔서 주문하세요. 모두 연결이 되었으면, 첫 사용시에는 필터후레싱을 해주세요. 그냥 물을 5분정도 틀어 흘려보내는 거에요. 후레싱이 끝났으면 이제 맘 놓고 사용하시면 됩니다. 끄~읕!","link":"/2018/01/31/%EC%97%B0%EC%88%98%EA%B8%B0-DIY/"},{"title":"7 Segment (FND) 사용하기","text":"FND의 종류 FND는 Anode형과 Cathode형으로 분류되며, 이 중 Anode형이 주로 사용되고 있는데요. Anode형은 중앙핀이 VCC이며, Cathode형은 GND입니다. 우리가 사용하는 것은 5611BH로 Common Anode형입니다. 7 Segment (FND)는 숫자나 문자를 표현하는 7개의 LED와 소수점을 표현하는 1개의 LED가 포함되어 있는 부품을 의미합니다. FND는 16X2 LCD와 비교할 때 표현할 수 있는 문자의 개수가 제한되고, 각 문자의 표현을 위하여 총 8개의 LED를 하나씩 조절해주어야 하는 등 사용이 복잡하다는 단점이 있습니다. 그렇지만, 전력소모가 적고 크기가 큰 Segment를 선택하면 비교적 큰 문자도 표현할 수 있다는 장점이 있어 다양한 용도로 사용되고 있습니다. 숫자표시 방법 ![](/image/7segment-02.jpg) Num DP G F E D C B A 2진수 16진수 0 1 1 0 0 0 0 0 0 0b11000000 0xC0 1 1 1 1 1 1 0 0 1 0b11111001 0xF9 2 1 0 1 0 0 1 0 0 0b10100100 0xA4 3 1 0 1 1 0 0 0 0 0b10110000 0xB0 4 1 0 0 1 1 0 0 1 0b10011001 0x99 5 1 0 0 1 0 0 1 0 0b10010010 0x92 6 1 0 0 0 0 0 1 0 0b10000010 0x82 7 1 1 1 1 1 0 0 0 0b11111000 0xF8 8 1 0 0 0 0 0 0 0 0b10000000 0x80 9 1 0 0 1 0 0 0 0 0b10010000 0x90 10진수 숫자와의 구분을 위해 2진수 앞에는 0b, 16진수 앞에는 0x를 표기하고16진수 표현에 있어서, 각 숫자에 소수점을 포함시키는 경우에는 80을 빼주면 됩니다. 예를 들어, 0． → 0xC0 - 0x80 = 0x40 1． → 0xF9 - 0x80 = 0x79 2． → 0xA4 - 0x80 = 0x24 3． → 0xB0 - 0x80 = 0x30 4． → 0x99 - 0x80 = 0x19 5． → 0x92 - 0x80 = 0x12 6． → 0x82 - 0x80 = 0x12 7． → 0xF8 - 0x80 = 0x78 8． → 0x80 - 0x80 = 0x00 9． → 0x90 - 0x80 = 0x10 Pin Map 7 Segment Arduino A 2 B 3 C 4 D 5 E 6 F 7 G 8 DP 9 schematic아래 회로에서는 330Ω 저항 1개를 VCC에 직접 연결하여 사용하였습니다. 상단부와 하단부 중앙핀은 서로 연결이 되어 있으므로, 둘 중 하나만 +5V에 연결하여 사용합니다. 주의 : 위 회로에서는 간단한 회로 구성을 위해 VCC에 저항을 직접 연결하여 사용하였으나, 이것이 좋은 방법은 아닙니다. FND의 각 LED가 직렬이 아닌 병렬로 연결되어 있는데, 이렇게 구성하는 경우 동일한 전류로 “1”를 표시할때는 2개의 Segment만 켜고, “8”을 표시할때는 7개의 Segment를 모두 키므로, 각 숫자마다 밝기의 차이가 생기길 수 있기 때문이죠. 실제 LED의 밝기에 미세한 변화가 생기는 것을 볼 수 있습니다. 이러한 문제를 해결하기 위해서는 각 LED마다 저항을 따로 사용하여야 합니다. 아래 그림과 같이 220~330Ω 저항 8개를 사용하는 것이 원칙이며, 이렇게 하면 밝기를 고르게 유지할 수 있습니다. sketch : 0~9까지 차례대로 표시하기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153const int A = 2;const int B = 3;const int C = 4;const int D = 5;const int E = 6;const int F = 7;const int G = 8;const int DP = 9;int dt = 1000;void setup() {pinMode(A, OUTPUT);pinMode(B, OUTPUT);pinMode(C, OUTPUT);pinMode(D, OUTPUT);pinMode(E, OUTPUT);pinMode(F, OUTPUT);pinMode(G, OUTPUT);pinMode(DP, OUTPUT);// 7 Segment ReadydigitalWrite (A,HIGH);digitalWrite (B,HIGH);digitalWrite (C,HIGH);digitalWrite (D,HIGH);digitalWrite (E,HIGH);digitalWrite (F,HIGH);digitalWrite (G,HIGH);digitalWrite (DP,HIGH);}void loop() {// digit 0digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,LOW);digitalWrite (F,LOW);digitalWrite (G,HIGH);digitalWrite (DP,HIGH);delay(dt);// digit 1digitalWrite (A,HIGH);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,HIGH);digitalWrite (E,HIGH);digitalWrite (F,HIGH);digitalWrite (G,HIGH);digitalWrite (DP,HIGH);delay(dt);// digit 2digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,HIGH);digitalWrite (D,LOW);digitalWrite (E,LOW);digitalWrite (F,HIGH);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 3digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,HIGH);digitalWrite (F,HIGH);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 4digitalWrite (A,HIGH);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,HIGH);digitalWrite (E,HIGH);digitalWrite (F,LOW);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 5digitalWrite (A,LOW);digitalWrite (B,HIGH);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,HIGH);digitalWrite (F,LOW);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 6digitalWrite (A,LOW);digitalWrite (B,HIGH);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,LOW);digitalWrite (F,LOW);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 7digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,HIGH);digitalWrite (E,HIGH);digitalWrite (F,HIGH);digitalWrite (G,HIGH);digitalWrite (DP,HIGH);delay(dt);// digit 8digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,LOW);digitalWrite (F,LOW);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 9digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,HIGH);digitalWrite (F,LOW);digitalWrite (G,LOW);digitalWrite (DP,HIGH);delay(dt);// digit 0.digitalWrite (A,LOW);digitalWrite (B,LOW);digitalWrite (C,LOW);digitalWrite (D,LOW);digitalWrite (E,LOW);digitalWrite (F,LOW);digitalWrite (G,HIGH);digitalWrite (DP,LOW);} sketch : 배열을 사용하여 숫자 출력하기12345678910111213141516171819202122232425262728293031323334353637int numArray[11][8] = { {0,0,0,0,0,0,1,1}, // 0 {1,0,0,1,1,1,1,1}, // 1 {0,0,1,0,0,1,0,1}, // 2 {0,0,0,0,1,1,0,1}, // 3 {1,0,0,1,1,0,0,1}, // 4 {0,1,0,0,1,0,0,1}, // 5 {0,1,0,0,0,0,0,1}, // 6 {0,0,0,1,1,1,1,1}, // 7 {0,0,0,0,0,0,0,1}, // 8 {0,0,0,0,1,0,0,1}, // 9 {0,0,0,0,0,0,1,0} // 0.};int pins[] = {2, 3, 4, 5, 6, 7, 8, 9}; void setup() { for (int r = 0; r &lt; 8; r++) { pinMode(pins[r], OUTPUT); digitalWrite(pins[r], 1); // 7 Segment Ready } // 8 출력 for (int r = 0; r &lt; 8; r++) { digitalWrite(pins[r], numArray[8][r]); // numbers[8][r]이면 8을 출력 } delay(1000);} void loop(){ for (int num = 0; num &lt; 11; num++) { for (int r = 0; r &lt; 8; r++) { digitalWrite(pins[r], numbers[num][r]); // num의 값을 출력 } delay(1000); }} sketch : 2진수나 16진수를 이용하여 표시하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int numArray[10] = { 0b11000000, // 0 0b11111001, // 1 0b10100100, // 2 0b10110000, // 3 0b10011001, // 4 0b10010010, // 5 0b10000010, // 6 0b11111000, // 7 0b10000000, // 8 0b10010000 // 9};// int numArray[10] = { 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90 };// 16진수를 사용해도 됨// 소수점 포함 int numArray[10] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10 };int segPins[7] = {2, 3, 4, 5, 6, 7, 8};int i, j;void setup() { for (i=0; i &lt; 8; i++) { pinMode(segPins[i], OUTPUT); }}void loop() { for (i=0; i &lt; 10; i++) { segLED(i); // i=1이면 1을 출력 delay(1000); }}void segLED(int num) { // num값을 넘겨받아 int data = numArray[num]; // num번째 배열값을 data로 지정 for (j = 0; j &lt; 8; j++) { // 2진수 배열 8비트를 &amp;연산자로 가장 오른쪽11 비트값부터 검사 if(data &amp; 0x01) { // 1이면 digitalWrite(segPins[j], HIGH); // HIGH(끄고) } else { digitalWrite(segPins[j], LOW); // 1이 아니면(0이면) } // LOW(킨다) data &gt;&gt;= 1; // data값을 1비트씩 오른쪽으로 쉬프트한 후 } // 7번 추가 실행 (총 8번 실행)} sketch : 시리얼모니터에서 값을 입력받아 출력하기12345678910111213141516171819202122232425262728293031323334353637383940414243int numArray[10] = { 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90 };// 소수점 포함 int numArray[10] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10 };int segPins[7] = {2, 3, 4, 5, 6, 7, 8};int i, j;void setup() { Serial.begin(9600); for (i=0; i &lt; 8; i++) { pinMode(segPins[i], OUTPUT); }}void loop() { Serial.println(&quot;Press any number!(0~9)&quot;); delay(1000); if (Serial.available()) { int number = Serial.read(); if(number &lt; 10) { Serial.println(number&quot;); segLED(number); // i=1이면 1을 출력 delay(1000); } else { Serial.println(&quot;Please input a lower number than 10!&quot;) } }}void segLED(int num) { // num값을 넘겨받아 int data = numArray[num]; // num번째 배열값을 data로 지정 for (j = 0; j &lt; 8; j++) { // 2진수 배열 8비트를 &amp;연산자로 가장 오른쪽11 비트값부터 검사 if(data &amp; 0x01) { // 1이면 digitalWrite(segPins[j], HIGH); // HIGH(끄고) } else { digitalWrite(segPins[j], LOW); // 1이 아니면(0이면) } // LOW(킨다) data &gt;&gt;= 1; // data값을 1비트씩 오른쪽으로 쉬프트한 후 } // 7번 추가 실행 (총 8번 실행)} 2개의 7 Segment를 사용하여 2자리 숫자 나타내기1개의 7 Segment를 사용하는데 8개의 Digital Pin이 필요하므로, 2개 이상의 7 Segment를 사용하려면 16개의 Digital Pin이 필요합니다. 핀의 개수로만 보면 Arduino Uno로는 표현할 수 없겠지요. 그러므로 2개의 7 Segment를 전원부 제어를 통해 빠른 시간동안 on/off를 반복함으로써 우리 눈에 나타나는 잔상효과를 이용하는 방법으로 여러개의 FND를 사용하는 Dynamic 구동 방식을 사용합니다. 아래 회로를 예로들면 아두이노의 Digital 2~9번핀이 각각 두개의 FND로 병렬연결 되어 있고, 10번핀은 10의 자리를 나타내는 FND1에, 11번 핀은 1의 자리를 나타내는 FND2에 연결되어 있는 것을 볼 수 있습니다. 이 회로를 통해 10번핀을 LOW, 11번핀을 HIGH로 두면 FND1이 작동하고, 마찬가지로 10번핀을 HIGH, 11번핀을 LOW로 두면 FND2가 작동하게 되죠. 이러한 방식으로 2개의 FND를 10개의 핀으로 작동할 수 있게 되는 것입니다. sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int numArray[10] = { 0b01000000, // 0 0b01111001, // 1 0b00100100, // 2 0b00110000, // 3 0b00011001, // 4 0b00010010, // 5 0b00000010, // 6 0b01111000, // 7 0b00000000, // 8 0b00010000 // 9};// int numArray[10] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10 };// 16진수를 사용해도 됨const int segPins[] = { 2, 3, 4, 5, 6, 7, 8, 9 }; // Segment핀 번호const int segNum = 2; // Segment 개수 (숫자 자리수)const int vccPins[segNum] = { 10, 11 }; // 10, 11번 핀을 통해 seg#1, seg#2의 전원 인가void setup() { for (int i = 0; i &lt; 8; i++) { pinMode(segPins[i], OUTPUT); // Segment핀 설정 } for (int i = 0; i &lt; segNum; i++) { pinMode(vccPins[i], OUTPUT); // seg#0, seg#1의 전원인가 핀 설정 }}void loop() { for (int i = 0; i &lt; 100; i++) { // 0~99까지 숫자를 표시 for (int n = 0; n &lt; 10; n++) { // 빠르게 카운트할 경우 모든 LED가 켜져 있는 것처럼 보여 showNumber(i); // 숫자를 구분할 수 없으므로, 빠르게 10번씩 점멸시키면서 표시 } } } void showNumber(int number) { if (number == 0) { showDigit(number, 0); // 0의 경우 (1의 자리수) Segment에만 0을 출력 } else { for (int j = 0; j &lt; segNum; j++) { // 10의 자리, 1의 자리 출력을 위해 2번 실행 if (number &gt; 0) { // 출력값이 0보다 큰 경우에만 실행 showDigit(number % 10, j); // 1의 자리 숫자(%10)를 seg#0(j=0)에 출력 (if 10의 자리 숫자 = (number % 100) / 10)) number = number / 10; // ※ 숫자를 10으로 나눠 10의 자리 숫자를 1의 자리 숫자로 만듦 } // if 처음에 주어진 숫자가 한 자리 수였으면, delay(5); // → 10으로 나눈 후에는 1의 자리값이 0이 되어, 0보다 큰 값이 안되므로 10의 자리 출력하지 않음 } // if 처음에 주어진 숫자가 두 자리 수였으면 } // → 10으로 나눈 후 10의 자리 숫자가 1의 자리 수가 되므로, 10이 자리수를 seg#1(j=1)에 출력 }void showDigit(int num, int digit) { // num값과 digit(0→1의 자리수에 표시, 1→10의 자리수에 표시)을 넘겨받아 int data = numArray[num]; // num번째 배열값을 digit자리수에 표시할 data로 지정 digitalWrite(vccPins[0], HIGH); // vcc핀에 전원 인가 digitalWrite(vccPins[1], HIGH); // [0] = Arduino Pin10, [1] = Arduino Pin11 for (int segLED = 0; segLED &lt; 7; segLED++) // 숫자 2진수의 7세그먼트 ON, OFF { if (data &amp; 0x01) { // 1이면 digitalWrite(segPins[segLED], HIGH); // HIGH(끄고) } else { // 1이 아니면(0이면) digitalWrite(segPins[segLED], LOW); // LOW(끈다) } data &gt;&gt;= 1; // data값을 1비트씩 오른쪽으로 쉬프트한 후 } digitalWrite(vccPins[digit], LOW); // 숫자 LED 한 자리 ON} 4 FND4개의 FND를 Dynamic 방식으로 구동하기 위해서는 8개의 데이터 핀과 4개의 전원부 핀이 필요합니다. schematic Pin Map FND Arduino Segment 자리수 1 6 E 2 5 D 3 13 DP 4 4 C 5 8 G 6 9 S1 1의 자리 수 7 3 B 8 10 S2 10의 자리 수 9 11 S3 100의 자리 수 10 7 F 11 2 A 12 12 S4 1000의 자리 수 sketch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Segment_X - Arduino Pin // FND Pin#define SEG_A 2 // 11#define SEG_B 3 // 7#define SEG_C 4 // 4#define SEG_D 5 // 2#define SEG_E 6 // 1#define SEG_F 7 // 10#define SEG_G 8 // 5// FND_num - Arduino Pin // FND Pin#define FND1 9 // 6#define FND2 10 // 8#define FND3 11 // 9#define FND4 12 // 12void seglight(byte number);byte numbers[] = { B0111111, // MSB -- LSB B0000110, B1011011, B1001111, B1100110, B1101101, B1111101, B0000111, B1111111, B1101111};int FND[] = {SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G };int FND_NO[] = {FND1, FND2, FND3, FND4};void setup() { for (int i = 0 ; i &lt; 7; i++) { pinMode(FND[i], OUTPUT); } for (int i = 0 ; i &lt; 4; i++) { pinMode(FND_NO[i], OUTPUT); digitalWrite(FND_NO[i], HIGH); }}int ON = OUTPUT;int intCnt = 0 ;void loop() { if(intCnt &lt; 10000) { intCnt++; } else { intCnt = 0; } unsigned long start = millis(); for (unsigned long j = 0 ; j &lt; 10 ; j = millis() - start) { // 600 밀리초 마다 실행 // Dynamic 구동 digitalWrite(FND1, LOW); // 1의 자리 켜기 seglight(numbers[intCnt % 10]); delay(5); // 5ms 유지 후 digitalWrite(FND1, HIGH); // 끄기 digitalWrite(FND2, LOW); // 10의 자리 켜기 seglight(numbers[(intCnt / 10) % 10]); delay(5); // 5ms 유지 후 digitalWrite(FND2, HIGH); // 끄기 digitalWrite(FND3, LOW); // 100의 자리 켜기 seglight(numbers[(intCnt / 100) % 10]); delay(5); // 5ms 유지 후 digitalWrite(FND3, HIGH); // 끄기 digitalWrite(FND4, LOW); // 1000의 자리 켜기 seglight(numbers[(intCnt / 1000) % 10]); delay(5); // 5ms 유지 후 digitalWrite(FND4, HIGH); // 끄기 }}// Bit값으로 FND 각 LED 점등void seglight(byte number) { for (int i = 0 ; i &lt; 7 ; i++) { int bit = bitRead(number, i) ; digitalWrite(FND[i], bit); }}","link":"/2018/10/01/7-Segment-FND-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"DC모터 + 4WD 자동차 만들기 (TB6612FNG)","text":"DC모터 사용하기아두이노의 5V, 3.3V핀으로는 모터에 필요한 충분한 전압과 전류를 공급하기 어렵다. 그러므로 사용하려는 모터에 맞는 전압과 전류의 공급을 위한 모터드라이버를 사용해야 한다. 아두이노에서 주로 사용하는 모듈은 L293D, L298N와 TB6612FNG 등이 있으며, 여기서는 TB6612FNG 모터드라이버와 함께, 모터 및 아두이노 단독사용을 위하여 별도의 외부전원을 사용한다. 외부 전원으로는 모터를 위한 1.5V AA*4개와 함께 아두이노 단독사용을 위한 9V 사각전지(6F22)를 추가로 연결하였다. 1.5V AA 6개 혹은 3.7V 18650 2개를 직렬로 연결하여 사용하면, 9V 사각전지(6F22)가 필요하지 않으므로 이 방법을 추천한다. 또한 AA 건전지를 사용하는 경우 4WD기준 연속사용시간은 10분 정도뿐일 정도로 전지 소모가 매우 빠르므로, 충전이 가능한 18650 사용을 추천한다. TB6612FNG VMVCCGND(*)AOUT1AOUT2BOUT2BOUT1GND PWMAAIN2AIN1STBYBIN1BIN2PWMBGND VM (모터 전압) = 15V max VCC (로직 전압) = 2.7 ~ 5.5V GND TB6612fng 모듈을 여러개 테스트한 결과, 3번핀 GND에 연결할 경우 작동이 안되는 몇몇 제품이 있었음 그러므로 8번핀, 9번핀의 GND 사용을 권장함 출력전류: 정전류 1.2A (3.2A peak)까지 (모터 2개 사용시 합산 전류임) 모터 제어모드: CW, CCW, short-brake, STOP, stand-by 두개의 모터 출력을 개별 제어하며, 100kHz의 PWM으로 속도 제어 써멀 셧다운 및 저전압 감지회로 내장 Pin의 사용 핀번호 모터드라이브1 아두이노 외부전원 모터 / 역할 1 VM (+) (DC모터에 사용하는 전압 사용) 2 VCC +5V 3 GND (사용 비추천) 4 A_OUT1 모터A 5 A_OUT2 모터A 6 B_OUT2 모터B 7 B_OUT1 모터B 8 GND (-) 9 GND GND 10 B_PWM 6 모터B 속도제어 11 B_IN2 12 모터B 방향제어 12 B_IN1 11 모터B 방향제어 13 STBY 10 모터 상태신호 14 A_IN1 9 모터A 방향제어 15 A_IN2 8 모터A 방향제어 16 A_PWM 5 모터A 속도제어 속도제어에 사용하는 A_PWM, B_PWM은 아두이노의 PWM이 가능한 핀에 연결하여야 합니다. 여기서는 ~5, ~6번 핀 사용. 주의: Pin Map이 다른 모듈의 경우TB6612FNG를 여러 개 구입하여 사용해본 결과, 위의 핀맵과 조금 다른 모듈도 있었다. 핀번호 모터드라이브1 아두이노 외부전원 모터 / 역할 1 GND GND (-) 2 VCC (2.7~5.5V) +5V 3 A_OUT1 모터A 4 A_OUT2 모터A 5 B_OUT2 모터B 6 B_OUT1 모터B 7 VM (15V max) (+) (DC모터 요구 전압 사용) 8 GND 9 GND 10 B_PWM 6 모터B 속도제어 11 B_IN2 12 모터B 방향제어 12 B_IN1 11 모터B 방향제어 13 NC(STBY) 10 모터 상태신호 14 A_IN1 9 모터A 방향제어 15 A_IN2 8 모터A 방향제어 16 A_PWM 5 모터A 속도제어 TB6612FNG와 DC모터의 연결Pin MapTB6612FNG 모터드라이브는 2채널 형태이며, 만일 2WD 자동차를 만든다면 디지털핀 7개가 필요하다. 4개의 DC모터를 사용하여 4WD 자동차를 만드는 방법은 3가지로 나눠 생각해볼 수 있는데, 모든 바퀴를 각각 컨트롤 하는 방법, 왼쪽 바퀴와 오른쪽 바퀴로 나누어 컨트롤 하는 방법, 앞 바퀴와 뒷 바퀴로 나누어 컨트롤 하는 방법 등이 있다. 모든 바퀴를 각각 컨트롤 하는 경우 : 모터드라이브 2개와 디지털핀 14개 사용 그런데, 아두이노에서 실제 사용할 수 있는 디지털핀의 개수가 12개(2~13번)이므로, 2개의 디지털핀이 부족하다. 아날로그핀을 디지털핀과 동일하게 사용할 수 있으므로, 2개의 아날로그핀을 추가로 사용한다. 또는 스케치 업로드시에만 0,1번 핀을 빼두었다가, 스케치 업로드가 끝나면 0,1번 핀을 사용한다. 이렇게 사용하면 0~13번까지 총 14개의 디지털핀을 확보할 수 있다. 왼쪽과 오른쪽 바퀴로 나누어 컨트롤 하는 방법 : 디지털핀 7개 사용 (아래 본문에서 사용한 방법) 앞과 뒷 바퀴로 나누어 컨트롤 하는 방법 : 디지털핀 7개 사용. (단, 조향을 위한 추가적인 방법을 고려해야 함.) H-SW Control Function Input Output IN1 IN2 PWM STBY OUT1 OUT2 Mode H H H/L H L L Short Brake L H H H L H Count-Clockwise L H L H L L Short Brake H L H H H L Clockwise H L L H L L Short Brake L L H H OFF(High impedance) OFF(High impedance) Stop H/L H/L H/L L OFF(High impedance) OFF(High impedance) Standby 출력 결과는 아래와 같으며, IN1이 LOW, IN2가 HIGH, PWM으로 신호를 출력할 경우 시계 반대 방향(CCW)으로 회전 IN1이 HIGH, IN2가 LOW, PWM으로 신호를 출력할 경우 시계 방향(CW)으로 회전 그 밖의 경우는 모두 stop 상태로 해석하면 된다. 모터 1개 컨트롤하기여기서 사용하는 DC모터는 아래의 형태를 가진 기어드모터이며, 아두이노를 사용하여 자동차를 만드는데 많이 사용되는 저렴이 모터이다. schematicUNO보드와 컴퓨터를 USB선으로 연결하여 사용할 경우 UNO보드와 컴퓨터의 연결없이 Vin핀을 사용하여 단독으로 사용할 경우 UNO 보드의 Vin에 외부전원(7.4V) (+)에 연결: 6.6V~12V 범위의 전원 연결 가능 (7.2V 이상 추천) UNO 보드의 GND를 TB6612fng 모듈의 GND에 연결 sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int STBY = 10; // Standby// Motor Aint A_PWM = 5; // Speed Controlint A_IN1 = 8;int A_IN2 = 9;void setup() { pinMode(STBY, OUTPUT); pinMode(A_PWM, OUTPUT); pinMode(A_IN1, OUTPUT); pinMode(A_IN2, OUTPUT);}void loop() { move(1, 128, 0); // motor A(right wheels), half speed, moving forward delay(1000); // go for 1 second stop(); // stop delay(250); // hold for 250ms until move again move(1, 128, 1); // motor A(right wheels), half speed, moving backward delay(1000); stop(); delay(250);}void move(int motor, int speed, int direction) {/*- Move specific motor at speed and direction- motor: A -&gt; 1- speed: 0 is off, and 255 is full speed= direction: 0 clockwise, 1 counter-clockwise*/ digitalWrite(STBY, HIGH); // Disable Standby boolean inPin1 = LOW; // Defalut(direction=0) - Clockwise boolean inPin2 = HIGH; if(direction == 1) { // Count-clockwise inPin1 = HIGH; inPin2 = LOW; } if(motor == 1){ // if motor == 1, right wheel digitalWrite(A_IN1, inPin1); digitalWrite(A_IN2, inPin2); analogWrite(A_PWM, speed); } else { // if motor is not 1, left wheel }}void stop() { digitalWrite(STBY, LOW); // Enable Standby} 회전 방향이 (생각했던 방향과) 반대로 회전하는 경우A_IN1핀과 A_IN2 핀의 번호를 바꿔준다. 즉, 위 스케치에서 12int A_IN1 = 8;int A_IN2 = 9; 부분을 12int A_IN1 = 9;int A_IN2 = 8; 로 바꿔준다. 4WD 자동차 만들기schematicUNO보드와 컴퓨터를 USB선으로 연결하여 사용할 경우 UNO보드와 컴퓨터의 연결없이 Vin핀을 사용하여 단독으로 사용할 경우 UNO 보드의 Vin에 외부전원(7.4V) (+)에 연결: 6.6V~12V 범위의 전원 연결 가능 (7.2V 이상 추천) UNO 보드의 GND를 TB6612fng 모듈의 GND에 연결 sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// front wheel : B1 - A1// rear wheel : B2 - A2 int STBY = 10; // Standby// Motor A 1 &amp; 2(Right)int A_PWM = 5; // Speed Controlint A_IN1 = 8;int A_IN2 = 9;// Motor B 1 &amp; 2(Left)int B_PWM = 6; // Speed Controlint B_IN1 = 11;int B_IN2 = 12;void setup() { pinMode(STBY, OUTPUT); pinMode(A_PWM, OUTPUT); pinMode(A_IN1, OUTPUT); pinMode(A_IN2, OUTPUT); pinMode(B_PWM, OUTPUT); pinMode(B_IN1, OUTPUT); pinMode(B_IN2, OUTPUT);}void loop() { move(1, 128, 0); // motor A(right wheels), half speed, moving forward move(2, 128, 0); // motor B(left wheels), half speed, moving forward delay(1000); // go for 1 second stop(); // stop delay(250); // hold for 250ms until move again move(1, 128, 1); // motor A(right wheels), half speed, moving backward move(2, 128, 1); // motor B(left wheels), half speed, moving backward delay(1000); stop(); delay(250);}void move(int motor, int speed, int direction) { //Move specific motor at speed and direction//motor: A(Right) -&gt; 1, B(Left) -&gt; 2//speed: 0 is off, and 255 is full speed//direction: 0 clockwise, 1 counter-clockwise digitalWrite(STBY, HIGH); // Disable Standby boolean inPin1 = LOW; // Defalut(direction=0) - Clockwise boolean inPin2 = HIGH; if(direction == 1) { // Count-clockwise inPin1 = HIGH; inPin2 = LOW; } if(motor == 1){ // if motor == 1, right wheel digitalWrite(A_IN1, inPin1); digitalWrite(A_IN2, inPin2); analogWrite(A_PWM, speed); } else { // if motor is not 1, left wheel digitalWrite(B_IN1, inPin1); digitalWrite(B_IN2, inPin2); analogWrite(B_PWM, speed); }}void stop() { digitalWrite(STBY, LOW); // Enable Standby} IR 리모컨으로 4WD 컨트롤하기IR리모컨을 사용하여 RC카를 컨트롤 하기 위해서는 모터와 회로에서 발생하는 노이즈를 제거하기 위한 104 케패시터(0.1uF)를 사용하는 것이 원칙입니다. 반드시 사용해야 하는 것은 아니지만, 회로보호를 위해 캐패시터가 있는 경우에는 IR 수신부의 (+)와 (-)에 병렬연결하세요. 이에 더하여 후진시 방향전환도 가능하도록 수정해 봅니다. schematicUNO보드와 컴퓨터를 USB선으로 연결하여 사용할 경우 UNO보드와 컴퓨터의 연결없이 Vin핀을 사용하여 단독으로 사용할 경우 IRremote 라이브러리 추가하기1234#include &lt;boarddefs.h&gt;#include &lt;IRremote.h&gt;#include &lt;IRremoteInt.h&gt;#include &lt;ir_Lego_PF_BitStreamEncoder.h&gt; 사용할 리모컨 버튼 HEX값 Remote Button unsigned int data define ▲ (전진 / 속도 증가) 0XFF18E7 BTN_U ▼ (후진 / 속도 감소) 0XFFA4B5 BTN_D ◀ (좌회전 / 좌회전각 증가) 0XFF10EF BTN_L ▶ (우회전 / 우회전각 증가) 0XFF5AA5 BTN_R OK (정지) 0XFF38C7 BTN_O 보유하고 있는 리모컨의 종류마다 HEX값이 다르므로, HEX값은 다를 수 있습니다. HEX값을 알아내는 방법은 IR Remote를 다루는 페이지를 참고하세요. sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//Initialize IR remote#include &lt;boarddefs.h&gt;#include &lt;IRremote.h&gt;#include &lt;IRremoteInt.h&gt;#include &lt;ir_Lego_PF_BitStreamEncoder.h&gt;int RECV_PIN = 13; // IR Signal pinIRrecv irrecv(RECV_PIN);decode_results results;#define BTN_F 0xFF18E7 // Forward Button#define BTN_B 0xFF4AB5 // Backward Button#define BTN_L 0xFF10EF // Left Button#define BTN_R 0xFF5AA5 // Right Button#define BTN_O 0xFF38C7 // OK Button// Initialize TB6612FNG Motor driveint STBY = 10; // STBY pin on TB6612FNG. Must be HIGH to enable motorint A_PWM = 5; // Right motor speed control using analogWrite() function. Value between 0 - 255int A_IN1 = 9; // Right motor - LOW should go forwardint A_IN2 = 8; // Right motor - HIGH should go forwardint B_PWM = 6; // Left motor speed control using analogWrite() function. Value between 0 - 255int B_IN1 = 11; // Left motor - LOW should go forwardint B_IN2 = 12; // Left motor - HIGH should go forwardint R_MaxSpeed = 255; //set motor speed to max speedint L_MaxSpeed = 255; //set motor speed to max speedint R_TurnSpeed = 128; //set motor speed to max speedint L_TurnSpeed = 128; //set motor speed to max speedint LR_Direct = 0; //for Directionvoid setup() { pinMode(A_PWM, OUTPUT); pinMode(A_IN1, OUTPUT); pinMode(A_IN2, OUTPUT); pinMode(B_PWM, OUTPUT); pinMode(B_IN1, OUTPUT); pinMode(B_IN2, OUTPUT); pinMode(STBY, OUTPUT); Serial.begin(9600); irrecv.enableIRIn(); // Start the receiver}void loop() { if (irrecv.decode(&amp;results)) { // Read IR remote control //Serial.println(results.value, HEX); // for debug irrecv.resume(); // Receive the next value } switch(results.value) { case BTN_F: go_forward(); break; case BTN_B: go_backward(); break; case BTN_L: if(LR_Direct==0) { go_f_left(); } else if(LR_Direct==1) { go_b_left(); } break; case BTN_R: if(LR_Direct==0) { go_f_right(); } else if(LR_Direct==1) { go_b_right(); } break; case BTN_O: stop(); break; } delay(50);}// Move specific motor at speed and direction// motor: A(Right) -&gt; 0, B(Left) -&gt; 1// speed: 0 is off, and 255 is full speed// direction: 0 clockwise, 1 counter-clockwisevoid move(int motorLR, int speed, boolean inPin1, boolean inPin2) { digitalWrite(STBY, HIGH); // Disable Standby if (motorLR == 0) { analogWrite(A_PWM, speed); digitalWrite(A_IN1, inPin1); digitalWrite(A_IN2, inPin2); } if (motorLR == 1) { analogWrite(B_PWM, speed); digitalWrite(B_IN1, inPin1); digitalWrite(B_IN2, inPin2); }}void go_forward() { Serial.println(&quot;F&quot;); move(0, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) LR_Direct = 0; // Forward delay(100);}void go_backward() { Serial.println(&quot;B&quot;); move(0, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) LR_Direct = 1; // Backward delay(100);}void go_f_left() { Serial.println(&quot;F_L&quot;); move(0, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_TurnSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) delay(100);}void go_b_left() { Serial.println(&quot;F_R&quot;); move(0, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_TurnSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) delay(100);}void go_f_right() { Serial.println(&quot;F_R&quot;); move(0, R_TurnSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) delay(100);}void go_b_right() { Serial.println(&quot;B_R&quot;); move(0, R_TurnSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) delay(100);}void stop() { Serial.println(&quot;STOP&quot;); digitalWrite(STBY, LOW); // Enable Standby} 초음파 센서 장착초음파 센서를 장착하여 전진시 일정한 거리 내에 장애물이 있으면 자동차를 멈춰보도록 하겠습니다. Trig는 아두이노 2번핀, Echo는 4번핀에 연결하였습니다. schematicUNO보드와 컴퓨터를 USB선으로 연결하여 사용할 경우 UNO보드와 컴퓨터의 연결없이 Vin핀을 사용하여 단독으로 사용할 경우 sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174//Initialize IR remote#include &lt;boarddefs.h&gt;#include &lt;IRremote.h&gt;#include &lt;IRremoteInt.h&gt;#include &lt;ir_Lego_PF_BitStreamEncoder.h&gt;int RECV_PIN = 13; // IR Signal pinIRrecv irrecv(RECV_PIN);decode_results results;#define BTN_F 0xFF18E7 // Forward Button#define BTN_B 0xFF4AB5 // Backward Button#define BTN_L 0xFF10EF // Left Button#define BTN_R 0xFF5AA5 // Right Button#define BTN_O 0xFF38C7 // OK Button// Initialize TB6612FNG Motor driveint STBY = 10; // STBY pin on TB6612FNG. Must be HIGH to enable motorint A_PWM = 5; // Right motor speed control using analogWrite() function. Value between 0 - 255int A_IN1 = 9; // Right motor - LOW should go forwardint A_IN2 = 8; // Right motor - HIGH should go forwardint B_PWM = 6; // Left motor speed control using analogWrite() function. Value between 0 - 255int B_IN1 = 11; // Left motor - LOW should go forwardint B_IN2 = 12; // Left motor - HIGH should go forwardint R_MaxSpeed = 255; //set motor speed to max speedint L_MaxSpeed = 255; //set motor speed to max speedint R_TurnSpeed = 128; //set motor speed to max speedint L_TurnSpeed = 128; //set motor speed to max speedint LR_Direct = 0; //for Direction// Initialize Ultrasonic Sensor#define TRIG 2#define ECHO 4void setup() { pinMode(A_PWM, OUTPUT); // Motor pinMode(A_IN1, OUTPUT); pinMode(A_IN2, OUTPUT); pinMode(B_PWM, OUTPUT); pinMode(B_IN1, OUTPUT); pinMode(B_IN2, OUTPUT); pinMode(STBY, OUTPUT); pinMode(TRIG, OUTPUT); // Ultrasonic Sensor pinMode(ECHO, INPUT); Serial.begin(9600); irrecv.enableIRIn(); // Start the receiver}void loop() { digitalWrite(TRIG, LOW); // Start Ultrasonic sensor delayMicroseconds(2); digitalWrite(TRIG, HIGH); delayMicroseconds(10); digitalWrite(TRIG, LOW); long distance = pulseIn(ECHO, HIGH) / 58.2; // 거리 측정 if (irrecv.decode(&amp;results)) { // Read IR remote control //Serial.println(results.value, HEX); // for debug irrecv.resume(); // Receive the next value } if (distance &lt; 10) { // 거리가 10cm 이내이면 정지 stop(); delay(500); } else { // 거리가 10cm 이상이면, switch(results.value) { case BTN_F: go_forward(); break; case BTN_B: go_backward(); break; case BTN_L: if(LR_Direct==0) { go_f_left(); } else if(LR_Direct==1) { go_b_left(); } break; case BTN_R: if(LR_Direct==0) { go_f_right(); } else if(LR_Direct==1) { go_b_right(); } break; case BTN_O: stop(); break; } delay(50);}// Move specific motor at speed and direction// motor: A(Right) -&gt; 0, B(Left) -&gt; 1// speed: 0 is off, and 255 is full speed// direction: 0 clockwise, 1 counter-clockwisevoid move(int motorLR, int speed, boolean inPin1, boolean inPin2) { digitalWrite(STBY, HIGH); // Disable Standby if (motorLR == 0) { analogWrite(A_PWM, speed); digitalWrite(A_IN1, inPin1); digitalWrite(A_IN2, inPin2); } if (motorLR == 1) { analogWrite(B_PWM, speed); digitalWrite(B_IN1, inPin1); digitalWrite(B_IN2, inPin2); }}void go_forward() { Serial.println(&quot;F&quot;); move(0, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) LR_Direct = 0; // Forward delay(100);}void go_backward() { Serial.println(&quot;B&quot;); move(0, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) LR_Direct = 1; // Backward delay(100);}void go_f_left() { Serial.println(&quot;F_L&quot;); move(0, R_MaxSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_TurnSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) delay(100);}void go_b_left() { Serial.println(&quot;F_R&quot;); move(0, R_MaxSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_TurnSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) delay(100);}void go_f_right() { Serial.println(&quot;F_R&quot;); move(0, R_TurnSpeed, 0, 1); // Right motor, Right Speed, forward(0,1) move(1, L_MaxSpeed, 0, 1); // Left motor, Left Speed, forward(0,1) delay(100);}void go_b_right() { Serial.println(&quot;B_R&quot;); move(0, R_TurnSpeed, 1, 0); // Right motor, Right Speed, backward(1,0) move(1, L_MaxSpeed, 1, 0); // Left motor, Left Speed, backward(1,0) delay(100);}void stop() { Serial.println(&quot;STOP&quot;); digitalWrite(STBY, LOW); // Enable Standby}","link":"/2019/10/29/DC%EB%AA%A8%ED%84%B0-4WD-%EC%9E%90%EB%8F%99%EC%B0%A8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"ESP32, nRF24L01 무선통신","text":"nRF24L01library스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; nRF24L01 검색한 후, RF24 by TMRh20, Avamander 설치 schematic: nRF24L01 receiver with ESP32 ※ nRF24L01 모듈에 따라 10uF 캐페시터가 없으면 통신이 안되는 경우가 있음. 이런 경우에만 사용할 것. pinmap: (안테나를 위로 향하게 두고, 모듈을 위에서 내려다 볼때의 핀배열) ESP32 3V3 IO5 IO23 None ↑ ↑ ↑ ↑ nRF24L01 VCC + 10uF CSN MOSI IRQ (위에서 보이는 핀배열) GND + 10uF CE SCK MISO ↓ ↓ ↓ ↓ ESP32 GND IO4 IO18 IO19 sketch: 1:1 Chat Room 양방향 송수신을 위하여 위 회로도를 보고 2개의 모듈을 만든 뒤, 다음 스케치를 업로드한다. 시리얼 모니터를 띄운 뒤, 메세지를 전송해본다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Libraries for NRF24L01+ module.#include &lt;SPI.h&gt;#include &lt;nRF24L01.h&gt;#include &lt;RF24.h&gt; //RF24 object with two pins defined with arguments. CE: 4, CSN: 5RF24 radio(4, 5); //Address of the pipe. 40 bit long, you can choose this freely.//Remember to use different address in different projects.long long address = 0x1234ABCDEFLL;int count = 0;char stext[32] = &quot;&quot;;int spos = 0;char rtext[32] = &quot;&quot;;int rpos = 0;void sendText(char * text, int tlen){ radio.stopListening(); radio.openWritingPipe(address); radio.write(stext, tlen); Serial.print(&quot;SEND: &quot;); Serial.println(text); memset(stext, 0x00, 32); radio.openReadingPipe(0, address); radio.startListening();}void setup() { //Start the radio Serial.begin(115200); radio.begin(); //Open reading pipe with given address and start listening for incoming data radio.openReadingPipe(0, address); radio.setPALevel(RF24_PA_MIN); radio.startListening();} void loop() { while(0 &lt; Serial.available()) { stext[spos] = Serial.read(); if(stext[spos] == 0x0a) { sendText(stext, spos); spos = 0; } else { spos += 1; } } if (radio.available()) { while (radio.available()) { radio.read(rtext, 32); } Serial.print(&quot;RECV: &quot;); Serial.println(rtext); }} sketch: 1:1 Chat Room다음은 처음 실행 후 시리얼모니터에 입력한 ID를 이용하여 Chat Room을 만드는 코드이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Libraries for NRF24L01+ module.#include &lt;SPI.h&gt;#include &lt;nRF24L01.h&gt;#include &lt;RF24.h&gt; //RF24 object with two pins defined with arguments. CE: 4, CSN: 5RF24 radio(4, 5); //Address of the pipe. 40 bit long, you can choose this freely.//Remember to use different address in different projects.long long address = 0x1234ABCDEFLL;String username = &quot;&quot;;String dataInput;char dataToSend[32];char dataReceived[32];void setup() { //Start the radio Serial.begin(115200); delay(2000); Serial.println(&quot;Enter username: &quot;); radio.begin(); radio.setRetries(3, 5); //Open reading pipe with given address and start listening for incoming data radio.openWritingPipe(address); radio.openReadingPipe(0, address); radio.setPALevel(RF24_PA_MIN); }void loop() { //set username while(username == &quot;&quot;) { if(Serial.available()) { username = Serial.readStringUntil('\\n'); Serial.print(&quot;Welcome &quot;); Serial.println(username); } } radio.startListening(); if(radio.available()) { radio.read(&amp;dataReceived, sizeof(dataReceived)); Serial.println(dataReceived); } if(Serial.available()) { radio.stopListening(); dataInput = &quot;[&quot; + username + &quot;] &quot; + Serial.readStringUntil('\\n'); Serial.println(dataInput); dataInput.toCharArray(dataToSend, 32); radio.write(&amp;dataToSend, sizeof(dataToSend)); }} nRF24L01을 이용한 센서값 전송for Receiverschematic sketchlong long address = 0x1234ABCDEFLL; receiver와 transmitter의 페어링을 위한 파이프(주소)를 지정함. (receiver와 transmitter의 파이프(주소)는 동일해야 함) 주변 여러 사람이 동시에 nRF24L01 모듈을 사용할 경우, 서로 다른 고유의 파이프(주소)를 지정하여야 한다. uint16_t temphumi[2]; 8-bit 기반 Arduino와 32-bit 기반 ESP32를 receiver와 transmitter로 혼용하여 사용할 경우, 아래와 같이 int를 사용하여 변수(혹은 배열)를 선언하면 문제가 발생함. 1int temphumi[2]; 8비트 아키텍처에서 int는 16비트이지만, 32비트 아키텍처에서는 32비트로 정의되기 때문이며, 이로 인해 radio.write 또는 radio.read를 할때 일부 데이터가 송신(혹은 수신)되지 않을 수 있다. 그러므로, arduino와 ESP32를 함께 사용할때에는, 아래와 같은 형태로 변수(혹은 배열) 선언시 특정 비트의 변수로 제한하여 선언할 필요가 있다. 1uint16_t temphumi[2]; 단, 송수신기로 Arduino만 사용하거나, 혹은 ESP32만 사용하는 경우에는 int를 사용해도 됨 radio.openReadingPipe(1, address);페어링 파이프(주소)를 오픈 for Transmitterschematic스케치를 업로드하고, 컴퓨터와 연결한 USB선을 분리한 뒤, 독립하여 동작하도록 외부 전원을 연결한다. ※ nRF24L01 모듈에 따라 10uF 캐페시터가 없으면 통신이 안되는 경우가 있음. 이런 경우에만 사용할 것. 18650을 사용하여 5V 외부 전원 만들기 ESP32를 외부전원을 통해 동작시키려면, ESP32의 5V/GND 단자를 사용하여 512V의 전압(최적 전압은 67V)을 공급하여야 한다. 18650 소켓에 F단자를 납땜하여 연결한다. (M단자는 서로 맞닿을 경우 과열 위험이 있으므로 사용금지!) DC-DC 5V 승압 모듈에 아래 그림과 같이 납땜하여 연결한다. (USB단자는 사용하지 않음) ※ USB단자가 있는 5V 승압 모듈을 사용하였지만, USB단자가 없는 승압모듈을 사용하면 더 깔끔하게 제작 가능하다. 위 사진과 같이 납땜한 승압 모듈을 18650배터리와 ESP32에 연결한다. 승압 모듈 ESP32 18650배터리 파란색 원 (GND) GND 빨간색 원 (5V) 5V 노란색 원(IN+) (+)극 초록색 원(IN-) (-)극 (transmitter의 경우, 많은 전류를 사용하지 않으므로) 위 그림처럼 ESP32에 DC컨버터를 사용하여 전원을 공급하는 형태보다는, TTGO T-Energy 사용을 추천함 TTGO T-Energy sketch: DHT22 temperature and humidity Sensorlibrary for DHT11 or DHT22 sensor먼저 온습도 센서 데이터를 보내기 위해 온습도 센서 라이브러리를 설치 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; DHT 검색 먼저 **DHT sensor library (by Adafruit)**를 검색하여 설치를 누르면, Dependencies for library DHT sensor library 창이 나오면 Install all을 클릭하여 2개의 라이브러리를 동시에 설치 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Libraries for NRF24L01+ module.#include &lt;SPI.h&gt;#include &lt;RF24.h&gt; //RF24 object with two pins defined with arguments. CE: 4, CSN: 5RF24 radio(4, 5); //Address of the pipe. 40 bit long, you can choose this freely.//Remember to use different address in different projects.long long address = 0x1234ABCDEFLL;// for temperature, humidity sensor#include &quot;DHT.h&quot;#define DHTPIN 13 // data pin#define DHTTYPE DHT22 // change to DHT11 if you're using the DHT11//float temphumi[2]; // AM2301(DHT21) -&gt; DHT21, AM2302(DHT22) -&gt; DHT22uint16_t temphumi[2];DHT dht(DHTPIN, DHTTYPE);void setup() { //Start the radio Serial.begin(115200); radio.begin(); radio.openWritingPipe(address); //RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX //NRF24L01: -18dBm, -12dBm,-6dBM, and 0dBm radio.setPALevel(RF24_PA_LOW); radio.stopListening(); dht.begin();} void loop() { //Get temperature from the sensor uint16_t t = dht.readTemperature(); uint16_t h = dht.readHumidity(); temphumi[0] = t; temphumi[1] = h; //Send the temperature wirelessly, print error if failed if (!radio.write(&amp;temphumi, sizeof(temphumi))) { Serial.println(F(&quot;Sending temperature failed&quot;)); // Check if any reads failed and exit early (to try again). if (isnan(h) || isnan(t)) { Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; } delay(2000); } } long long address = 0x1234ABCDEFLL; receiver와 transmitter의 페어링을 위한 파이프(주소)를 지정함. (receiver와 transmitter의 파이프(주소)는 동일해야 함) 주변 여러 사람이 동시에 nRF24L01 모듈을 사용할 경우, 서로 다른 고유의 파이프(주소)를 지정하여야 한다. radio.setPALevel(RF24_PA_LOW); RF24_PA_MIN RF24_PA_LOW RF24_PA_HIGH RF24_PA_MAX: 가장 강함 (전류소모도 큼) result nRF24L01 + Dual Joystick2개의 조이스틱을 사용하여 x축, y축 좌표값을 받아보자. for Transmitterschematic: nRF24L01 transmitter with ESP32, Dual Joystick하나의 조이스틱으로도 일반적인 조정이 가능하지만, 시판되는 조정기의 경우 dual joystick(혹은 dual channel)을 사용하는 형태가 많으므로, 여기서도 이와 같은 형태의 transmitter를 만들어 보자. 위 그림에서는 18650을 DC 컨버터를 사용하여 5V핀에 입력하고 있음. (transmitter의 경우, 많은 전류를 사용하지 않으므로) 위 그림처럼 ESP32에 DC컨버터를 사용하여 전원을 공급하는 형태보다는, TTGO T-Energy 사용을 추천함 TTGO T-Energy pinmap ESP32 Joystick1 (x축) Joystick2 (y축) GND GND GND 5V 5V 5V 25 VRX 32 VRY sketch: nRF24L01 transmitter with ESP32, Dual Joystick12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4, 5);long long address = 0x1234ABCDEFLL;// for no interference, two joysticks must be used with each other ADC! // one joystick use ADC1: GPIO 36,39,32,33,34,35// the other must use ADC2: GPIO 4,0,2,15,13,12,14,27,25,26const int Jstick_x_pin = 25; // Left_Right GPIO25const int Jstick_y_pin = 32; // Forward_Back GPIO32struct Value{ uint16_t value_x; uint16_t value_y;};Value data;void setup() { Serial.begin(115200); radio.begin(); radio.openWritingPipe(address); radio.setPALevel(RF24_PA_MIN); radio.stopListening();}void loop() { data.value_x = Jstick(Jstick_x_pin); delay(10); data.value_y = Jstick(Jstick_y_pin); delay(10); radio.write(&amp;data, sizeof(Value)); //Serial.print(&quot;x: &quot;); Serial.print(data.value_x); //Serial.print(&quot;, y: &quot;); Serial.println(data.value_y);}uint16_t Jstick(int Jstick_Pin){ return analogRead(Jstick_Pin);} Joystick GPIO의 선정12345// for no interference, two joysticks must be used with each other ADC! // one joystick use ADC1: GPIO 36,39,32,33,34,35// the other must use ADC2: GPIO 4,0,2,15,13,12,14,27,25,26const int Jstick_x_pin = 25; // Left_Right GPIO25const int Jstick_y_pin = 32; // Forward_Back GPIO32 2개의 joystick을 동시에 사용할때 동일한 ADC의 GPIO를 사용하면, 한쪽 joystick을 움직여 값을 변화시킬 경우 다른 한쪽 joystick을 움직이지 않았음에도 동시에 값이 일부 (소폭) 변화하는 현상이 생긴다. 이 문제를 해결하기 위해 각각의 joystick을 서로 다른 ADC에 연결한다. ADC1: GPIO 36,39,32,33,34,35 중 1개 사용 (예제에서는 GPIO 32를 y축 joystick으로 사용) ADC2: GPIO 4,(0),(2),15,13,(12),14,27,25,26 중 1개 사용 (()안의 핀은 사용시 주의 필요) (예제에서는 GPIO 25를 x축 joystick으로 사용) 단, ESP32의 wifi 기능을 이용하면 ADC1핀 중에서 wifi 기능에 공유되는 핀의 사용에 제한을 받게 되므로 주의가 필요하다. 그밖에도 사용하는 ADC의 noise를 제거하기 위해 다음과 같은 방법을 쓰는 것이 좋다. GPIO와 GND에 100nF 케패시터를 연결하여 사용 10여회 정도의 값을 받아 평균값으로 사용 for Receiverschematic: nRF24L01 receiver with ESP32 sketch1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4 ,5);long long address = 0x1234ABCDEFLL;struct Value{ uint16_t value_x; uint16_t value_y;};Value data;void setup() { Serial.begin(115200); radio.begin(); radio.openReadingPipe(1, address); radio.setPALevel(RF24_PA_LOW); radio.startListening();}unsigned long lastRecvTime = 0;void recvData(){ while( radio.available()){ radio.read(&amp;data, sizeof(Value)); lastRecvTime = millis(); }}void loop() { unsigned long now = millis(); if( now - lastRecvTime &gt; 1000){ recvData(); } Serial.print(&quot;x: &quot;); Serial.print(data.value_x); Serial.print(&quot;, y: &quot;); Serial.println(data.value_y); } result nRF24L01 + Dual Joystick + Dual Servomotorsfor Receiverschematic: nRF24L01 receiver with ESP32, Dual Joystick MG996R과 같이 전류 사용량이 큰 서보 모터를 2개 이상 사용하는 경우, ESP32의 5V pin에서 공급하는 전류량이 부족하여 서보모터 동작이 원활치 않을 수 있다. 이런 경우에는 아래와 같이 외부 전원을 사용하여야 한다. pinmap ESP32 servo_x servo_y GND GND (갈) GND (갈) 5V 5V (빨) 5V (빨) 25 VRX (주) 32 VRY (주) schematic: nRF24L01 receiver with ESP32, Dual Joystick, External Power (standalone) 외부 전원의 구성 18650 리튬이온 전지 2개를 사용하여 7.4V를 공급 (혹은 18650 3개를 사용하여 11.1V로 구성) XL4015E1칩을 사용한 HW-514 DC-DC regulator를 사용하여, 7.4V → 5V로 전압을 낮춘다. (유사한 형태의 모듈 사용 가능) HW-514 HC v0.2 Specification Input voltage: 5-36V (6.5V 미만 입력시 디스플레이 동작안됨) Output voltage: 1.25-32V continuously adjustableOutput current: adjustable, up to 5A (4.5A 이내 권장)Output power: 75W max (50W 이내 권장) Conversion efficiency: up to 96% Working frequency: 180KHzShort circuit protection: yesOver-temperature protectionInput reverse polarity protection: None,(필요시 고전류 다이오드를 입력단에 사용) Module Size: 68.2 * 38.8 * 15 (mm) 왼쪽 가변저항으로 출력 전압을 5V 조정 (오른쪽 가변저항은 출력 전류를 조정) 2P 출력단자는 모터에 직접 연결 USB포트는 USB-A to microUSB 케이블을 사용하여 ESP32에 연결 (이런 이유로 USB단자가 있는 모듈을 사용하는 것이 편함) 아래와 같은 mini360, mini560 등의 소형 컨버터를 사용하면, SG90 서보모터는 정상적으로 동작 MG996R 서보모터를 연결한 경우에는 컨버터 자체가 불안정하여 모터 동작이 멈춤 ※ 외부 전원 구성시 주의할 점! 외부 전원을 ESP32의 5V or 3.3V 핀에 직접 연결하지 않도록 한다. 외부 전원을 DC 컨버터를 사용하여 5V or 3.3V로 만든 경우에도 5V or 3.3V 핀에 직접 연결하면 안된다. ESP32의 스펙상 5V or 3.3V 핀을 사용하여 외부 전원을 구성해도 된다고 나와 있지만, 실제로는 모터 등의 모듈이 작동하지 않거나, 심할 경우 ESP32 보드가 망가질 수 있으므로 이와 같은 구성은 지양한다. (경험상) ESP32의 microUSB포트를 통해 전원을 공급하는 것이 가장 안정적으로 동작하였음! sketch: nRF24L01 receiver with ESP32, Dual Joystick , External Power (standalone)library for ESP32스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리 에서 “esp32servo“ 검색 sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4, 5);long long address = 0x1234ABCDEFLL;struct Value{ uint16_t value_x; uint16_t value_y;};Value data;//Servo motor library for ESP32#include &lt;ESP32Servo.h&gt;Servo servo_x; // create servo object to control a servoServo servo_y; // 16 servo objects can be created on the ESP32int angle_x, angle_y;// Recommended PWM GPIO pins on the ESP32 include 2,4,12-19,21-23,25-27,32-33 int servo_xPin = 15;int servo_yPin = 2;// RecvTimeunsigned long lastRecvTime = 0;void recvData(){ while( radio.available()){ radio.read(&amp;data, sizeof(Value)); lastRecvTime = millis(); }}void setup() { Serial.begin(115200); radio.begin(); radio.openReadingPipe(1, address); radio.setPALevel(RF24_PA_LOW); radio.startListening(); // Allow allocation of all timers ESP32PWM::allocateTimer(0); ESP32PWM::allocateTimer(1); ESP32PWM::allocateTimer(2); ESP32PWM::allocateTimer(3); servo_x.setPeriodHertz(50); // standard 50 hz servo servo_y.setPeriodHertz(50); servo_x.attach(servo_xPin, 500, 2500); // attaches the servo on pin 25 &amp; 32 to the servo object servo_y.attach(servo_yPin, 500, 2500); // using default min/max of 1000us and 2000us // different servos may require different min/max settings // for an accurate 0 to 180 sweep}void loop() { recvData(); unsigned long now = millis(); if( now - lastRecvTime &gt; 1000){ //ResetData(); } rotate_xy();}void rotate_xy() { Serial.print(&quot;x: &quot;); Serial.print(data.value_x); Serial.print(&quot;, y: &quot;); Serial.println(data.value_y); angle_x = map(data.value_x, 0, 4095, 0, 180); angle_y = map(data.value_y, 0, 4095, 0, 180); servo_x.write(angle_x); servo_y.write(angle_y); delay(10); } 조이스틱 중립 조정 2개의 조이스틱을 중립에 두고, 시리얼 모니터를 통해 센서값을 확인했을때, x축 서보모터는 2700정도, y축 서보모터는 2800 정도의 값을 나타내었다. 이를 기준으로 조이스틱의 값에 따른 대략적인 형태를 생각해보면 (아래의 원 그림에 2개의 조이스틱 값을 모두 나타냄) x축 조이스틱 값이 1350~3400 일때: 중립 (서보모터는 90도 위치로 이동) 0~1350 일때: 서보모터 1도씩 감소 (0도 위치가 될때까지) 단, 자동차 조향 시스템에 적용할 경우 55~90도 사이에서만 움직이도록 조정 3400~4095 일때: 서보모터 1도씩 증가 (180도 위치가 될때까지) 단, 자동차 조향 시스템에 적용할 경우 90~125도 사이에서만 움직이도록 조정 y축 조이스틱 값이 1400~3350 일때: 중립 (서보모터는 90도 위치로 이동) 0~1400 일때: 서보모터 1도씩 감소 (0도 위치가 될때까지) (자동차에 적용시 브레이크 역할) 3350~4095 일때: 서보모터 1도씩 증가 (180도 위치가 될때까지) (자동차에 적용시 액셀레이터 역할) 위 그림에 나타낸 값은 모든 조이스틱에 적용되는 절대적인 값이 아니며, 조이스틱마다 중립을 나타내는 센서값이 다르므로, 초기값을 100번 읽은 후 평균값을 만들어 사용한다. sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4 ,5);long long address = 0x1234ABCDEFLL;struct Value{ uint16_t value_x; uint16_t value_y;};Value data;//Servo motor library for ESP32#include &lt;ESP32Servo.h&gt;Servo servo_x; // create servo object to control a servoServo servo_y; // 16 servo objects can be created on the ESP32int angle_x = 90;int angle_y = 90;int i = 0;int center_x = 0;int center_y = 0;int ref_xl, ref_xr, ref_ya, ref_yb; // Servo rotation reference value // for no interference, each joysticks must be used with other ADC! (* not recommended)// one joystick use ADC1: GPIO 36,39,32,33,34,35// the other must use ADC2: GPIO 4,0*,2,15,13,12,14,27,25,26int servo_xPin = 15;int servo_yPin = 2;// RecvTimeunsigned long lastRecvTime = 0;void centerData(){ while(i &lt; 100) { if(radio.available()){ radio.read(&amp;data, sizeof(Value)); center_x = center_x + data.value_x; center_y = center_y + data.value_y; i++; } } center_x = center_x / 100; // x축 조이스틱 센터값 center_y = center_y / 100; // y축 조이스틱 센터값 ref_xl = center_x / 2; // 좌회전 동작 기준값 ref_xr = (4095 + center_x) / 2; // 우회전 동작 기준값 ref_ya = (4095 + center_y) / 2; // accelator 동작 기준값 ref_yb = center_y / 2; // brake 동작 기준값}void recvData(){ while(radio.available()){ radio.read(&amp;data, sizeof(Value)); lastRecvTime = millis(); }}void setup() { Serial.begin(115200); radio.begin(); radio.openReadingPipe(1, address); radio.setPALevel(RF24_PA_LOW); radio.startListening(); // Allow allocation of all timers ESP32PWM::allocateTimer(0); ESP32PWM::allocateTimer(1); ESP32PWM::allocateTimer(2); ESP32PWM::allocateTimer(3); servo_x.setPeriodHertz(50); // standard 50 hz servo servo_y.setPeriodHertz(50); servo_x.attach(servo_xPin, 500, 2500); // attaches the servo on pin 25 &amp; 32 to the servo object servo_y.attach(servo_yPin, 500, 2500); // using default min/max of 1000us and 2000us // different servos may require different min/max settings // for an accurate 0 to 180 sweep // center value centerData();}void loop() { unsigned long now = millis(); if( now - lastRecvTime &gt; 5){ // 5ms 마다 서보출력 recvData(); rotate_xy(); }}void rotate_xy() { //Serial.print(&quot;x: &quot;); Serial.print(data.value_x); //Serial.print(&quot;, y: &quot;); Serial.println(data.value_y); //x축 서보 구동 조건 설정 if(data.value_x &lt; ref_xl) { if(angle_x &gt; 0) { angle_x--; } else { angle_x = 0; } } else if(data.value_x &gt; ref_xr) { if(angle_x &lt; 180) { angle_x++; } else { angle_x = 180; } } else { if(angle_x &lt; 90) { angle_x++; } else if(angle_x &gt; 90) { angle_x--; } else { angle_x = 90; } } //y축 서보 구동 조건 설정 if(data.value_y &lt; ref_yb) { if(angle_y &gt; 0) { angle_y--; } else { angle_y = 0; } } else if(data.value_y &gt; ref_ya) { if(angle_y &lt; 180) { angle_y++; } else { angle_y = 180; } } else { if(angle_y &lt; 90) { angle_y++; } else if(angle_y &gt; 90) { angle_y--; } else { angle_y = 90; } } servo_x.write(angle_x); servo_y.write(angle_y); delay(5); // delay를 더 줄이면 서보 모터 기어에 무리가 감}","link":"/2021/10/10/ESP32-nRF24L01/"},{"title":"hexo icarus 테마로 Github 블로그 만들기","text":"필수 요소Hexo를 이용하여 블로그를 만들기에 앞서 아래 요소를 먼저 설치 git github.com에 repository 2개 생성하기 사용자ID-archives 사용자ID.github.io node.js npm hexo.io 사이트에는 이를 위한 설치 방법이 간단하게 요약이 되어 있지만, 이것만으로 자신이 원하는 형태의 블로그를 운영하기는 쉽지 않다. 이 글은 아무것도 설치 되어있지 않은 상태의 윈도우 사용 컴퓨터 사용자를 기준으로, d드라이브에 hexo 블로그를 생성하고 운영하는 방법을 차례대로 따라할 수 있도록 정리한 것이다. Git 설치 https://git-scm.com/download/win 에서 64-bit Git for Windows Setup 다운로드 설치 (설치 경로는 바꾸지 않음) exe 파일은 삭제 nodejs 설치 https://nodejs.org/en/download/ 에서 Windows Installer (.msi) 64-bit 다운로드 설치 (설치 경로는 바꾸지 않음) (선택사항) 설치 중 Tools for Native Modules 에서 Automatically install the necessary tools에 체크 chocolately, python, visualstudio 등 여러가지 패키지가 설치됨 설치 후, 리부팅 필요 환경 변수 구성: 제어판&gt; 고급 시스템 설정 보기&gt; 고급&gt; 환경 변수를 열고, 사용자 변수와 시스템 변수에 다음을 새로만들기 혹은 추가 PATH 변수에 아래의 변수값 지정되어 있는지 확인 (없으면 새로 만들기) 변수값: C:\\Program Files\\nodejs git-bash 실행 후, hexo 및 icarus 테마 설치terminal12cd d:/devnpm install -g hexo-cli terminal12345mkdir mybloghexo init myblog // myblog 폴더가 비어 있어야 함.cd mybloggit clone --depth 1 https://github.com/ppoffice/hexo-theme-icarus.git themes/icarushexo config theme icarus 아래와 같은 error 메세지가 나오면, terminal123456789ERROR Package bulma-stylus is not installed.ERROR Package hexo-renderer-inferno is not installed.ERROR Package hexo-component-inferno is not installed.ERROR Package inferno is not installed.ERROR Package inferno-create-element is not installed.ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.13.0 inferno@^7.3.3 inferno-create-element@^7.3.3ERROR or:ERROR yarn add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.13.0 inferno@^7.3.3 inferno-create-element@^7.3.3 패키지를 추가 설치한 후 terminal1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.13.0 inferno@^7.3.3 inferno-create-element@^7.3.3 다시 실행 terminal1hexo config theme icarus 이후에 아래와 같은 메세지가 나오면 _config.icarus.yml이 생성되면서 완료된다. terminal12345678910111213141516171819INFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===WARN None of the following configuration files is found:WARN - D:\\dev\\stemwith\\_config.icarus.ymlWARN - D:\\dev\\stemwith\\themes\\icarus\\_config.ymlINFO Generating theme configuration file...INFO D:\\dev\\stemwith\\_config.icarus.yml created successfully.INFO To skip configuration generation, use &quot;--icarus-dont-generate-config&quot;.INFO === Registering Hexo extensions === 이제 블로그 저장소 주소를 설정 파일(_config.yml)에 적어준다. _config.yml12345theme: icarusdeploy: type: git repo: https://github.com/myblog/myblog.github.io branch: master 로컬에서 확인 terminal1hexo server --debug 이후, 브라우저에서 terminal1http://localhost:4000 배포를 위한 hexo-deployer-git 설치 terminal1npm i hexo-deployer-git --save 이제 hexo generate와 hexo deploy를 사용할 수 있다. icarus 테마 설정Category list order 설정 (선택사항) d:/dev/myblog/node-modules/hexo-generator-category/lib/generator.js 수정 node-modules/hexo-generator-category/lib/generator.js12345module.exports = function(locals) { const config = this.config; const perPage = config.category_generator.per_page; const paginationDir = config.pagination_dir || 'page'; const orderBy = config.category_generator.order_by || '+date'; orderBy 부분 -date : 최근 글 순 (default) +date : 오래된 글 순 기본 설정 Site Configuration: _config.yml 수정 _config.yml123456789101112# Sitetitle: myblogsubtitle: 'my first blog'description: 'life diary'keywords:author: anonymouslanguage: kotimezone: Asia/Seoul# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://[githubID].github.io Localization re-testing terminal1hexo clean &amp;&amp; hexo s Alternative Configuration_config.yml 에서는 가장 기본적인 셋팅과 테마 설정만 하고. 나머지 설정은 _config.[테마명].yml 에서 수행한다. 사용 예시동일한 설정항목에 대하여 두가지 이상의 설정파일에서 동시에 정의하는 경우, 우선순위에 의해 설정값이 결정된다. 만약 _config.yml, _config.[테마명].yml, themes/[테마명]/ _config.yml 세가지 설정파일이 동시에 존재하는 경우, 각 파일을 아래와 같이 설정했다면, _config.yml12# _config.ymltheme: &quot;my-theme&quot; _config.icarus.yml1234# _config.icarus.ymlbio: &quot;My awesome bio&quot;foo: bar: 'a' /themes/icarus/_config.yml12345# themes/icarus/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot; foo: baz: 'b' 최종적으로 설정되는 값은 각각 다음과 같다. config12345bio: &quot;My awesome bio&quot;,logo: &quot;a-cool-image.png&quot;,foo: { bar: &quot;a&quot;, baz: &quot;b&quot; icarus 테마 셋팅 출처: 친성의 블로그 github hexo blog web font 적용하기, hexo icarus 테마에 커스텀 레이아웃, 스타일(css) 적용하기 폰트 수정layout/common/head.jsx 51 line123456// 51 lineconst fontCssUrl = { default: fontcdn(&quot;Ubuntu:wght@400;600&amp;family=Source+Code+Pro&quot;, &quot;css2&quot;), cyberpunk: fontcdn(&quot;Oxanium:wght@300;400;600&amp;family=Roboto+Mono&quot;, &quot;css2&quot;), nanumgothic: fontcdn(&quot;Nanum+Gothic:wght@400&amp;family=Roboto&quot;, &quot;css2&quot;),}; layout/common/head.jsx 151 line123// 151 line&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; /&gt;&lt;link href={fontCssUrl['nanumgothic']} rel=&quot;stylesheet&quot; /&gt; include/style/base.styl 8 line12$family-sans-serif ?= 'Gowun Dodum', 'Nanum Gothic', Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif// $family-sans-serif ?= Ubuntu, Roboto,'Nanum Gothic Coding', 'Open Sans', 'Microsoft YaHei', sans-serif include/style/article.styl 4 line1$article-font-size ?= 1.2rem Google Fonts에서 사용가능한 몇가지 폰트들을 검색해볼 수 있다. 이 사이트는 Google Fonts에서 지원하는 Gowun Dodum 폰트를 사용하도록 설정하였다. 이 경우 새로운 폰트 cdn을 import할 필요는 없으나, 특별한 폰트를 원하는 경우에는 아래와 같은 방법으로 새로운 cdn을 import하여야 한다. themes/icarus/source/css/default.styl12345678910111213141516 @import url(https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css)&lt;br&gt;#### 가독성 향상icarus 테마의 포스트 글자 크기나 기본 줄간격이 좋지 않아 가독성이 떨어지는 경향이 있어 아래와 같이 수정한다.1. 포스트 제목 폰트 변경: &amp;.article 을 검색한 후, .title 추가 ``` [html] themes/icarus/include/style/article.styl &amp;.article .title font-size: 2.0em font-weight: 700 letter-spacing: -1.4px; 포스트 컨텐트 폰트 변경: .content를 검색한 후, 수정 themes/icarus/include/style/article.styl123456.content font-size: $article-font-size line-height: 1.75em; letter-spacing: -0.3px; color: #5d686f; margin-top: 20px; heading 폰트 변경: h1과 h2만 수정 themes/icarus/include/style/article.styl12345678h1 font-size: 1.95em font-weight: 600 margin-top: 50px; h2 font-size: 1.5em margin-top: 35px; 컬럼 비율 조정하기 layout/common/widgets.jsx 로 가보면 getColumnSizeClass라는 함수가 있다 여기에 자신의 columnCount 에 맞게 수정한다 columnCount* 의 기본값은 2라서 case 2인 경우를 is-3으로 수정 themes/icarus/layout/common/widgets.jsx123456789function getColumnSizeClass(columnCount) { switch (columnCount) { case 2: return 'is-3-tablet is-3-desktop is-3-widescreen'; // 여기 수정 case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} layout/layout.jsx 아래쪽에서 is-9로 수정해주었다 전체 12에서 기본값은 프로필이 들어있는 영역이 4, 게시글 영역이 8이였다 위처럼 수정하게되면 우선 그 비율을 3, 9로 변경해준 것이다 프로필 영역을 좁게, 게시글 영역은 크게 바뀐 것이다 이 12라는 것은 칼럼들의 상위에 있는 container의 크기를 기준으로 12등분한 것이다. themes/icarus/layout/layout.jsx1234567891011&lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-9-tablet is-9-desktop is-9-widescreen': columnCount === 2, // 여기 수정 'is-9-tablet is-9-desktop is-6-widescreen': columnCount === 3, })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; container 크기 늘리기 include/style/base.styl 로 가서 23라인 정도에 보이는 아래 코드 중에서 $widescreen, $fullhd의 값을 각각 200px 씩 늘려준다. themes/icarus/include/style/base.styl12345$gap ?= 16px$tablet ?= 769px$desktop ?= 1288px$widescreen ?= 1480px$fullhd ?= 1672px 커스텀 css 적용이미지 margin 변경themes/icarus/include/style/article.styl1234567891011121314151617&amp;.article .article-meta, .article-tags color: $text-light .article-meta overflow-x: auto margin-bottom: .5rem .article-more @extend .button.is-light .content word-wrap: break-word font-size: $article-font-size img // 여기 추가 margin-top: 30px // 여기 추가 변경된 css의 배포 및 적용 hexo server에서는 최신 css 상태를 반영하는데, 그런데 실제로 배포될 때는 css파일이 갱신이 안된다. 그러므로 public/css/default.css 파일을 삭제하고, 다시 hexo generate로 생성한 후 배포한다. link, hover 컬러 변경 link, link-visited 컬러가 blue와 purple로 지정되어 있는 것이 어울리는것 같지 않아 grey-darker와 grey-light로 변경 node_modules/bulma-stylus/stylus/utilities/derived-variables.styl12345678910111213141516// Link colors$link ?= $grey-darker$link-invert ?= findColorInvert($link)$link-light ?= findLightColor($link)$link-dark ?= findDarkColor($link)$link-visited ?= $grey-dark$link-hover ?= $grey-darker$link-hover-border ?= $grey-light$link-focus ?= $grey-darker$link-focus-border ?= $blue$link-active ?= $grey-darker$link-active-border ?= $grey-dark Troubleshooting경로의 대소문자 구분 설정경로에서 사용하는 폴더나 파일이름의 대소문자 구분 문제로 인해, 파일 인식이 안되는 경우가 발생한다. 특히, generate 시에 아래와 같은 메세지가 여러개 나오면, 대부분 파일이름의 대소문자 구분 문제라고 생각하면 된다. terminal1Markdown Image Path does not exists! 이런 경우, 다음과 같은 방법으로 문제를 해결해야 한다. _config.yml의 filename_case 수정 terminal12# Writingfilename_case: 1 0: 대소문자 구분 1: 경로를 이루는 문자를 모두 소문자로 변경하여 관리 2: 경로를 이루는 문자를 모두 대문자로 변경하여 관리 github.com에 로그인하여 repository의 categories 폴더 삭제 d:\\dev\\myblog\\ 폴더의 .deploy_git 폴더 삭제 hexo clean 후 재배포 재배포시에 다음과 같은 에러가 생길 수 있다. terminal1fatal: not a git repository (or any of the parent directories): .git .deploy_git 폴더의 삭제에 따라, git에 대한 정보를 담은 파일이 없기 때문에 발생하는 에러이며, d:\\dev\\myblog 폴더에서 다음을 실행한 후, terminal12git initgit remote add 이렇게 해도 경로가 인식이 안되는 경우는, Git에서 대소문자를 구분하게 설정하고, 폴더명 및 파일이름의 대소문자를 하나하나 맞춰주어서 해결할 수도 있다. terminal1git config --global core.ignorecase=false 기존 블로그를 복구하는 경우 기존에 사용하던 블로그 디렉토리가 d:\\dev\\myblog 인 경우, d:\\dev 폴더 전체를 다른 폴더에 복사하여 백업해두고 아래의 과정을 진행한다. 백업 완료 후, 기존에 사용하던 d:\\dev\\ 폴더 자체를 삭제한 후, 아래의 과정을 수행하여 모든 설치를 마친 뒤, 백업해둔 myblog 폴더에서 필요한 부분을 복구함. favicon이 안나오는 경우로컬 테스트시 favicon이 출력되지만, github 배포시 출력되지 않는다면 _config.icarus.yml1234head: # URL or path to the website's icon favicon: /img/favicon.png? # Open Graph metadata _config.icarus.yml 에서 상단에 favicon을 설정하는 부분에서 favicon.png 끝에 ?를 추가한 후, 재배포 한다. 블로그 포스트 생성 test.md 파일을 만든 뒤, d:/dev/stemwith/source/_post/ 폴더에 복사 test.md 파일의 가장 앞부분에 들어가는 post front-matter는 다음과 같이 구성한다. .md123456789101112---title: test 블로그 페이지date: 2019-09-17 01:32:35updated: category: - blogtags: - hexo - blogtoc: truethumbnail: /images/preview.jpg--- toc: true를 추가하면 헤딩 태그(h1~h6)를 통해 목차를 만들어 준다. (icarus 테마의 경우) 로컬에서 페이지 확인 terminal12hexo servehttp://localhost:4000 로컬 작업 내용을 github 도메인으로 배포 (push) terminal12hexo generatehexo deploy or terminal1hexo g -d deploy 후에도 오랜시간 업데이트가 안된다면, 페이지 clean 후 재배포 terminal12hexo cleanhexo deploy --generate Code fence.md1234567891011``` [language] [title] [url] [link text] [additional options]code snippet```{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %}{% code [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcode %} 첫번째 라인에 .md1``` [C++] 파일이름 과 같이 적어주면 코드박스 상단에 파일이름이 표시된다. 파일이름은 [ ]로 감싸게 되면, [ ]까지 출력된다. typora에서는 `````를 먼저 입력한 뒤, 코드박스가 나타나면, 코드박스 하단의 language 입력란에 입력한다. about 페이지 만들기아래 명령을 통해 source/about/index.md을 생성한 후, 파일을 수정하여 사용한다. terminal1hexo new page &quot;about&quot; 사진 첨부 방법 첨부할 사진 파일 위치 : 사진 파일을 d:/dev/stemwith/source/image/ 폴더에 복사 마크다운 파일에서 파일 위치를 다음과 같이 지정함 지정함 .md1![사진첨부파일설명](/image/~~~.jpg) 사진 출력시 사이즈 조정 icarus, next 테마 사용시에는 사진 사이즈 조정이 필요한 경우, img 태그를 사용하여 zoom 수치로 조정하여야 함 .md1&lt;img src=&quot;/image/test.png&quot; style=&quot;zoom:80%;&quot; /&gt; book 테마 사용시에는 아래와 같이 하면 화면에 출력되는 크기를 조정할 수 있다. (단, icarus, Next 테마와 같은 방법을 사용해도 된다.) .md1![사진첨부파일설명](/image/~~~.png =432x768) 주의 사항 필요한 경우, hexo-image-link-with-display-size 설치 terminal1npm i hexo-image-link-with-display-size 사진이 위치한 폴더를 지정할 때, /image/ 폴더 앞에 점(.) 같은 것을 추가하면 안됨 파일이름에 언더바(_)가 포함되면 안됨. 대시(-)는 가능 Github 블로그 구글 검색 노출※ 출처: 내 github blog 글이 구글 검색에 나오는 법(친성의 블로그) blog 설정SEO (search engine optimization) 설정블로그 설치 폴더가 d:\\dev\\myblog 인 경우, d:\\dev\\myblog 폴더에서 terminal1234npm i hexo-autonofollownpm i hexo-generator-feednpm i hexo-generator-seo-friendly-sitemapnpm i hexo-generator-robotstxt 필요한 경우 hexo-auto-canonical과 hexo-component-inferno을 추가로 설치한다. terminal12npm i hexo-auto-canonicalnpm i hexo-component-inferno 설치 후 terminal1npm audit fix ※ 표준링크 확인 방법 본인 블로그로 접속 F12로 개발자도구를 열고 개발자도구 상단의 요소를 클릭한 뒤, Ctrl-F를 눌러 canonical를 검색했을 때, 아래 형태의 링크 태그가 검색이 되면, 이미 표준링크가 생성되고 있는 것임. 이런 경우에는 hexo-auto-canonical은 설치하지 않아도 됨! 1&lt;link rel=&quot;canonical&quot; href=&quot;http://블로그 글 주소/&quot; NEXT 테마의 경우, (이미 표준링크를 생성하고 있으므로) hexo-auto-canonical은 설치하지 않아도 됨 _config.yml 설정_config.yml 최하단 deploy 설정 아래에 다음을 추가 _config.yml123456789101112131415161718nofollow: enable: true exclude: - exclude1.com - exclude2.comfeed: type: rss2 path: rss2.xml limit: 20sitemap: path: sitemap.xml tag: false category: falserobotstxt: useragent: '*' allow: - / sitemap: https://깃허브유저네임.github.io/sitemap.xml 배포terminal1hexo g -d 생성된 파일 확인하기d:\\dev\\myblog\\public\\ 디렉터리 하단에 rss2.xml, sitemap.xml, robots.txt 이 3개의 파일이 보이는지 확인한다. 검색 노출구글 검색 엔진 등록 Google Search Console 에 접속후 시작하기 클릭 URL 접두어를 선택하고, 자신의 깃헙 주소 (예, https://testblog.github.io)를 입력한 뒤 계속 클릭 소유권 확인 html 파일 다운로드 (_config.yml 이 위치한) d:\\dev\\myblog\\public\\ 디렉토리에 다운 받은 파일을 넣고 hexo d 로 배포 잠시 대기 후, 소유권 확인 과정 창의 확인 클릭 (확인이 안된다고 나오는 경우에는 잠시 후에 다시 시도 해야 함) 소유권이 확인되면, 속성으로 이동 클릭 Google Search Console에서 왼쪽 메뉴의 sitemaps 클릭 새 사이트맵 추가에서 sitemap.xml 입력 후 제출 클릭 새 사이트맵 추가에서 rss2.xml 입력 후 제출 클릭 두 파일의 제출 상태가 성공으로 표시되어야 함 (가져올 수 없음 이라고 나오면 잠시 후에 페이지 새로고침을 해보고, 성공으로 표시되는지 확인이 필요함) 실제 검색은 하루 정도 지나면 가능 Naver 검색 노출 구글과 유사하며, 네이버 웹마스터 도구 (Naver Search Advisor)를 사용하여 등록함 RSS 제출 메뉴와 사이트맵 제출 메뉴가 분리되어 있으므로, sitemap.xml 및 rss2.xml 등록시 유의 Daum 검색 노출 Daum 검색등록으로 들어가서 신규 등록에 블로그 URL을 등록한 뒤 확인을 클릭하여 제출하면, 심사 후 이메일로 등록 결과를 알려줌 Mathjax &amp; KaTeX 설정 _config.[테마].yml 설정 _config.icarus.yml1234567math: enable: false ... katex: enable: true # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex copy_tex: true ​ math: enable: false 상태에서는 필요한 렌더링이 필요한 페이지의 front matter에 mathjax: true를 넣어주어야 한다. .md1234---title: Will Render Mathmathjax: true--- Google Analytics 설정_config.icarus.yml1234# Google Analytics# See: https://analytics.google.comgoogle_analytics: tracking_id: UA-*********-1 // google analytics 계정 s○○○○○○○@○○○○○○○.com","link":"/2019/09/01/hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"ESP32, 중력 가속도 측정","text":"중력(Gravitational Force)뉴턴은 달의 운동과 케플러의 법칙을 통해, 달과 지구 사이에 작용하는 힘은 지구의 질량과 달의 질량의 곱에 비례하고 거리의 제곱에 반비례한다는 만유인력의 법칙을 밝혔다.$$F = G \\frac{Mm}{r^2} = m_i a = mg$$ 지구의 질량 M$$M=5.072 \\times 10^{24}~kg$$ 지구 반지름 r$$r = 6371~km$$ 만유인력 상수값은 다음과 같다. (캐번디시에 의해 측정된 G값은 6.674)$$G = 6.67259 \\times 10^{-11}~N \\cdot m^2 /kg^2$$ 만유인력이 지상의 물체에 작용되는 경우, 이때 작용하는 힘을 중력이라고 한다. 중력 가속도(Gravitational Acceleration)위 식에서 관성 질량(m_i)과 중력 질량(m)이 같다는 등가원리를 적용하면 중력 가속도는 작은 물체의 질량 m에 무관하게 된다.$$a = g = G \\frac{M}{r^2}$$ 지구의 질량 M과 지구 반지름 R은 지표면의 물체에 비해 매우 크고, 거의 구에 가까우므로, 위 식을 사용하여 지구 표면에서의 중력 가속도 g 값을 구할 수 있다.$$g = 9.80665~m/s^2$$ 등가속도 직선 운동가속도의 크기와 방향이 일정한 직선 운동으로, 속도가 일정하게 증가하거나 감속하는 직선 운동을 의미한다. 자유낙하의 경우 초기속도가 0인 물체를 중력장에 낙하시킬 때 중력가속도를 받으며 낙하하는 물체의 운동이며, 공기의 저항이 없다고 가정할 경우 등가속도 직선 운동이 된다. 등가속도 직선 운동과 관련된 공식은 다음과 같다.$$v = v_0 + at~~~\\cdots~~~①$$ $$s=v_0t + \\frac{1}{2}at^2~~~\\cdots~~~②$$ $$2as = v^2 - v_0^2~~~\\cdots~~~③$$ 이 3가지 기본 공식을 통해 다양한 형태의 공식을 유도할 수도 있다. ①, ②식을 조합하면$$s = \\frac{1}{2}(v_0+v)t~~~\\cdots~~~④$$③식에서 초기속도(v_0)가 0인 경우$$v=\\sqrt{2as}~~~\\cdots~~~⑤$$②식을 변형하면$$a=\\frac{2(s-v_0t)}{t^2}~~~\\cdots~~~⑥$$③식을 변형하면$$a=\\frac{v^2-v_0^2}{2s}~~~\\cdots~~~⑦$$ 자유낙하를 이용한 중력 가속도 측정 실험 실험 목적: 중력 가속도를 측정하는 방법은 여러 가지가 있지만, 본 실험은 자유 낙하를 통해 중력 가속도를 측정하고자 한다. 자유낙하 운동이 중력을 가장 쉽게 표현할 수 있는 운동이라 판단하였기 때문이다. 정밀한 값의 측정보다는, 자유낙하 운동을 통해 중력 가속도를 이해하고 이를 실험을 통해 확인하는 것이 이번 실험의 목적이다. 보다 정밀한 중력 가속도를 측정하기 위해서는 진자의 운동 주기를 이용하는 것이 좋다. 이번 실험에서는 2m 길이의 파이프에 25cm 간격으로 센서를 배치하고, 낙하하는 물체가 센서를 지날때마다 시간을 기록할 것이다. 변위와 시간을 측정할 수 있으므로 초기속도(v_0)값만 알면 ⑥을 이용하여 중력 가속도를 계산할 수 있다. ⑥을 단순화 시키기 위해서는 초기 속도가 0이 되도록 하기 위해 첫번째 센서를 파이프의 입구(최상단)에 배치하는 것이다. 단, 이렇게 할 경우 실험 과정에서 낙하시킬 물체를 놓을 때 물체를 잡고 있는 손가락의 영향을 제거하기 어려우며, 이 문제에 기인하는 오차는 큰 편이라고 할 수 있다. 위 문제 해결을 위해 첫번째 센서를 최상단으로부터 12.5cm 정도 아래로 내려 설치한다. 이를 통해 센서가 측정하는 시간은 온전히 자유낙하하는 상태에서 측정되므로 비교적 정확하게 측정할 수 있다. 문제는 첫번째 센서 위치에서의 초기 속도(v_0)값이 0이 아니므로 이 값을 별도로 계산하여야 한다. 이 값은 ③으로부터 계산할 수 있는데, $$2as = v^2 - v_0^2~~~\\cdots~~~③$$ 파이프 입구에서의 초기 속도(v_0)를 0으로 가정하면, 12.5cm만큼 낙하하여 첫번째 센서에 반응할 때의 속도(v)값은 ⑤로 부터 구할 수 있다. $$v=\\sqrt{2as} = \\sqrt{2\\times9.80665\\times0.125}=1.5658~m/s$$ 이 값이 12.5cm 위치에 첫번째 센서를 설치한 실험기구를 사용하는 경우, ⑥에서의 초기 속도(v_0)값이 된다. 파이프에 설치한 센서의 번호를 n이라고 하면, ⑥은 다음과 같이 쓸 수 있다. $$a_n=\\frac{2(s_n-1.5658t_n)}{t_n^2}$$ s는 첫번째 센서 ~ 각 센서가 위치한 곳까지 물체가 이동한 변위이며, 8개의 센서를 사용하여 낙하하는 물체가 센서와 반응하는 시간(t_n)을 측정하고, 이를 ⑥에 대입하면 가속도(a_n)를 계산할 수 있다. 각 지점에서의 가속도를 평균계산하여 중력가속도를 구한다. 센서 입구 ~ 0 0 ~ 1 0 ~ 2 0 ~ 3 0 ~ 4 0 ~ 5 0 ~ 6 0 ~ 7 s_n (m) 0.125 0.25 0.50 0.75 1.00 1.25 1.50 1.75 t_n a_n 이 실험의 한계 이 실험의 목적은 자유 낙하하는 물체를 통해 중력 가속도를 측정하는 것이다. 그런데, 중력 가속도를 계산하는 중간 과정에서, ⑤를 이용하기 위한 초기 속도(v_0=1.5658m/s) 값을 계산하기 위해 (실험 목적값인) 중력 가속도 9.80665m/s²를 사용한 것은 이 실험을 행하는 본질을 벗어나는 것이라고 볼 수 있다. 그렇지만, 여기서는 각 센서를 통해 측정되는 값으로 계산해낸 중력 가속도의 평균 값이 어느 정도되는지 확인해보고, 실제값과 어느 정도의 오차를 보이는지를 확인하는 교육 목적을 갖고 사용하는 것임을 감안할 필요가 있다. 이를 근거로 중력 가속도 값을 이용하여 계산한 첫번째 센서위치에서의 초기 속도 값을 기본 보정값의 개념으로 사용하고자 한다. 이러한 방법이 합당하지 않다고 생각한다면, 위에서 언급한 것 처럼 초기 속도(v_0)가 0이 되도록 센서를 파이프의 입구(최상단)에 배치하고, 물체가 손에서 떨어짐과 동시에 첫번째 센서에 반응하도록 낙하시키는 위치를 정확하게 조절하며 실험해야 한다. 실험 장치 만들기파이프 준비 길이 2m 투명 아크릴 파이프(내경 3.5cm)에 **구간 거리가 0.25m(=25cm)**가 되도록 일정하게 IR LED를 배치하고 고정한다. 센서 장착 맨 위쪽과 아래쪽에는 12.5cm정도 띄우고 IR LED와 Phototransistor를 배치함 손에서 낙하물을 놓을 때, 낙하물이 바닥에 닿을 때, 낙하시간에 영향을 주는 요소를 제거하기 위함 IR LED와 Phototransistor가 서로 정확하게 마주 볼 수 있는 위치에 유성펜을 사용하여 표시한다. 드릴을 이용하여 아크릴 파이프에 지름 5mm의 구멍을 뚫는다. 아크릴이 파손되지 않도록 유의한다. 이를 위해 먼저 작은 지름(1~2mm)의 드릴비트를 이용하여 작은 구멍을 뚫은 뒤, 그 구멍에 5mm 드릴비트를 사용하여 LED가 들어갈 구멍을 다시 뚫는 것이 좋다. IR LED와 Phototransistor를 구멍에 넣고 글루건을 사용하여 고정한다. 글루건이 IR LED와 Phototransistor의 앞부분에 뭍지 않도록 주의 글루건이 손에 뭍으면 화상을 입을 수 있으므로 주의 배선 각 센서 층마다 저항과 전원선과 데이터선을 다음과 같이 연결한다. IR LED 부품번호 및 제조회사가 표기되어 있지 않아 정확히 어떤 제품인지 알 수 없어, Everlight사의 IR333-A (940nm, 직경5mm)의 Datasheet를 참고하였다. Forward Current 100mA, Forward Voltage 1.5V 5V를 전원으로 사용하는 경우$$R = \\frac{(5-1.5)V}{0.1A} = 35~Ω$$그러므로 35Ω보다 약간 큰 47Ω저항을 연결한다. 100Ω정도의 저항도 사용할 수 있으나, 너무 큰 저항을 사용할 경우 IR의 세기가 작아지게 되므로, 실험이 잘 안될 수 있다. 실외에서는 태양광에 포함된 적외선의 영향도 받게 되므로 사용장소가 실내로 제한된다. Phototransistor 적외선이 닿으면 전류를 흐르게 하는 스위치 역할을 한다. 콜렉터(Collector)의 역할을 하는 긴다리와 에미터(Emitter)의 역할을 하는 짧은 다리, 총 2개의 다리가 붙어가 있지만 적외선 빛이 베이스(Base)의 역할을 하는 트렌지스터이다. 스위치의 역할을 하므로, 1MΩ의 풀업 저항을 긴다리에 부착한다. 10k옴을 써도 무방하지만 센서의 감도가 떨어지게 됨 schematic 8세트의 IR LED와 Phototransistor를 사용하기 위해 아날로그 입력이 총 8개 필요하다. 그러므로 여기서는 많은 아날로그 입력핀을 갖고 있는 ESP32를 사용하도록 한다. 장치의 특성상, 최종 사용시에는 USB선을 분리한 상태에서 사용할 수 있도록 하는 것이 좋으므로, 18650 배터리 홀더가 내장된 ESP32를 사용하는 것도 좋은 방법이다. ※ 아두이노 UNO의 경우 아날로그 입력이 총 6개이고, 여기에 SDA, SCL과 같은 I2C 통신포트를 사용한다면 실제 사용가능한 아날로그 포트가 4개밖에 남지 않는다. 아두이노 UNO를 사용해야한다면 CD4051BE와 같은 멀티플렉서 IC를 추가로 사용하여야 한다. 혹은 아날로그 입력 포트를 많이 가지고 있는 아두이노 MEGA를 사용한다. sketch: 센서 테스트 모든 센서의 배선이 완료되면, 센서가 잘 작동하는지 테스트하기 위한 스케치를 업로드하여 센서를 점검한다. 12345678910111213141516171819202122232425// Potentiometer is connected to GPIO 34 (Analog ADC1_CH6) const int ir_Pin[8] = {36, 39, 34, 35, 32, 33, 4, 2};// variable for storing the potentiometer valueint ir_Value[8] = {0, 0, 0, 0, 0, 0, 0, 0};void setup() { Serial.begin(115200); delay(1000); // Print the header: Serial.println(&quot;Y0\\tY1\\tY2\\tY3\\tY4\\tY5\\tY6\\tY7&quot;); Serial.println(&quot;---\\t---\\t---\\t---\\t---\\t---\\t---\\t---&quot;);}void loop() { // Loop through all eight pins. for (byte pin=0; pin&lt;=7; pin++) { ir_Value[pin] = analogRead(ir_Pin[pin]); Serial.print(String(ir_Value[pin]) + &quot;\\t&quot;); } Serial.println(); delay(2);} 센서값이 4095으로 출력되는 센서는 배선 자체의 연결에 문제가 있는 것이므로, 배선이 연결되어야 하는 부분에 정확하게 연결이 되었는지 우선 점검한다. 초기 상태의 센서값이 모두 0에 근접하는 값으로 표시될 수 있도록 하는 것이 좋으며, 초기값이 0에서 많이 벗어나는 경우에는 LED와 Phototransistor가 서로 정확하게 마주 볼 수 있도록 조절해준다. 조절 후에도 센서값이 0이 되지 않을 수 있다. 이때는 0에 가장 가까운 값이 만들어지도록 최대한 조절한다. 이 상태에서 물체를 떨어뜨려 모든 센서가 물체에 반응하는지 살펴본 뒤, 물체에 반응하는 센서값의 최소값을 점검한다. sketch 테스트 sketch를 통해 센서의 반응 정도를 파악한 뒤에, 메인 스케치를 업로드 한다. 업로드 전에 아래 부분을 찾아, 각 센서에 따라으로 물체에 반응하는 센서의 최소값(센서 테스트시 점검할 것!)으로 바꿔준다. 민감도의 범위는 0~4095이며, 값이 작을 수록 떨어지는 물체에 민감하게 반응한다. 기본값은 모두 100으로 설정되어 있다. 12// The smaller the value, the more sensitive (0~4095)const int min_Sensitive[8] = {100, 100, 100, 100, 100, 100, 100, 100}; 메인 스케치123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/****** ESP32 SKETCH FOR GRAVITATIONAL ACCELERATION ****** Author: K. Jun, Lee Blog: https://stemwith.github.io 2020-10-06*********************************************************/// GPIO of connecting with 8 Phototransistorsconst int ir_Pin[8] = {36, 39, 34, 35, 32, 33, 4, 2};// variable for storing the potentiometer valueint ir_Value[8] = {0, 0, 0, 0, 0, 0, 0, 0};// variable for IR Phototransistors' sensitivityint ir_Sensitivity[8] = {0, 0, 0, 0, 0, 0, 0, 0};// The smaller the value, the more sensitive (0~4095)const int min_Sensitive[8] = {100, 100, 100, 100, 100, 100, 100, 100};// for recording of sensing time by micros()unsigned long nowTime[8] = {0, 0, 0, 0, 0, 0, 0, 0};// for recording of interval time by micros()unsigned long intervalTime[8] = {0, 0, 0, 0, 0, 0, 0, 0};/*// for distance of 8 sensors in micrometer unit// (12.5cm - 25cm - 25cm - 25cm - 25cm - 25cm - 25cm - 25cm)unsigned long ir_Distance[8] = {125000, 250000, 250000, 250000, 250000, 250000, 250000, 250000};*/// for testing distance of 8 sensors in micrometer unit// (1.4cm - 2.54cm - 2.54cm - 2.54cm - 2.54cm - 2.54cm - 2.54cm - 2.54cm)unsigned long ir_Distance[8] = {14000, 25400, 25400, 25400, 25400, 25400, 33300, 25400};// for displacemence of 8 sensors in micrometer unitunsigned long ir_Displacemence[8] = {0, 0, 0, 0, 0, 0, 0, 0};// for interval accelerationfloat acceleration[8] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};// for times numberint t = 0;// Gravitational Acceleration &amp; Initial Velocityfloat g = 9.80665; // 9.80665 m/s^2 = 0.00000980665 um/us^2float initVelocity = sqrt(2*g*((float)ir_Distance[0]/1000000)); // in m/s unitvoid setup() { Serial.begin(115200); delay(1000);// Setup Displacemence for (byte pin=1; pin&lt;8; pin++) { ir_Displacemence[pin] = ir_Displacemence[pin-1] + ir_Distance[pin]; }}void loop() { // Print the header:; t++; float sum_Accel = 0.0; unsigned long initTime = 0; Serial.println(); Serial.print(&quot;Experiment #&quot;); Serial.println(t); Serial.println(&quot;\\t\\tY0\\t\\tY1\\t\\tY2\\t\\tY3\\t\\tY4\\t\\tY5\\t\\tY6\\t\\tY7&quot;); Serial.println(&quot;\\t\\t---\\t\\t---\\t\\t---\\t\\t---\\t\\t---\\t\\t---\\t\\t---\\t\\t---&quot;); // Initializing 8 IR Phototransistors' Sensitivity: for (int s=0; s&lt;101; s++) { for (byte pin=0; pin&lt;=7; pin++) { ir_Sensitivity[pin] = ir_Sensitivity[pin] + analogRead(ir_Pin[pin]); } } // Average of Initial Senser value Serial.print(&quot;IR_Sensivitity\\t&quot;); for (byte pin=0; pin&lt;8; pin++) { ir_Sensitivity[pin] = ir_Sensitivity[pin] / 100; Serial.print(String(ir_Sensitivity[pin]) + &quot;\\t\\t&quot;); } Serial.println(); // Loop through #0~7 pins. Serial.print(&quot;IR_Value\\t&quot;); for (byte pin=0; pin&lt;8; pin++) { while (ir_Value[pin] &lt;= ir_Sensitivity[pin] + min_Sensitive[pin]) { if(pin==0) { initTime = micros(); } nowTime[pin] = micros() - initTime; ir_Value[pin] = analogRead(ir_Pin[pin]); } Serial.print(String(ir_Value[pin]) + &quot;\\t\\t&quot;); } Serial.println(); Serial.print(&quot;Now Time(us)\\t&quot;); for (byte pin=0; pin&lt;8; pin++) { Serial.print(String(nowTime[pin]) + &quot;\\t\\t&quot;); ir_Value[pin] = 0; ir_Sensitivity[pin] = 0; } Serial.println(); Serial.print(&quot;Interval(s)\\t&quot;); for (byte pin=1; pin&lt;8; pin++) { intervalTime[pin] = nowTime[pin] - nowTime[pin-1]; float f_intervalTime = (float)intervalTime[pin] / 1000000.0; Serial.print(&quot; &quot; + String(f_intervalTime, 6) + &quot;\\t&quot;); } Serial.println(); Serial.print(&quot;Distance(m)\\t&quot;); for (byte pin=1; pin&lt;8; pin++) { float f_Distance = (float)ir_Distance[pin] / 1000000.0; Serial.print(&quot; &quot; + String(f_Distance, 4) + &quot;\\t&quot;); } Serial.println(); Serial.print(&quot;Displace.(m)\\t&quot;); for (byte pin=1; pin&lt;8; pin++) { float f_Displacemence = (float)ir_Displacemence[pin] / 1000000.0; Serial.print(&quot; &quot; + String(f_Displacemence, 4) + &quot;\\t&quot;); } Serial.println(); // using a = 2(s - v_0*t) / t^2 Serial.print(&quot;Accel.(m/s^2)\\t&quot;); for (byte pin=1; pin&lt;8; pin++) { //Serial.print(&quot; &quot; + String(initVelocity, 4) + &quot;\\t&quot;); float f_numerator = 2*(ir_Displacemence[pin]-(initVelocity*nowTime[pin])); //Serial.print(&quot; &quot; + String(f_numerator) + &quot;\\t&quot;); unsigned long l_numerator = (unsigned long)f_numerator; //Serial.print(&quot; &quot; + String(l_numerator) + &quot;\\t&quot;); float f_denominator = pow(nowTime[pin], 2) * pow(10, -6); //Serial.print(&quot; &quot; + String(f_denominator) + &quot;\\t&quot;); unsigned long l_denominator = (unsigned long)f_denominator; //Serial.print(&quot; &quot; + String(l_denominator) + &quot;\\t&quot;); acceleration[pin] = (float)l_numerator/(float)l_denominator; Serial.print(&quot; &quot; + String(acceleration[pin]) + &quot;\\t&quot;); } Serial.println(); for (byte pin=1; pin&lt;8; pin++) { sum_Accel = sum_Accel + acceleration[pin]; } float ave_Accel = sum_Accel / 7.0; Serial.print(&quot;Gravitational Acceleration = &quot;); Serial.print(ave_Accel); Serial.println(&quot; m/s^2&quot;); Serial.println(); Serial.println(); delay(1500);} ※ 스케치 내부에서 사용하는 시간과 거리의 단위는 소수 자리수 계산의 편의를 위해 microsecond, micrometer를 사용하며, 출력시에 second, meter 단위로 변환한다. 실험 결과예비 실험예비 실험은 파이프 없이 브레드 보드를 사용한 프로토 타입으로 실시하였다. 센서 간격이 원래의 계획보다 작기 때문에 아래와 같이 설정하였다. 입구부터 첫번째 센서까지의 거리 1.4cm, 각 센서간의 거리는 2.54cm이며, 6번째~7번째 센서의 간격만 3.33cm 이다. 12// for testing distance of 8 sensors in micrometer unitunsigned long ir_Distance[8] = {14000, 25400, 25400, 25400, 25400, 25400, 33300, 25400}; 브레드 보드에 배선을 하고 수직으로 세운 뒤, IR LED와 Phototansistor 사이에 스티로폼 공과 쇠구슬을 차례로 낙하시킨다. 질량이 다른 물체의 낙하 속도를 비교할 수 있다. 스티로폼 공은 집에 있는 스티로폼을 커터칼로 적당히 구 형태로 잘라낸 뒤, 손바닥과 바닥 사이에 놓고 손바닥에 살짝 힘을 주어 누르면서 돌돌 굴리면 스티로폼 공 형태를 쉽게 만들 수 있다. 결과스티로폼 공과 쇠구슬 2종류를 사용하였고, 몇 차례 시도한 결과 다음과 같은 결과가 나왔다. 센서 Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 NowTime(us) 1 35232 62407 81854 100329 117774 141384 141428 Interval(s) 0.035231 0.027075 0.019547 0.018475 0.017445 0.023610 0.000044 Distance(m) 0.0254 0.0254 0.0254 0.0254 0.0254 0.0254 0.0254 Displace.(m) 0.0254 0.0508 0.0762 0.1016 0.1270 0.1603 0.1857 Acceleration(m/s^2) 11.18 9.35 9.94 9.74 9.41 8.63 11.16 ∴ Gravitational Acceleration = 9.92 m/s² 문제점 및 해결 방법언제나 중력 가속도 9.81 m/s² 에 근접한 값이 나오는 것은 아니다. 낙하시키는 물체가 센서나 브레드보드에 닿지 않도록 조심스럽게 낙하시켜야 한다. 조금이라도 충돌이 일어나면 가속도 값이 전혀 다른 값으로 출력된다. 파이프를 사용하면 문제를 보완할 수 있을 것이다. 처음 물체를 잡고 낙하시키는 위치를 셋팅된 값과 일치시켜야 한다. 셋팅값보다 멀리서(위에서) 낙하시키면 중력 가속도 값이 커지고, 반대로 가까이서(아래에서) 낙하시키면 중력 가속도 값이 작아진다. 손에서 놓는 과정에서 발생하는 초기 속도의 오차는 지속적으로 발생한다. 되도록이면 낙하 물체를 살짝 잡은 상태에서 낙하시키도록 한다. 쇠구슬인 경우 전자석을 이용하거나, 솔레노이드 밸브 등의 사용을 고려할 필요가 있다. 실제 측정 장치이민O 학생과 황정O 학생이 제작한 측정 장치의 외형이다. 각 센서부를 보호하고 외형을 돋보이게 하는 틀을 3D프린터를 사용하여 직접 제작한 뒤 덧붙인 모습이다. 중앙에 18650 배터리를 내장한 ESP32를 덧붙여 제작하였다. 대체 가능 센서이 실험에서 사용한 IR LED와 Phototransistor의 조합은 여러가지 장점이 많지만, 배선이 복잡하다는 것은 제작하는 입장에서는 (특히 학생들이 제작을 한다면) 난감할 수 있다. 이럴 경우 다른 형태의 센서들로 대체할 수 있다. IRLED + Phototransistor 포토 인터럽터 금속 감지기 가격 저렴, 쉽게 구할 수 있음. 타오바오에서 1세트당 0.10.5위안 (약 20원100원) 센서 간격 35cm인 제품은 가격이 비쌈 (타오바오에서 2545위안) 구경 3cm인 제품의 경우 타오바오에서 18위안 (단, 3cm 초과 제품은 매우 비쌈) 종류 낙하물의 종류, 재질의 영향이 없다. (고정이 가능하면 파이프를 사용하지 않아도 되므로) 낙하물이 크기가 큰 경우에도 가능 낙하물의 종류, 재질의 영향이 없다.낙하물체의 길이가 5cm를 넘어가면 불가능 금속 낙하물만 가능낙하물체의 직경이 3cm 이내 추천 전류 사용 전류가 작으므로 배터리홀더가 내장된 ESP32를 사용할 경우, 별도의 전원장지 없이도 (컴퓨터와 연결하지 않고) 독립적으로 사용할 수 있다. 좌동 개당 전류값이 0.3A로 큰 편이다. 배선 저항을 2개 붙여야 하고, 배선이 복잡 간편 간편 실외 불가 불가 가능 기타 크기가 작은 것은 본 실험에 부적합구하기 어려움(단종여부 확인) 포토 인터럽터 TT Electronics OPB819Z 泰邦工控 TBGK E3S-GS30 금속 감지기 위 제품은 环形接近开关金属感应传感器이라는 이름으로 타오바오에서 판매하고 있는 금속감지센서이다. 구경 3cm (30mm孔径, NPN型) 정도인 제품까지는 저렴한 가격(18위안, 약 3,000원)에 구입할 수 있다. 생김새만 보아서는 가장 쉽게 제작할 수 있을 것 같다. 단, 낙하물은 금속을 사용해야하며, 적당한 크기의 금속 구슬을 사용하면 될 것 같다. 외경 3cm 투명 아크릴 파이프에 일정한 간격으로 테이프를 두껍게 감은 뒤 감지기를 끼우는 형태로 설치하면 될 것 같다.","link":"/2020/10/06/STEM-%EC%A4%91%EB%A0%A5-%EA%B0%80%EC%86%8D%EB%8F%84-%EC%B8%A1%EC%A0%95/"},{"title":"esp32 OpenWeatherMap에서 실시간 날씨 정보 받기","text":"OpenWeatherMap.orgOpenWeatherMap은 세계 각 지역의 현재 날씨, 예보, 과거 날씨 데이터를 제공하는 사이트입니다. (몇가지 제약이 있긴 하지만) 회원가입을 통해서 API Key를 생성하고 이를 통해 무료로 실시간 날씨 정보를 얻을 수 있습니다. Free Current weather and forecasts collection 60 Calls per minute (no more than) Current weather API 5 days/3 hour forecast API Weather maps 1.0 UV index Weather alerts Availability 95% Weather API data update &lt; 2 hours Weather maps data update &lt; 3 hours API lifetime support : Current version Historical weather collection은 모두 Starter 이상(유료) Current weather collections API Key 생성 Sign Up을 클릭하여 회원가입을 하고, Sign In을 클릭하여 로그인한 뒤, API Keys를 누릅니다. Default로 지정되어 있는 Key를 복사하거나, 새로운 Key를 생성합니다. API Key를 이용하는 방법은 메인홈페이지 메뉴의 API 탭을 누른뒤, 얻고자 하는 날씨정보(예를 들어 Current weather data)의 API doc을 참고하세요. 먼저 인터넷 브라우저를 통해 날씨정보가 어떻게 출력되는지 알아보기위하여 아래 홈페이지 주소에 접속해봅니다. 이때 주소의 끝부분에 있는 YOUR_API_KEY 대신 본인의 API Key를 입력합니다. 서울: https://api.openweathermap.org/data/2.5/weather?q=Seoul,KR&amp;units=metric&amp;APPID=YOUR_API_KEY 1https://api.openweathermap.org/data/2.5/weather?q=Seoul,KR&amp;units=metric&amp;APPID=1bf3d5e1bd2e5934aadd86.......... 런던: https://api.openweathermap.org/data/2.5/weather?q=London,GB&amp;units=metric&amp;appid=YOUR_API_KEY 1https://api.openweathermap.org/data/2.5/weather?q=London,GB&amp;units=metric&amp;APPID=1bf3d5e1bd2e5934aadd86.......... 상하이: https://api.openweathermap.org/data/2.5/weather?q=Shanghai,CN&amp;units=metric&amp;APPID=YOUR_API_KEY 1https://api.openweathermap.org/data/2.5/weather?q=Shanghai,CN&amp;units=metric&amp;APPID=1bf3d5e1bd2e5934aadd86.......... 브라우저에 출력되는 내용1{&quot;coord&quot;:{&quot;lon&quot;:-0.13,&quot;lat&quot;:51.51},&quot;weather&quot;:[{&quot;id&quot;:804,&quot;main&quot;:&quot;Clouds&quot;,&quot;description&quot;:&quot;overcast clouds&quot;,&quot;icon&quot;:&quot;04n&quot;}],&quot;base&quot;:&quot;stations&quot;,&quot;main&quot;:{&quot;temp&quot;:277.16,&quot;pressure&quot;:1007,&quot;humidity&quot;:86,&quot;temp_min&quot;:274.82,&quot;temp_max&quot;:279.26},&quot;visibility&quot;:8000,&quot;wind&quot;:{&quot;speed&quot;:5.1,&quot;deg&quot;:90},&quot;clouds&quot;:{&quot;all&quot;:90},&quot;dt&quot;:1574300635,&quot;sys&quot;:{&quot;type&quot;:1,&quot;id&quot;:1414,&quot;country&quot;:&quot;GB&quot;,&quot;sunrise&quot;:1574321288,&quot;sunset&quot;:1574352288},&quot;timezone&quot;:0,&quot;id&quot;:2643743,&quot;name&quot;:&quot;London&quot;,&quot;cod&quot;:200} 그밖의 도시 및 국가명은 Maps&gt; Weather maps를 클릭하여 표시되는 지도를 통해 확인할 수 있습니다. ESP32에서 사용하는 경우wifi 접속 설정12const char* ssid = &quot;your ssid&quot;; // 연결할 SSIDconst char* password = &quot;your password&quot;; // 연결할 SSID의 비밀번호 wifi에 접속하기 위한 ssid와 password를 설정 OpenWeatherMap.org 접속 설정12345const String endpoint = &quot;https://api.openweathermap.org&quot;;const String ver = &quot;/data/2.5/weather?q=&quot;;const String city = &quot;Shanghai,CN&quot;; // City,Country (띄어쓰기 금지)const String appid = &quot;&amp;units=metric&amp;APPID=&quot;; // Units: metricconst String key = &quot;1bf3d5e1bd2e5934aadd86..........&quot;; // API Key 날씨 데이터를 받아올 도시, 국가를 지정 (Shanghai,CN) (※주의: Shanghai,CN 사이에 띄어쓰기를 하면 안됨) key 변수에 본의 API Key를 입력 sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;WiFi.h&gt;#include &lt;HTTPClient.h&gt;const char* ssid = &quot;your ssid&quot;; // 연결할 SSIDconst char* password = &quot;your password&quot;; // 연결할 SSID의 비밀번호// OpenWeatherMap.org: Shanghai,CNconst String endpoint = &quot;https://api.openweathermap.org&quot;;const String ver = &quot;/data/2.5/weather?q=&quot;;const String city = &quot;Shanghai,CN&quot;; // City,Country (띄어쓰기 금지)const String appid = &quot;&amp;units=metric&amp;APPID=&quot;; // Units: metricconst String key = &quot;1bf3d5e1bd2e5934aadd86..........&quot;; // API Keyvoid setup() { Serial.begin(115200); delay(10); WiFi.begin(ssid, password); // 와이파이 연결 while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(&quot;Connecting to WiFi..&quot;); } Serial.println(&quot;Connected to the WiFi network&quot;);}// 연결 여부 로그 출력void loop() { if ((WiFi.status() == WL_CONNECTED)) { // Check the current connection status HTTPClient http; http.begin(endpoint + ver + city + appid + key); // Specify the URL int httpCode = http.GET(); // Make the request if (httpCode &gt; 0) { // Check for the returning code String json = http.getString(); // get JSON format data Serial.println(httpCode); Serial.println(json); } else { Serial.println(&quot;Error on HTTP request&quot;); } http.end(); // Free the resources } delay(30000); } 출력 DATA출력 데이터는 JSON(JavaScript Object Notation)을 기반으로 합니다. JSON은 프로그래밍 언어에 관계없이 데이터를 생성하고 읽을 수 있도록 만들어졌으며, 이를 통해 상호간에 보다 쉽게 데이터를 교환이 가능한 텍스트 기반의 데이터 교환 방식입니다. OpenWeatherMap에서도 이 방식을 사용하여 날씨 데이터를 생성하여 출력하고 있으며, 출력 데이터의 형태는 아래와 같습니다. 스케치 맨 아래라인의 delay 명령으로 인해 10초마다 1번씩 data를 출력합니다. 단, OpenWeatherMap free service의 update time이 2시간 이하로 되어 있으므로, 자료 갱신이 매 출력시마다 진행되지는 않습니다. Firefox 등의 몇몇 인터넷 브라우저에서는 JSON 데이터를 보다 직관적으로 이해할 수 있도록 계층별로 나누어 출력해주기도 합니다. JSON Parsing위와 같이 복잡한 형태로 출력되는 날씨 데이터 중에서 필요한 날씨 정보를 추출하기 위하여 JSON (JavaScript Object Notation) 파싱 과정을 거쳐야 하는데요. 이를 위해 아두이노 IDE에서 Json 파싱을 위한 라이브러리를 설치하여야 합니다. 라이브러리 설치ArduinoJson (by Benoit Blanchon) 라이브러리 (version 6)를 설치합니다. 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리 Memory pool 크기 계산 JSON 파싱에 사용할 배열의 크기를 계산하여 메모리를 확보합니다. 이를 위해 샘플로 사용할 JSON데이터가 필요하므로, 먼저 웹브라우저에서 OpenWeatherMap에 접속한 뒤, 1https://api.openweathermap.org/data/2.5/weather?q=Shanghai,CN&amp;units=metric&amp;APPID=1bf3d5e1bd2e5934aadd86.......... 출력되는 JSON 데이터를 드래그하여 복사합니다. 1{&quot;coord&quot;:{&quot;lon&quot;:-0.13,&quot;lat&quot;:51.51},&quot;weather&quot;:[{&quot;id&quot;:804,&quot;main&quot;:&quot;Clouds&quot;,&quot;description&quot;:&quot;overcast clouds&quot;,&quot;icon&quot;:&quot;04n&quot;}],&quot;base&quot;:&quot;stations&quot;,&quot;main&quot;:{&quot;temp&quot;:277.16,&quot;pressure&quot;:1007,&quot;humidity&quot;:86,&quot;temp_min&quot;:274.82,&quot;temp_max&quot;:279.26},&quot;visibility&quot;:8000,&quot;wind&quot;:{&quot;speed&quot;:5.1,&quot;deg&quot;:90},&quot;clouds&quot;:{&quot;all&quot;:90},&quot;dt&quot;:1574300635,&quot;sys&quot;:{&quot;type&quot;:1,&quot;id&quot;:1414,&quot;country&quot;:&quot;GB&quot;,&quot;sunrise&quot;:1574321288,&quot;sunset&quot;:1574352288},&quot;timezone&quot;:0,&quot;id&quot;:2643743,&quot;name&quot;:&quot;London&quot;,&quot;cod&quot;:200} https://arduinojson.org/assistant 에 접속한 뒤, Input란에 있는 내용을 모두 지우고 복사한 JSON데이터를 붙여넣기하면, Memory pool size가 자동으로 계산됩니다. Memory pool size의 Expression부분을 드래그하여 복사하고, Additional bytes for strings dubplucation 부분의 숫자를 이용하여 스케치에서 다음의 형식으로 변수를 생성합니다. 1const size_t capacity = JSON_ARRAY_SIZE(1) + JSON_OBJECT_SIZE(1) + 2*JSON_OBJECT_SIZE(2) + JSON_OBJECT_SIZE(4) + 2*JSON_OBJECT_SIZE(5) + JSON_OBJECT_SIZE(13) + 240; 실제로는 아래 Parsing Program에 이미 변수가 설정되어 있으므로, 이 과정은 수행하지 않아도 됩니다. Parsing program Memory pool size가 출력된 화면의 아래쪽에 Parsing program도 함께 출력됩니다. 우선 Parsing Program 전체를 복사한 뒤, 스케치의 void loop() 부분에 붙여넣기 합니다. 밑줄친 부분의 json 변수가 나타나 있는 라인을 모두 지우고 1const char* json = &quot;{\\&quot;coord\\&quot;:{\\&quot;lon\\&quot;:121.49,\\&quot;lat\\&quot;:31.23},\\&quot;weather\\&quot;:[{\\&quot;id\\&quot;:804,\\&quot;main\\&quot;:\\&quot;Clouds\\&quot;,\\&quot;description\\&quot;:\\&quot;overcast clouds\\&quot;,\\&quot;icon\\&quot;:\\&quot;04d\\&quot;}],\\&quot;base\\&quot;:\\&quot;stations\\&quot;,\\&quot;main\\&quot;:{\\&quot;temp\\&quot;:293.02,\\&quot;pressure\\&quot;:1027,\\&quot;humidity\\&quot;:55,\\&quot;temp_min\\&quot;:289.82,\\&quot;temp_max\\&quot;:298.71},\\&quot;visibility\\&quot;:10000,\\&quot;wind\\&quot;:{\\&quot;speed\\&quot;:3,\\&quot;deg\\&quot;:60},\\&quot;clouds\\&quot;:{\\&quot;all\\&quot;:94},\\&quot;dt\\&quot;:1574303919,\\&quot;sys\\&quot;:{\\&quot;type\\&quot;:1,\\&quot;id\\&quot;:9659,\\&quot;country\\&quot;:\\&quot;CN\\&quot;,\\&quot;sunrise\\&quot;:1574288762,\\&quot;sunset\\&quot;:1574326426},\\&quot;timezone\\&quot;:28800,\\&quot;id\\&quot;:1796236,\\&quot;name\\&quot;:\\&quot;Shanghai\\&quot;,\\&quot;cod\\&quot;:200}&quot;; OpenWeatherMap에서 실시간으로 받는 String 형식의 데이터 변수로 바꿔줍니다. 1String json = http.getString(); Timezone 반영을 위하여, 붙여넣기 한 Parsing program의 아래 부분에 아래 내용을 추가합니다. 123dt = dt + timezone; // for GMT+8 -&gt; +28800, for GMT+9 -&gt; +32400sys_sunrise = sys_sunrise + timezone;sys_sunset = sys_sunset + timezone; UNIX Timestamp로 표기되는 시간을 일반적인 날짜, 시간으로 표기되도록 변환해줍니다. 이를 위해서 timelib.h 파일을 이용해야하는데, 이 파일은 Time 라이브러리(by Michael Margolis)에 포함되어 있지요. 그러므로 라이브러리 매니저를 통해 Time라이브러리를 찾아 설치해줍니다. 1year(dt), month(dt), day(dt), hour(dt), minute(dt), second(dt), weekday(dt)); ​ 위의 스케치를 통해서 UTC를 YYYY.MM.DD HH:MM:SS(요일) 형태의 날짜를 변환하며, printf문을 통해 출력할 수 있습니다. Data 출력에 사용한 variablesJSON 형식의 데이터를 파싱할때 사용한 변수들입니다. 내용 형식 변수 unit UNIX Time(UTC) long dt Weather ID int weather_0_id Weather Main const char* weather_0_main Weather Description const char* weather_0_description Weather Icon ID const char* weather_0_icon Temperature float main_temp ℃ Temperature Max. float main_temp_max ℃ Temperature Min. float main_temp_min ℃ Pressure int main_pressure hPa Humidity int main_humidity % Visibility int visibility m Wind Speed int wind_speed m/s Wind Degree int wind_deg º Clouds int clouds_all Sunrise long sys_sunrise Sunset long sys_sunset City ID long id City name const char* name Country const char* sys_country Longitude float coord_lon º Latitude float coord_lat º GMT int timezone (※timezone/3600) hour int sys_type int sys_id Base const char* base COD int cod sketch: 전체위의 과정을 통해 만들진 부분 스케치를 병합하여 JSON 파싱을 위한 전체 스케치를 구성해봅니다. ArduinoJson 라이브러리의 경우 version 5와 6의 사용 문법이 조금 다릅니다. 현재 Arduino IDE에서 라이브러리 추가과정을 통해 다운로드 받을 수 있는 최신 라이브러리 버전이 ArduinoJson 6이므로, 이에 맞게 작성하여야합니다. (기존의 ArduinoJson 5에 맞게 작성된 스케치는 컴파일이 되지 않으므로, Migrating from version 5 to 6 문서를 참고하여 스케치를 변경해야 합니다.) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;WiFi.h&gt;#include &lt;HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;TimeLib.h&gt; const char* ssid = &quot;your ssid&quot;; // 연결할 SSIDconst char* password = &quot;your password&quot;; // 연결할 SSID의 비밀번호 const String endpoint = &quot;https://api.openweathermap.org&quot;;const String ver = &quot;/data/2.5/weather?q=&quot;;const String city = &quot;Shanghai,CN&quot;; // City,Country (띄어쓰기 금지)const String appid = &quot;&amp;units=metric&amp;APPID=&quot;; // Units: metricconst String key = &quot;1bf3d5e1bd2e5934aadd86..........&quot;; // API Keyunsigned long offset_days = 3; // 3 days for convert unix timestamp to datetimevoid setup() { Serial.begin(115200); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(&quot;Connecting to WiFi..&quot;); } Serial.println(&quot;Connected to the WiFi network&quot;);} void loop() { if ((WiFi.status() == WL_CONNECTED)) { // Check the current connection status HTTPClient http; http.begin(endpoint + ver + city + appid + key); // Specify the URL int httpCode = http.GET(); // Make the request if (httpCode &gt; 0) { // Check for the returning code // 데이터 파싱 const size_t capacity = JSON_ARRAY_SIZE(1) + JSON_OBJECT_SIZE(1) + 2*JSON_OBJECT_SIZE(2) + JSON_OBJECT_SIZE(4) + 2*JSON_OBJECT_SIZE(5) + JSON_OBJECT_SIZE(13) + 270; DynamicJsonDocument doc(capacity); String json = http.getString(); // get JSON format data deserializeJson(doc, json); float coord_lon = doc[&quot;coord&quot;][&quot;lon&quot;]; // 121.49 float coord_lat = doc[&quot;coord&quot;][&quot;lat&quot;]; // 31.23 JsonObject weather_0 = doc[&quot;weather&quot;][0]; int weather_0_id = weather_0[&quot;id&quot;]; // 804 const char* weather_0_main = weather_0[&quot;main&quot;]; // &quot;Clouds&quot; const char* weather_0_description = weather_0[&quot;description&quot;]; // &quot;overcast clouds&quot; const char* weather_0_icon = weather_0[&quot;icon&quot;]; // &quot;04d&quot; /* JsonObject weather_1 = weather[1]; int weather_1_id = weather_1[&quot;id&quot;]; // 701 const char* weather_1_main = weather_1[&quot;main&quot;]; // &quot;Mist&quot; const char* weather_1_description = weather_1[&quot;description&quot;]; // &quot;mist&quot; const char* weather_1_icon = weather_1[&quot;icon&quot;]; // &quot;50n&quot; JsonObject weather_2 = weather[2]; int weather_2_id = weather_2[&quot;id&quot;]; // 741 const char* weather_2_main = weather_2[&quot;main&quot;]; // &quot;Fog&quot; const char* weather_2_description = weather_2[&quot;description&quot;]; // &quot;fog&quot; const char* weather_2_icon = weather_2[&quot;icon&quot;]; // &quot;50n&quot; */ const char* base = doc[&quot;base&quot;]; // &quot;stations&quot; JsonObject main = doc[&quot;main&quot;]; float main_temp = main[&quot;temp&quot;]; // 293.02 int main_pressure = main[&quot;pressure&quot;]; // 1027 int main_humidity = main[&quot;humidity&quot;]; // 55 float main_temp_min = main[&quot;temp_min&quot;]; // 289.82 float main_temp_max = main[&quot;temp_max&quot;]; // 298.71 int visibility = doc[&quot;visibility&quot;]; // 10000 int wind_speed = doc[&quot;wind&quot;][&quot;speed&quot;]; // 3 int wind_deg = doc[&quot;wind&quot;][&quot;deg&quot;]; // 60 int clouds_all = doc[&quot;clouds&quot;][&quot;all&quot;]; // 94 long dt = doc[&quot;dt&quot;]; // 1574303919 JsonObject sys = doc[&quot;sys&quot;]; int sys_type = sys[&quot;type&quot;]; // 1 int sys_id = sys[&quot;id&quot;]; // 9659 //float sys_message = sys[&quot;message&quot;]; // Internal parameter (0.0226) const char* sys_country = sys[&quot;country&quot;]; // &quot;CN&quot; long sys_sunrise = sys[&quot;sunrise&quot;]; // 1574288762 long sys_sunset = sys[&quot;sunset&quot;]; // 1574326426 int timezone = doc[&quot;timezone&quot;]; // 28800 long id = doc[&quot;id&quot;]; // 1796236 const char* name = doc[&quot;name&quot;]; // &quot;Shanghai&quot; int cod = doc[&quot;cod&quot;]; // 200 dt = dt + timezone; // for GMT+8 -&gt; +28800, for GMT+9 -&gt; +32400 sys_sunrise = sys_sunrise + timezone; sys_sunset = sys_sunset + timezone; //int main_sea_level = main[&quot;sea_level&quot;]; // Atmospheric pressure hPa on the sea level //int main_grnd_level = main[&quot;grnd_level&quot;]; // Atmospheric pressure hPa on the ground level //int rain_1h = doc[&quot;rain&quot;][&quot;1h&quot;]; // Rain volume for the last 1 hour, mm //int rain_3h = doc[&quot;rain&quot;][&quot;3h&quot;]; // Rain volume for the last 3 hour, mm //int snow_1h = doc[&quot;snow&quot;][&quot;1h&quot;]; // Snow volume for the last 1 hour, mm //int snow_3h = doc[&quot;snow&quot;][&quot;3h&quot;]; // Snow volume for the last 3 hour, mm //데이터 출력 Serial.print(&quot;UNIX Time of Weather: &quot;); Serial.println(dt); Serial.printf(&quot;Time of Weather: %4d-%02d-%02d %02d:%02d:%02d(%1d)\\n&quot;, year(dt), month(dt), day(dt), hour(dt), minute(dt), second(dt), weekday(dt)); Serial.print(&quot;Weather ID: &quot;); Serial.println(weather_0_id); Serial.print(&quot;Weather Main: &quot;); Serial.println(weather_0_main); Serial.print(&quot;Weather Description: &quot;); Serial.println(weather_0_description); Serial.print(&quot;Weather Icon: &quot;); Serial.println(weather_0_icon); Serial.print(&quot;Temperature(℃): &quot;); Serial.println(main_temp); Serial.print(&quot;Temperature Max(℃): &quot;); Serial.println(main_temp_max); Serial.print(&quot;Temperature Min(℃): &quot;); Serial.println(main_temp_min); Serial.print(&quot;Pressure(hPa): &quot;); Serial.println(main_pressure); Serial.print(&quot;Humidity(%): &quot;); Serial.println(main_humidity); Serial.print(&quot;Visibility(m): &quot;); Serial.println(visibility); Serial.print(&quot;Wind Speed(m/s): &quot;); Serial.println(wind_speed); Serial.print(&quot;Wind Degree(º): &quot;); Serial.println(wind_deg); Serial.print(&quot;Clouds: &quot;); Serial.println(clouds_all); Serial.printf(&quot;Sunrise: %02d:%02d:%02d\\n&quot;, hour(sys_sunrise), minute(sys_sunrise), second(sys_sunrise)); Serial.printf(&quot;Sunset: %02d:%02d:%02d\\n&quot;, hour(sys_sunset), minute(sys_sunset), second(sys_sunset)); Serial.print(&quot;City/Country: &quot;); Serial.print(name); Serial.print(&quot;/&quot;); Serial.println(sys_country); Serial.print(&quot;longitude/latidude: &quot;); Serial.print(coord_lon); Serial.print(&quot;/&quot;); Serial.println(coord_lat); Serial.print(&quot;Timezone: GMT+&quot;); Serial.println(timezone/3600); /* Serial.print(&quot;Sea Level(hPa): &quot;); Serial.println(main_sea_level); Serial.print(&quot;Ground Level(hPa): &quot;); Serial.println(main_grnd_level); Serial.print(&quot;Rain 1h(mm): &quot;); Serial.println(rain_1h); Serial.print(&quot;Rain 3h(mm): &quot;); Serial.println(rain_3h); Serial.print(&quot;Snow 1h(mm): &quot;); Serial.println(snow_1h); Serial.print(&quot;Snow 3h(mm): &quot;); Serial.println(snow_3h); */ } else { Serial.println(&quot;Error on HTTP request&quot;); } http.end(); } delay(30000);} 출력 Data Weather Condition CodeGroup 2xx: Thunderstorm ID Main Description Icon 200 Thunderstorm thunderstorm with light rain 11d 201 Thunderstorm thunderstorm with rain 11d 202 Thunderstorm thunderstorm with heavy rain 11d 210 Thunderstorm light thunderstorm 11d 211 Thunderstorm thunderstorm 11d 212 Thunderstorm heavy thunderstorm 11d 221 Thunderstorm ragged thunderstorm 11d 230 Thunderstorm thunderstorm with light drizzle 11d 231 Thunderstorm thunderstorm with drizzle 11d 232 Thunderstorm thunderstorm with heavy drizzle 11d Group 3xx: Drizzle ID Main Description Icon 300 Drizzle light intensity drizzle 09d 301 Drizzle drizzle 09d 302 Drizzle heavy intensity drizzle 09d 310 Drizzle light intensity drizzle rain 09d 311 Drizzle drizzle rain 09d 312 Drizzle heavy intensity drizzle rain 09d 313 Drizzle shower rain and drizzle 09d 314 Drizzle heavy shower rain and drizzle 09d 321 Drizzle shower drizzle 09d Group 5xx: Rain ID Main Description Icon 500 Rain light rain 10d 501 Rain moderate rain 10d 502 Rain heavy intensity rain 10d 503 Rain very heavy rain 10d 504 Rain extreme rain 10d 511 Rain freezing rain 13d 520 Rain light intensity shower rain 09d 521 Rain shower rain 09d 522 Rain heavy intensity shower rain 09d 531 Rain ragged shower rain 09d Group 6xx: Snow ID Main Description Icon 600 Snow light snow 13d 601 Snow Snow 13d 602 Snow Heavy snow 13d 611 Snow Sleet 13d 612 Snow Light shower sleet 13d 613 Snow Shower sleet 13d 615 Snow Light rain and snow 13d 616 Snow Rain and snow 13d 620 Snow Light shower snow 13d 621 Snow Shower snow 13d 622 Snow Heavy shower snow 13d Group 7xx: Atmosphere ID Main Description Icon 701 Mist mist 50d 711 Smoke Smoke 50d 721 Haze Haze 50d 731 Dust sand/ dust whirls 50d 741 Fog fog 50d 751 Sand sand 50d 761 Dust dust 50d 762 Ash volcanic ash 50d 771 Squall squalls 50d 781 Tornado tornado 50d Group 800: Clear ID Main Description Icon 800 Clear clear sky 01d 01n Group 80x: Clouds ID Main Description Icon 801 Clouds few clouds: 11-25% 02d 02n 802 Clouds scattered clouds: 25-50% 03d 03n 803 Clouds broken clouds: 51-84% 04d 04n 804 Clouds overcast clouds: 85-100% 04d 04n ICON 출력방법Weather ID 801에 해당하는 아이콘 code가 02d이므로 URL을 다음과 같이 지정하면 1http://openweathermap.org/img/wn/10d.png ICON크기를 크게 출력하고 싶은 경우에는 아이콘 code에 @2x를 덧붙입니다. 1http://openweathermap.org/img/wn/10d@2x.png 1602 LCD에 날씨 정보 출력하기여러가지 날씨 정보 중에서 현재 온도를 1602 LCD(I2C)에 출력해보겠습니다. 라이브러리 설치하기스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리 LiquidCrystal I2C (by Frank de Brabander) 검색하여 설치 schematic sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;WiFi.h&gt;#include &lt;HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;TimeLib.h&gt;const char* ssid = &quot;your ssid&quot;; // 연결할 SSIDconst char* password = &quot;your password&quot;; // 연결할 SSID의 비밀번호 const String endpoint = &quot;https://api.openweathermap.org&quot;;const String ver = &quot;/data/2.5/weather?q=&quot;;const String city = &quot;Shanghai,CN&quot;; // City,Country (띄어쓰기 금지)const String appid = &quot;&amp;units=metric&amp;APPID=&quot;; // Units: metricconst String key = &quot;1bf3d5e1bd2e5934aadd86..........&quot;; // API Keyunsigned long offset_days = 3; // 3 days for convert unix timestamp to datetimefloat main_temp;// set the LCD#include &lt;LiquidCrystal_I2C.h&gt;int lcdColumns = 16;int lcdRows = 2;// set LCD address, number of columns and rows// if you don't know your display address, run an I2C scanner sketchLiquidCrystal_I2C lcd(0x27, lcdColumns, lcdRows); void setup() { Serial.begin(115200); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(&quot;Connecting to WiFi..&quot;); } Serial.println(&quot;Connected to the WiFi network&quot;); // initialize LCD lcd.init(); // turn on LCD backlight lcd.backlight();} void loop() { if ((WiFi.status() == WL_CONNECTED)) { // Check the current connection status HTTPClient http; http.begin(endpoint + ver + city + appid + key); // Specify the URL int httpCode = http.GET(); // Make the request if (httpCode &gt; 0) { // Check for the returning code // 데이터 파싱 const size_t capacity = JSON_ARRAY_SIZE(1) + JSON_OBJECT_SIZE(1) + 2*JSON_OBJECT_SIZE(2) + JSON_OBJECT_SIZE(4) + 2*JSON_OBJECT_SIZE(5) + JSON_OBJECT_SIZE(13) + 270; DynamicJsonDocument doc(capacity); String json = http.getString(); // get JSON format data deserializeJson(doc, json); float coord_lon = doc[&quot;coord&quot;][&quot;lon&quot;]; // 121.49 float coord_lat = doc[&quot;coord&quot;][&quot;lat&quot;]; // 31.23 JsonObject weather_0 = doc[&quot;weather&quot;][0]; int weather_0_id = weather_0[&quot;id&quot;]; // 804 const char* weather_0_main = weather_0[&quot;main&quot;]; // &quot;Clouds&quot; const char* weather_0_description = weather_0[&quot;description&quot;]; // &quot;overcast clouds&quot; const char* weather_0_icon = weather_0[&quot;icon&quot;]; // &quot;04d&quot; /* JsonObject weather_1 = weather[1]; int weather_1_id = weather_1[&quot;id&quot;]; // 701 const char* weather_1_main = weather_1[&quot;main&quot;]; // &quot;Mist&quot; const char* weather_1_description = weather_1[&quot;description&quot;]; // &quot;mist&quot; const char* weather_1_icon = weather_1[&quot;icon&quot;]; // &quot;50n&quot; JsonObject weather_2 = weather[2]; int weather_2_id = weather_2[&quot;id&quot;]; // 741 const char* weather_2_main = weather_2[&quot;main&quot;]; // &quot;Fog&quot; const char* weather_2_description = weather_2[&quot;description&quot;]; // &quot;fog&quot; const char* weather_2_icon = weather_2[&quot;icon&quot;]; // &quot;50n&quot; */ const char* base = doc[&quot;base&quot;]; // &quot;stations&quot; JsonObject main = doc[&quot;main&quot;]; float main_temp = main[&quot;temp&quot;]; // 293.02 int main_pressure = main[&quot;pressure&quot;]; // 1027 int main_humidity = main[&quot;humidity&quot;]; // 55 float main_temp_min = main[&quot;temp_min&quot;]; // 289.82 float main_temp_max = main[&quot;temp_max&quot;]; // 298.71 int visibility = doc[&quot;visibility&quot;]; // 10000 int wind_speed = doc[&quot;wind&quot;][&quot;speed&quot;]; // 3 int wind_deg = doc[&quot;wind&quot;][&quot;deg&quot;]; // 60 int clouds_all = doc[&quot;clouds&quot;][&quot;all&quot;]; // 94 long dt = doc[&quot;dt&quot;]; // 1574303919 JsonObject sys = doc[&quot;sys&quot;]; int sys_type = sys[&quot;type&quot;]; // 1 int sys_id = sys[&quot;id&quot;]; // 9659 //float sys_message = sys[&quot;message&quot;]; // Internal parameter (0.0226) const char* sys_country = sys[&quot;country&quot;]; // &quot;CN&quot; long sys_sunrise = sys[&quot;sunrise&quot;]; // 1574288762 long sys_sunset = sys[&quot;sunset&quot;]; // 1574326426 int timezone = doc[&quot;timezone&quot;]; // 28800 long id = doc[&quot;id&quot;]; // 1796236 const char* name = doc[&quot;name&quot;]; // &quot;Shanghai&quot; int cod = doc[&quot;cod&quot;]; // 200 dt = dt + timezone; // for GMT+8 -&gt; +28800, for GMT+9 -&gt; +32400 sys_sunrise = sys_sunrise + timezone; sys_sunset = sys_sunset + timezone; //int main_sea_level = main[&quot;sea_level&quot;]; // Atmospheric pressure hPa on the sea level //int main_grnd_level = main[&quot;grnd_level&quot;]; // Atmospheric pressure hPa on the ground level //int rain_1h = doc[&quot;rain&quot;][&quot;1h&quot;]; // Rain volume for the last 1 hour, mm //int rain_3h = doc[&quot;rain&quot;][&quot;3h&quot;]; // Rain volume for the last 3 hour, mm //int snow_1h = doc[&quot;snow&quot;][&quot;1h&quot;]; // Snow volume for the last 1 hour, mm //int snow_3h = doc[&quot;snow&quot;][&quot;3h&quot;]; // Snow volume for the last 3 hour, mm //데이터 출력 Serial.print(&quot;UNIX Time of Weather: &quot;); Serial.println(dt); Serial.printf(&quot;Time of Weather: %4d-%02d-%02d %02d:%02d:%02d(%1d)\\n&quot;, year(dt), month(dt), day(dt), hour(dt), minute(dt), second(dt), weekday(dt)); Serial.print(&quot;Weather ID: &quot;); Serial.println(weather_0_id); Serial.print(&quot;Weather Main: &quot;); Serial.println(weather_0_main); Serial.print(&quot;Weather Description: &quot;); Serial.println(weather_0_description); Serial.print(&quot;Weather Icon: &quot;); Serial.println(weather_0_icon); Serial.print(&quot;Temperature(℃): &quot;); Serial.println(main_temp); Serial.print(&quot;Temperature Max(℃): &quot;); Serial.println(main_temp_max); Serial.print(&quot;Temperature Min(℃): &quot;); Serial.println(main_temp_min); Serial.print(&quot;Pressure(hPa): &quot;); Serial.println(main_pressure); Serial.print(&quot;Humidity(%): &quot;); Serial.println(main_humidity); Serial.print(&quot;Visibility(m): &quot;); Serial.println(visibility); Serial.print(&quot;Wind Speed(m/s): &quot;); Serial.println(wind_speed); Serial.print(&quot;Wind Degree(º): &quot;); Serial.println(wind_deg); Serial.print(&quot;Clouds: &quot;); Serial.println(clouds_all); Serial.printf(&quot;Sunrise: %02d:%02d:%02d\\n&quot;, hour(sys_sunrise), minute(sys_sunrise), second(sys_sunrise)); Serial.printf(&quot;Sunset: %02d:%02d:%02d\\n&quot;, hour(sys_sunset), minute(sys_sunset), second(sys_sunset)); Serial.print(&quot;City/Country: &quot;); Serial.print(name); Serial.print(&quot;/&quot;); Serial.println(sys_country); Serial.print(&quot;longitude/latidude: &quot;); Serial.print(coord_lon); Serial.print(&quot;/&quot;); Serial.println(coord_lat); Serial.print(&quot;Timezone: GMT+&quot;); Serial.println(timezone/3600); /* Serial.print(&quot;Sea Level(hPa): &quot;); Serial.println(main_sea_level); Serial.print(&quot;Ground Level(hPa): &quot;); Serial.println(main_grnd_level); Serial.print(&quot;Rain 1h(mm): &quot;); Serial.println(rain_1h); Serial.print(&quot;Rain 3h(mm): &quot;); Serial.println(rain_3h); Serial.print(&quot;Snow 1h(mm): &quot;); Serial.println(snow_1h); Serial.print(&quot;Snow 3h(mm): &quot;); Serial.println(snow_3h); */ lcd.setCursor(0, 0); lcd.print(&quot;Temperature : &quot;); lcd.setCursor(0, 1); lcd.print(main_temp); } else { Serial.println(&quot;Error on HTTP request&quot;); } http.end(); } delay(30000); lcd.setCursor(0, 1); lcd.print(&quot; &quot;);} Arduino IDE에서 컴파일시 *””경고: 라이브러리 LiquidCrystal_I2C가 avr 아키텍처에서 실행되며 esp32아키텍처에서 실행되는 현재보드에서는 호환되지 않을 수 있습니다.””*라는 메세지가 나타나지만, LCD 출력에는 문제가 없습니다. 공공데이터 활용하기위의 방법을 응용하면 국가별, 관련 업체별로 제공되는 여러가지 공공데이터를 활용할 수 있습니다. 대기질 관련 데이터 : https://aqicn.org/api/ (한국)공공데이터포털 : https://www.data.go.kr/ (미국)공공데이터포털 : https://www.data.gov/ 그밖에 활용가능한 공공데이터가 어떤 것이 있는지, 살펴보세요~","link":"/2019/11/19/ESP32-OpenWeatherMap/"},{"title":"ESP32, OLED (한글 출력 하기)","text":"OLED종류ESP32나 Arduino에서 사용할 수 있는 oled의 종류는 매우 많지만, 주로 128*64 픽셀을 가진 0.96인치, 1.3인치의 SSD1306, SH1106 컨트롤러를 사용한 oled가 판매되고 있으며, 통신 프로토콜은 I2C나 SPI를 사용한다. oled 모듈 구입시 픽셀수, 컨트롤러 및 통신프로토콜을 잘 알아두어야 스케치 작성시 참고할 수 있음에 유의한다. I2C 방식은 GPIO를 2개만 사용하여 구성이 쉽다는 장점이 있고, SPI방식은 4~5개의 GPIO를 사용하지만 속도가 빠르다는 장점이 있다. 겉모습만으로는 컨트롤러를 확인하기는 어렵다. I2C SPI 이밖에도 U8g2 라이브러리에서 사용가능한 다양한 oled의 종류를 아래 링크에서 확인할 수 있다. Constructor Reference for U8g2 library SPI OLEDpinmap OLED ESP32 (HW_SPI로 사용시) (VSPI) (I2C겸용보드인 경우) GND GND VDD 3.3V D0 18 (HW_SPI 사용시 GPIO_18로 고정) SCK/CLK/CLOCK SCL D1 23 (HW_SPI 사용시 GPIO_23으로 고정) DATA/DIN/MOSI SDA RES 15 RST/RESET DC 14 Data Command CS 5 Chip Select ※ HW_SPI로 사용하는 경우에는 D0, D1의 핀번호를 바꿀 수 없으며, SW_SPI로 사용하는 경우에는 사용되는 모든 핀의 번호를 임의로 지정하여 사용할 수 있다. schematic SW_SPI 연결시에는 스케치에서 지정하는 GPIO핀에 연결한다. HW_SPI로 연결할 때의 회로도는 아래 그림과 같다. sketcholed를 SPI로 연결하는 경우, 다음을 추가해야 한다. 1#include &lt;SPI.h&gt; sketch: SH1106, HW_SPIHW_SPI를 사용하는 경우에는 D0(CLK), D1(MOSI)을 ESP32에 지정된 핀으로 사용하기 때문에, 나머지 3개의 핀만 sketch에서 지정해주면 된다. 12// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15); sketch: SH1106, SW_SPISW_SPI를 사용하는 경우, 4~5개의 핀을 sketch에 지정해주어야 한다. 12// for SW_SPIU8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15); sketch: SSD1306, HW_SPISSD1306을 사용하는 oled의 경우 U8G2_SH1106_~ 부분을 U8G2_SSD1306_~ 으로 수정하여 사용한다. 자세한 옵션은 Constructor Reference for U8g2 library에서 확인할 수 있다. 12// for HW_SPI (VSPI)U8G2_SSD1306_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15); sketch: SSD1306, SW_SPISW_SPI를 사용하는 경우, 4~5개의 핀을 sketch에 지정해주어야 한다. 12// for SW_SPIU8G2_SSD1306_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15); I2C OLEDpinmap OLED ESP32 GND GND VDD 3.3V SDA 21 (HW_I2C 사용시 GPIO_21로 고정) SCL 22 (HW_I2C 사용시 GPIO_22으로 고정) schematic sketchsketch: SH1106, HW_I2CHW_I2C를 사용하는 경우에는 SDA, SCL을 ESP32에 지정된 핀으로 사용하기 때문에, 구동 드라이버만 지정해주면 된다. 12// for SH1106, I2C, (ESP32: SDA 21, SCL 22)U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); sketch: SSD1306, HW_I2C12// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); U8g2 라이브러리ESP32나 Arduino에서 OLED를 사용을 위한 대표적인 라이브러리는 3~4가지 정도이다. U8glib U8g2 Adafruit SSD1306 UTF8_HanDraw 이들 중에서도 특히 U8glib와 Adafruit SSD1306 라이브러리가 가장 많이 사용되고 있다. 그렇지만 한글 출력이 쉽지 않다는 단점이 있으며, U8glib는 현재 개발이 중단된 상태이기도 하다. U8g2는 U8glib를 이어 새롭게 개발되는 라이브러리이며, U8glib의 기능을 모두 포함하고 있으므로 접근이 용이하다. 그러므로 여기서는 U8g2 라이브러리를 중심으로 ESP32에서 OLED를 사용하는 방법을 알아보고, 이에 더하여 한글 출력이 용이한 UTF8_HanDraw를 사용해보도록 한다. 사용 방법라이브러리 설치 스케치&gt; 라이브러리 포함하기&gt; 라이브러리 관리&gt; u8g2 검색 후 설치 클릭 U8g2 referenceU8g2 라이브러리 사용에 필요한 명령어들은 u8g2reference · olikraus/u8g2 Wiki · GitHub 를 참고한다. sketch SH1106 드라이버를 사용하여 HW_SPI로 OLED 출력을 수행할 경우, 아래와 같은 예제를 사용해볼 수 있다. 실제 사용하는 OLED 드라이버와 통신 프로토콜에 따라 sketch를 수정해서 사용해야 한다. 12345678910111213141516171819202122232425262728293031323334353637#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;// for SPI#include &lt;SPI.h&gt;// for using Korean NanumGothicCoding font//#include &quot;u8g2_font_unifont_t_korean_NanumGothicCoding_16.h&quot;// Please UNCOMMENT one of the contructor lines below// U8g2 Contructor List (Frame Buffer)// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SW_SPI//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);// for SH1106, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);void setup() { u8g2.begin(); u8g2.enableUTF8Print(); // enable UTF8 support for the Arduino print() function}void loop() { u8g2.firstPage(); do { u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.drawStr(0,15, &quot;SKS STEAM!&quot;); u8g2.drawTriangle(27,50, 64,32, 100,50); } while ( u8g2.nextPage() ); delay(1000);} 기본 사용 선언void setup() 내에 U8g2 라이브러리를 사용하여 oled를 사용하는 것을 선언 한다. 1u8g2.begin(); 폰트 폰트는 u8g2_font_ncenB14_tr를 사용하고 있는데, fntlist8 · olikraus/u8g2 Wiki · GitHub에서 글자 크기별로 사용 가능한 폰트 목록을 확인할 수 있다. 폰트명에 ncenB14가 포함되어 있으므로 폰트(세로) 픽셀수가 14 라는 것을 알 수 있다. 1u8g2.setFont(u8g2_font_ncenB14_tr); drawing sheet 사용하여, 그림 그려보기128X64 픽셀을 표시한 Drawing Sheet를 사용하여, 원하는 그림을 그려보자. Drawing Sheet drawStr1u8g2.drawStr(0,15, &quot;SKS STEAM!&quot;) drawStr를 통해 문자를 프린트할 수 있다. 예제에서 사용한 0,15는 프린트할 문자열 “SKS STEAM!“ 중 맨 앞글자인 “S“의 왼쪽 아래 시작 픽셀을 의미한다. 폰트사이즈가 14이므로 0,15 픽셀에서 시작하며, 0,1 픽셀까지 출력에 사용한다. 만약 시작 픽셀을 0,14로 바꾸면, 0,0 픽셀까지 출력하므로, 문자를 올바르게 출력할 수 있다. 만약 시작 픽셀을 0,13으로 2픽셀 위로 올리게되면 0,-1 픽셀까지 출력되므로, 글자의 맨 윗부분 1행 전체가 삭제된 상태로 출력된다. 음수(-)를 허용하므로, 이를 적절히 이용하면 가로방향 또는 세로방향 스크롤로 사용할 수 있다. drawTriangle1u8g2.drawTriangle(27,50, 64,32, 100,50); U8g2 라이브러리에서 삼각형을 그릴때 사용하는 명령어이다. 지정된 픽셀(128x64)내에 3쌍의 순서쌍으로 3개의 꼭지점을 지정하면 이에 맞춰 삼각형을 그린다. 여기서는 (27,50), (64,32), (100,50)이 꼭지점이다. ※ 그밖의 도형을 그리거나 글자 모양을 바꾸려면, u8g2reference · olikraus/u8g2 Wiki · GitHub 를 참고한다. 한글 사용하기U8g2 라이브러리에서 한글을 사용하려면, 한글 폰트를 사용하여야 한다. 기본적으로 제공되는 한글 폰트는 2가지가 있다. u8g2_font_unifont_t_korean1 : 사용가능한 글자가 제한되며, 용량이 17kB 정도 u8g2_font_unifont_t_korean2 : korean1폰트보다 사용가능한 글자수가 많으나, 용량이 70kB 정도 1u8g2.setFont(u8g2_font_unifont_t_korean2); 한글 사용을 위해 void setup()에 아래의 코드를 추가하여야 한다. 1u8g2.enableUTF8Print(); // enable UTF8 support for the Arduino print() function sketch: 한글 사용하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;// for SPI#include &lt;SPI.h&gt;// Please UNCOMMENT one of the contructor lines below// U8g2 Contructor List (Frame Buffer)// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SW_SPI//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);// for SH1106, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);void setup(void) { u8g2.begin(); u8g2.enableUTF8Print();}void loop(void) { u8g2.firstPage(); do { u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.drawStr(0, 15, &quot;SKS STEAM!&quot;); u8g2.drawTriangle(27,50, 64,32, 100,50); } while ( u8g2.nextPage() ); delay(1000); u8g2.firstPage(); do { //u8g2.setFont(u8g2_font_unifont_t_korean1); u8g2.setFont(u8g2_font_unifont_t_korean2); u8g2.setFontDirection(0); u8g2.clearBuffer(); u8g2.setCursor(0, 16); u8g2.print(&quot;Hello!&quot;); u8g2.setCursor(0, 40); u8g2.print(&quot;안녕하세요.&quot;); u8g2.sendBuffer(); } while ( u8g2.nextPage() ); delay(1000);} 나눔고딕폰트 사용하기 (한글의 모든 글자를 사용해야 할 경우) U8g2 라이브러리에서 사용할 나눔고딕 폰트를 다운로드 (created by xyz37) 한다. u8g2_font_unifont_t_korean_NanumGothicCoding_16.h ※ 주의! 폰트 크기가 1.09MB이므로 메모리가 작은 아두이노에서는 위 폰트를 사용하기 어렵지만, ESP32에서 사용할 수 있다. U8g2에서 제공하는 폰트인 korean1이 17k, korean2는 70k이므로 아두이노를 사용해야하는 경우는, (모든 한글 글자를 표현할 수 없더라도) korean1이나 korean2 폰트를 사용해야 한다. 다운로드 받은 나눔고딕 폰트 파일을 **”u8g2 라이브러리 폴더”**에 넣는다. u8g2 라이브러리 폴더의 위치를 모를 경우, 아래 그림과 같이 아두이노 IDE에서 파일&gt; 환경설정 에서 스케치북 위치를 확인한 후, ​ (스케치북 위치)/libraries/U8g2/src/ 폴더를 찾아, 폰트 파일을 넣는다. 위 폰트를 사용하려면 스케치에 다음을 포함해야 한다. 1#include &quot;u8g2_font_unifont_t_korean_NanumGothicCoding_16.h&quot; 1234void loop() { u8g2.setFont(u8g2_font_unifont_t_korean_NanumGothicCoding_16); } sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;// for SPI#include &lt;SPI.h&gt;// for using Korean NanumGothicCoding font#include &quot;u8g2_font_unifont_t_korean_NanumGothicCoding_16.h&quot;// Please UNCOMMENT one of the contructor lines below// U8g2 Contructor List (Frame Buffer)// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SW_SPI//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);// for SH1106, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);void setup(void) { u8g2.begin(); u8g2.enableUTF8Print();}void loop(void) { u8g2.firstPage(); do { u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.drawStr(0, 15, &quot;SKS STEAM!&quot;); u8g2.drawTriangle(27,50, 64,32, 100,50); } while ( u8g2.nextPage() ); delay(1000); u8g2.firstPage(); do { //u8g2.setFont(u8g2_font_unifont_t_korean1); //u8g2.setFont(u8g2_font_unifont_t_korean2); u8g2.setFont(u8g2_font_unifont_t_korean_NanumGothicCoding_16); u8g2.setFontDirection(0); u8g2.clearBuffer(); u8g2.setCursor(0, 16); u8g2.print(&quot;Hello!&quot;); u8g2.setCursor(0, 40); u8g2.print(&quot;안녕하세요.&quot;); u8g2.sendBuffer(); } while ( u8g2.nextPage() ); delay(1000);} 비트맵 그림/사진 출력하기OLED의 해상도(128×64)에 맞추어 그림이나 로고를 출력해보자. 윈도우 기준으로 설명하며, Mac의 경우 GIMP에서 비슷한 작업을 수행할 수 있다. 사진 or 로고 그림파일 준비사진 픽셀수 조정우선 oled에 출력하려는 작은 사진이나 로고 파일(.jpg or .png 등)을 준비한 뒤, 사용하는 oled의 해상도(예를들어 128×64) 고려하여 사진의 픽셀 수를 줄여야 한다. (※주의할 점: 화면상에 보이는 크기를 축소하는 것이 아니라 실제 픽셀수를 조정해야 함!) 윈도우에서 그림판을 연다. (그림판3D 아님!) : 시작&gt; Windows 보조프로그램&gt; 그림판 그림판 하단에 불러온 그림의 실제 픽셀수가 나타납니다. (픽셀수 오른쪽의 % 수치는 화면상에서 보이는 확대/축소 비율이므로, 여기서는 신경쓰지 않는다.) Ctrl-A를 눌러 전체 그림을 선택하면 그림 겉테두리에 점선이 표시되는데, 이때 (파란색 동그라미 표시된) 사진 오른쪽 상단 모서리의 포인트를 마우스로 클릭하여 픽셀사이즈를 원본 그림의 비율에 맞추어 128x64 이하로 조정한다. 예시에서는 1000x1000px, 즉 1:1의 비율 그림이므로 64x64로 조정하였다. 캔버스 크기를 나타내는 1000x1000px 왼쪽에, 축소되는 그림의 픽셀수가 나타나므로, 이를 확인하면서 픽셀수를 64x64로 조정하면 된다. 64x64px이 표시되어는 부분은, 마우스로 크기를 조정한 뒤에 클릭하고 있는 마우스 버튼에서 손을 떼는 순간 사라진다. (신경쓰지 않아도 됨) 중요! 위 그림처럼 축소된 작은 그림(전체 캔버스가 아님!)의 테두리에 점선이 남아 있는 상태에서 Ctrl-c를 눌러, 축소된 그림만 클립보드에 복사한다. 메뉴에서 파일&gt; 새로 만들기&gt;를 클릭한다. 이때, 변경내용을 저장하시겠습니까? 팝업이 뜨면 저장 안 함 클릭 (저장을 해도 관계없으나, 원본파일이 사라짐) 메뉴에서 파일&gt; 속성&gt; 을 클릭한 뒤 이미지 속성에서 단위를 픽셀로 지정하고, 너비와 높이를 oled의 전체 픽셀 사이즈(128x64)로 조정한다. 그림판에 128x64 크기의 캔버스가 나타난다. (화면상에 나타나는 크기가 너무 작아 확대/축소 비율을 100%로 조정함) 위 상태에서 Ctrl-v를 클릭하여, 클립보드에 복사한 그림을 붙여넣기 한다. 붙여넣은 그림을 마우스로 클릭하여 위치를 조정한다. 추가로 그림판의 텍스트 기능을 사용하여 글씨를 넣어보았다. 단색 1-bit 비트맵 bmp 파일로 저장하기 이제 작업한 파일을 1-bit 비트맵 bmp 파일로 저장한다. 파일&gt; 다른 이름으로 저장&gt; BMP 그림 을 클릭한 뒤, ) 저장할 경로와 파일이름을 지정한 뒤, 파일 형식을 *단색 비트맵(.bmp; *dlb)**으로 지정하여 저장한다. (사진 품질 저하에 대한 경고를 확인하면 최종 저장 된다.) 최종 결과물은 다음과 같다. (어피치 로고 bmp 파일 다운로드) ※ Mac에서는 GIMP를 이용하여 단색 비트맵 파일로 저장할 수 있다. ​ 링크 참고 - Creating monochrome bitmap files for LCD / GLIB using GIMP) 단색 bmp 파일을 hex파일로 변경하기프로그램 설치이제 아래와 같은 bitmap converter 프로그램을 사용하여, 단색 bmp 파일을 hex 파일로 변경한다. (여기서는 윈도우 기준으로 설명) 윈도우: LCD Assistant Mac: BitmapToC bmp → hex LCD Assistant를 실행한 후, File&gt; Load image&gt; 를 클릭하여 위에서 제작한 단색 bmp 파일을 연다. Byte orientation을 Horizontal로 변경한다. Size, Pixel/byte, Table name은 자동으로 지정되나, 만일 자동으로 설정되지 않는 경우, 아래와 같이 변경한다. Size: OLED 픽셀수 Pixel/byte: 8 Table name: 스케치내에서 사용할 이름 File&gt; Save output&gt; 를 클릭하여 파일을 저장한다. 이때 파일 형식을 별도로 지정하지 않으며, 사용할 파일이름에 .h 또는 .txt 를 덧붙여 구분하여도 된다. 예시에서는 apeach.h 로 지정하였다. 메모장이나 텍스트 에디터 등을 사용하여 apeach.h 파일을 열어보면, 단색 bmp 파일의 hex 코드를 볼 수 있다. 이제 이를 sketch에 반영하면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const unsigned char apeach [] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x10, 0x38, 0x00, 0xF0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x30, 0xC6, 0x01, 0x8C, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x21, 0x01, 0x02, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x21, 0x10, 0x84, 0x22, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x10, 0x84, 0x61, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x00, 0x84, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x00, 0x85, 0xF9, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x43, 0xFF, 0x86, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x01, 0xFF, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x20, 0x01, 0x55, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x20, 0x01, 0xD6, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x10, 0x00, 0x38, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x61, 0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x0F, 0xF0, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x18, 0x18, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x23, 0xC4, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x4C, 0x36, 0x90, 0x00, 0x24, 0x03, 0xD9, 0x9C, 0x0E, 0x07, 0xB0, 0xF3, 0x38, 0x00,0x00, 0x00, 0xD8, 0x1A, 0x90, 0x00, 0x24, 0x07, 0xF9, 0xFE, 0x1F, 0x8F, 0xF1, 0xF3, 0x7C, 0x00,0x00, 0x00, 0x93, 0xCB, 0xF0, 0x00, 0x28, 0x0E, 0x39, 0xC7, 0x31, 0x9C, 0x73, 0x83, 0x8C, 0x00,0x00, 0x00, 0xA6, 0x25, 0x30, 0x00, 0x28, 0x0C, 0x19, 0x83, 0x21, 0x98, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0xA4, 0x35, 0xD0, 0x00, 0x20, 0x0C, 0x19, 0x83, 0x7F, 0x98, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0xA4, 0x96, 0x10, 0x00, 0x20, 0x0C, 0x19, 0x83, 0x3E, 0x18, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0x97, 0x94, 0x10, 0xFC, 0x20, 0x0E, 0x39, 0xC7, 0x30, 0x9C, 0x73, 0x83, 0x0C, 0x00,0x00, 0x00, 0x90, 0x34, 0x10, 0x84, 0x20, 0x07, 0xF9, 0xFE, 0x3F, 0x8F, 0xF1, 0xF3, 0x0C, 0x00,0x00, 0x00, 0x48, 0x24, 0x10, 0x84, 0x20, 0x03, 0xD9, 0xBC, 0x0F, 0x07, 0xB0, 0xF3, 0x0C, 0x00,0x00, 0x00, 0x47, 0xCC, 0x11, 0x04, 0x40, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x30, 0x18, 0x09, 0x02, 0x40, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x1C, 0x30, 0x06, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; 스케치에 이미지 hex 코드 넣기sketch위에서 만든 어피치로고와 함께 학교로고를 추가로 만들고, 2개의 이미지를 OLED에 3초씩 출력하는 코드이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;#include &lt;SPI.h&gt; // for SPI// #include &quot;u8g2_font_unifont_t_korean_NanumGothicCoding_16.h&quot; // for using Korean NanumGothicCoding font// Please UNCOMMENT one of the contructor lines below// U8g2 Contructor List (Frame Buffer)// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SW_SPI//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);// for SH1106, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);const unsigned char apeach [] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x10, 0x38, 0x00, 0xF0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x30, 0xC6, 0x01, 0x8C, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x21, 0x01, 0x02, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x21, 0x10, 0x84, 0x22, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x10, 0x84, 0x61, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x00, 0x84, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x42, 0x00, 0x85, 0xF9, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x43, 0xFF, 0x86, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x40, 0x01, 0xFF, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x20, 0x01, 0x55, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x20, 0x01, 0xD6, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x10, 0x00, 0x38, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x61, 0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x0F, 0xF0, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x18, 0x18, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x23, 0xC4, 0x90, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,0x00, 0x00, 0x4C, 0x36, 0x90, 0x00, 0x24, 0x03, 0xD9, 0x9C, 0x0E, 0x07, 0xB0, 0xF3, 0x38, 0x00,0x00, 0x00, 0xD8, 0x1A, 0x90, 0x00, 0x24, 0x07, 0xF9, 0xFE, 0x1F, 0x8F, 0xF1, 0xF3, 0x7C, 0x00,0x00, 0x00, 0x93, 0xCB, 0xF0, 0x00, 0x28, 0x0E, 0x39, 0xC7, 0x31, 0x9C, 0x73, 0x83, 0x8C, 0x00,0x00, 0x00, 0xA6, 0x25, 0x30, 0x00, 0x28, 0x0C, 0x19, 0x83, 0x21, 0x98, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0xA4, 0x35, 0xD0, 0x00, 0x20, 0x0C, 0x19, 0x83, 0x7F, 0x98, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0xA4, 0x96, 0x10, 0x00, 0x20, 0x0C, 0x19, 0x83, 0x3E, 0x18, 0x33, 0x03, 0x0C, 0x00,0x00, 0x00, 0x97, 0x94, 0x10, 0xFC, 0x20, 0x0E, 0x39, 0xC7, 0x30, 0x9C, 0x73, 0x83, 0x0C, 0x00,0x00, 0x00, 0x90, 0x34, 0x10, 0x84, 0x20, 0x07, 0xF9, 0xFE, 0x3F, 0x8F, 0xF1, 0xF3, 0x0C, 0x00,0x00, 0x00, 0x48, 0x24, 0x10, 0x84, 0x20, 0x03, 0xD9, 0xBC, 0x0F, 0x07, 0xB0, 0xF3, 0x0C, 0x00,0x00, 0x00, 0x47, 0xCC, 0x11, 0x04, 0x40, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x30, 0x18, 0x09, 0x02, 0x40, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x1C, 0x30, 0x06, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};const unsigned char skslogo_1bit_128x64 [] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x64, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x76, 0x28, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40, 0x06, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x80, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x07, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x0E, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1E, 0x00, 0x07, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x3C, 0x00, 0x07, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3C, 0x00, 0x07, 0xF8, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7C, 0x00, 0x0F, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0xFC, 0x00, 0x01, 0xF0, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x0F, 0xE0, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xFF, 0xF0, 0x0F, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0xFF, 0xF8, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xC1, 0xFF, 0xFF, 0xFF, 0xC0, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xFF, 0x8D, 0xB1, 0xF8, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xC1, 0xFF, 0xB5, 0x26, 0xFC, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x9C, 0x73, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x03, 0xC3, 0xFF, 0xC4, 0x78, 0xFE, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x05, 0x41, 0xFF, 0x35, 0x26, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0xFF, 0x85, 0x90, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0x07, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x3F, 0xFF, 0x3F, 0xFE, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7F, 0xF8, 0x0F, 0xFE, 0x3F, 0xFC, 0x0F, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xE6, 0x7C, 0x03, 0xF8, 0xFF, 0xF8, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xF1, 0x7C, 0x00, 0x03, 0xFF, 0xF0, 0x1F, 0xA1, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xF3, 0xFE, 0x03, 0xFF, 0xFF, 0xE0, 0x3F, 0x37, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7B, 0xDF, 0x00, 0xFF, 0xFF, 0x80, 0x7F, 0x97, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7B, 0x67, 0x80, 0x3F, 0xFE, 0x00, 0xFA, 0xD7, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3F, 0xE7, 0xC0, 0x07, 0xF0, 0x01, 0xF9, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3E, 0x0F, 0xE0, 0x00, 0x00, 0x03, 0xF8, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x1F, 0x5C, 0xF8, 0x00, 0x00, 0x0F, 0xFB, 0x7C, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0F, 0x38, 0x7E, 0x00, 0x00, 0x1F, 0xB6, 0xBC, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x7F, 0x80, 0x00, 0xFF, 0x87, 0xB8, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0xCF, 0xF8, 0x07, 0xFB, 0x8F, 0xF0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x03, 0xED, 0xD3, 0xFF, 0xFF, 0xE3, 0x27, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xFA, 0xAB, 0xFF, 0xFF, 0x38, 0x73, 0xC0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xCE, 0x3F, 0xFE, 0xB9, 0xE7, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x15, 0x30, 0xFE, 0x37, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x0E, 0x31, 0xFE, 0xDE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xCD, 0x30, 0xEF, 0xDC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFB, 0xB0, 0xEF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFE, 0xE1, 0xD7, 0x6F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF9, 0xDA, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xBB, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};void setup(void) { u8g2.begin(); u8g2.enableUTF8Print();}void loop(void) { u8g2.firstPage(); do { u8g2.drawBitmap( 0, 0, 16, 64, apeach); } while(u8g2.nextPage()); delay(3000); u8g2.firstPage(); do { u8g2.drawBitmap( 0, 0, 16, 64, skslogo_1bit_128x64); } while(u8g2.nextPage()); delay(3000);} 센서값 출력하기DS18b20 온도센서pinmap OLED ESP32 (HW_SPI로 사용시) (VSPI) DS18b20 4.7kΩ GND GND VDD 3.3V D0 18 (HW_SPI 사용시 GPIO_18로 고정) SCK/CLK/CLOCK D1 23 (HW_SPI 사용시 GPIO_23으로 고정) DATA/DIN/MOSI RES 15 RST/RESET DC 14 Data Command CS 5 Chip Select GND GND (Black) 5V VCC (Red) O 13 Signal (Yellow) O schematic librarySketch&gt; Include Library&gt; Manage Libraries&gt; OneWire (by Jim Studt etc.) DallasTemperature (by Miles Burton) sketch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;// for SPI#include &lt;SPI.h&gt;// for using Korean NanumGothicCoding font// #include &quot;u8g2_font_unifont_t_korean_NanumGothicCoding_16.h&quot;// Please UNCOMMENT one of the contructor lines below// U8g2 Contructor List (Frame Buffer)// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected// for HW_SPI (VSPI)U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SW_SPI//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 26, /* data=*/ 25, /* cs=*/ 5, /* dc=*/ 14, /* reset=*/ 15);// for SSD1306, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);// for SH1106, I2C, (ESP32: SDA 21, SCL 22)//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 13OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);unsigned long startTime = 0;const unsigned char skslogo_1bit_128x64 [] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x64, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x76, 0x28, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40, 0x06, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x80, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x07, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x0E, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1E, 0x00, 0x07, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x3C, 0x00, 0x07, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3C, 0x00, 0x07, 0xF8, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7C, 0x00, 0x0F, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0xFC, 0x00, 0x01, 0xF0, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x0F, 0xE0, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xFF, 0xF0, 0x0F, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0xFF, 0xF8, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xC1, 0xFF, 0xFF, 0xFF, 0xC0, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xFF, 0x8D, 0xB1, 0xF8, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xC1, 0xFF, 0xB5, 0x26, 0xFC, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x9C, 0x73, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x03, 0xC3, 0xFF, 0xC4, 0x78, 0xFE, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x05, 0x41, 0xFF, 0x35, 0x26, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0xFF, 0x85, 0x90, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0x07, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x3F, 0xFF, 0x3F, 0xFE, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7F, 0xF8, 0x0F, 0xFE, 0x3F, 0xFC, 0x0F, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xE6, 0x7C, 0x03, 0xF8, 0xFF, 0xF8, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xF1, 0x7C, 0x00, 0x03, 0xFF, 0xF0, 0x1F, 0xA1, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0xF3, 0xFE, 0x03, 0xFF, 0xFF, 0xE0, 0x3F, 0x37, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7B, 0xDF, 0x00, 0xFF, 0xFF, 0x80, 0x7F, 0x97, 0x80, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x7B, 0x67, 0x80, 0x3F, 0xFE, 0x00, 0xFA, 0xD7, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3F, 0xE7, 0xC0, 0x07, 0xF0, 0x01, 0xF9, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x3E, 0x0F, 0xE0, 0x00, 0x00, 0x03, 0xF8, 0xFE, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x1F, 0x5C, 0xF8, 0x00, 0x00, 0x0F, 0xFB, 0x7C, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0F, 0x38, 0x7E, 0x00, 0x00, 0x1F, 0xB6, 0xBC, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x7F, 0x80, 0x00, 0xFF, 0x87, 0xB8, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0xCF, 0xF8, 0x07, 0xFB, 0x8F, 0xF0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x03, 0xED, 0xD3, 0xFF, 0xFF, 0xE3, 0x27, 0xE0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x01, 0xFA, 0xAB, 0xFF, 0xFF, 0x38, 0x73, 0xC0, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xCE, 0x3F, 0xFE, 0xB9, 0xE7, 0x80, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x15, 0x30, 0xFE, 0x37, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x0E, 0x31, 0xFE, 0xDE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xCD, 0x30, 0xEF, 0xDC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFB, 0xB0, 0xEF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFE, 0xE1, 0xD7, 0x6F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF9, 0xDA, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xBB, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};void setup(void) { u8g2.begin(); u8g2.enableUTF8Print(); u8g2.firstPage(); do { u8g2.drawBitmap( 0, 0, 16, 64, skslogo_1bit_128x64); } while(u8g2.nextPage()); delay(3000); u8g2.firstPage(); do { u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.drawStr(0, 15, &quot;SKS STEAM!&quot;); u8g2.drawTriangle(27,50, 64,32, 100,50); } while ( u8g2.nextPage() ); delay(3000); startTime = millis(); // Start up the DS18b20 library sensors.begin();}void loop(void) { unsigned long ttime = millis(); sensors.requestTemperatures(); float temperatureC = sensors.getTempCByIndex(0); float temperatureF = sensors.getTempFByIndex(0); u8g2.firstPage(); do { //u8g2.setFont(u8g2_font_unifont_t_korean1); u8g2.setFont(u8g2_font_unifont_t_korean2); //u8g2.setFont(u8g2_font_unifont_t_korean_NanumGothicCoding_16); // Title u8g2.setCursor(8, 14); u8g2.print(&quot;[[ 온도측정 ]]&quot;); // actual time measured. (1초 마다 출력되지는 않음) u8g2.setCursor(0, 31); u8g2.print(&quot;시간: &quot;); u8g2.setCursor(63, 31); u8g2.print(getTime(ttime)); // Celcius temperature u8g2.setFont(u8g2_font_unifont_t_korean2); u8g2.setCursor(0, 47); u8g2.print(&quot;섭씨: &quot;); u8g2.setFont(u8g2_font_unifont_tf); if(temperatureC&lt;100) { u8g2.setCursor(71, 47); } else { u8g2.setCursor(63, 47); } u8g2.print(temperatureC, 2); u8g2.drawGlyph(111, 47, 0x00b0); // degree u8g2.drawStr(119, 47, &quot;C&quot;); // Fahrenheit temperature u8g2.setFont(u8g2_font_unifont_t_korean2); u8g2.setCursor(0, 63); u8g2.print(&quot;화씨: &quot;); u8g2.setFont(u8g2_font_unifont_tf); if(temperatureF&lt;100) { u8g2.setCursor(71, 63); } else { u8g2.setCursor(63, 63); } u8g2.print(temperatureF, 2); u8g2.drawGlyph(111, 63, 0x00b0); // degree u8g2.drawStr(119, 63, &quot;F&quot;); } while ( u8g2.nextPage() ); delay(1000);}String getTime(unsigned long ttime) { int sec = ttime / 1000; int min = sec / 60; int hr = min / 60; String ts = &quot;&quot;; // 시간 if (hr &lt; 10) ts += &quot;0&quot;; ts += hr; ts += &quot;:&quot;; // 분 if ((min % 60) &lt; 10) ts += &quot;0&quot;; ts += min % 60; ts += &quot;:&quot;; // 초 if ((sec % 60) &lt; 10) ts += &quot;0&quot;; ts += sec % 60; return (ts);} result UTF8_HanDraw 라이브러리 한글 출력하기ESP32 SPIFFS 영역에 폰트 업로드 SPIFFS란? **SPIFFS(Serial Peripheral Interface Flash File System)**는 ESP32와 ESP8266의 모듈에 내부 탑재 되어 있는 메모리를 저장공간으로 사용하기 위한 파일 시스템이다. ESP8266과 ESP32에는 보통 4MByte의 메모리가 탑재되어 있으며 이 메모리의 일부를 플래쉬 메모리로 사용하고 나머지를 파일 저장공간으로 사용할 수가 있다. 작은 용량의 SD카드가 내장이 되었다고 생각하면 이해하기 쉽다. 아두이노에서의 SPIFFS의 이용 아두이노 IDE에는 이 메모리의 분리를 설정할 수 있는 메뉴가 있다. 아두이노IDE에서 아래의 항목을 설정하는 것 만으로 스케치를 업로드하면 영역이 분할되어 스케치가 업로드 된다. 툴&gt; Partition Scheme&gt; Default 4MB with spiffs (1.2MB APPS / 1.5MB SPIFFS) 기본설정은 위와 같지만 SPIFFS 용량이 부족하다면, **위 메뉴에서 ** **No OTA(1MB APP/3MB SPIFFS)**와 같은 다른 설정을 선택하여, 코딩이 들어가는 플래쉬 메모리를 1MByte를 사용하고, 나머지 3MByte의 SPIFFS영역에는 코딩에서 필요한 자료(예를 들면 그림파일이나 텍스트 파일등)을 업로드 하고 코딩에서 그 파일을 사용하면 됩니다. 아두이노 우노의 플래쉬메모리가 32KByte인 것을 고려하면 ESP32에 플래쉬 메모리를 1MByte만 할당 하는 것도 적지 않은 할당이지만, ESP32의 고급기능(WIFI, 블루투스)등을 사용하면 이 메모리도 모자라게 되는 경우도 있다. 아두이노 IDE에 SPIFFS 설정하기 아두이노 IDE에서 ESP32의 SPIFFS영역에 파일을 올리기 위해서는 별도의 툴을 설치하여야 한다. 아래의 링크를 클릭하여 ESP32FS-1.0.zip 파일을 다운로드 받은 뒤, https://github.com/me-no-dev/arduino-esp32fs-plugin/releases/ 압축을 풀어 나오는 ESP32FS폴더를 아두이노 설치 폴더 내의 tools폴더 아래에 복사한다. 예를들면, c:\\Program Files (x86)\\Arduino\\tools\\ESP32FS\\tool\\esp32fs.jar 같은 형태로 파일 경로가 만들어져야 한다. 아두이노IDE를 종료하였다가 다시 실행시키면 툴&gt; ESP32 Sketch Data Upload 항목이 만들어진다. SPIFFS에 (폰트) 파일 업로드하기 기본적으로 ESP32의 SPIFFS에 파일을 업로드 하기 위해서는, 업로드하려는 스케치(.ino) 파일이 위치한 폴더에 data폴더를 생성한 뒤, 업로드하려는 파일을 복사해 넣으면 된다. 그러므로 이번 과정에서 SPIFFS에 (폰트)파일을 업로드하려면, (폰트) 파일을 업로드하려는 스케치(UTF8_HanDraw.ino)가 저장되어 있는 폴더 안에, (UTF8_HanDraw.zip 파일의 압축을 풀었을때 만들어진) data폴더를 복사해 넣으면 된다. 아두이노 IDE에 스케치를 열고, 메뉴에 추가된 ESP32 Sketch Data Upload를 클릭하면, 스케치 파일은 컴파일 후 APP영역에 저장되고, Data폴더안의 (폰트) 파일은 SPIFFS영역에 분리되어 저장된다. schematic OLED (I2C) ESP32 if, Arduino UNO GND GND GND VCC 3V3 3V3 SCL 22 A5 SDA 21 A4 sketch출처: [OLED에 한글을 출력하자 by Andy Kim (andy-power.blogspot.com)](Andy Kim: OLED에 한글을 출력하자. (andy-power.blogspot.com)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;Arduino.h&gt;#include &quot;Display_SSD1306.h&quot;#include &quot;HanDraw.h&quot;#define OLED_RESET -1 // for S/W 리셋Display_SSD1306 Oled(OLED_RESET);/************************* Global variables *********************************/unsigned long startTime = 0;uint32_t loopcnt = 0;char fpsbuf[128] = &quot;FPS:&quot;;bool invert = true; // 화면을 역상으로 표시void setup() { Serial.begin(115200); delay(50); // Oled를 I2C 방식으로 연결하고, 그 주소는 0x3c Oled.begin(SSD1306_SWITCHCAPVCC, 0x3C, false); // Callback 함수를 설정해 주면 필요시 호출 하여 사용함. HanDraw.begin(12, // 화면 지우는 콜백함수 [](void) { Oled.clearDisplay(); }, // 1개 픽셀을 그리는 콜백 함수 [](int16_t x, int16_t y, uint16_t color) { Oled.drawPixel(x, y, color); }, // 메모리에서 Display 표시 버퍼까지 보내는 함수 [](void) { Oled.display(); } ); HanDraw.display(); // 사실상 Oled.display() 와 동일.... delay(2000); HanDraw.clear(); HanDraw.setFontSize(12); // 특수한 문자 몇개는... 아래와 같이 주면 출력된다. (통용되는 코드가 아니라 변칙 코드임) // 12px:한글 21℃℉‰μ° 라고 출력 HanDraw.drawString(1, 0, &quot;12px:한글 21\\x10\\x0f\\x11\\x12\\x13&quot;); HanDraw.setFontSize(14); // 14:아래첨자 A₁₂₃₄ 라고 출력 HanDraw.drawString(1, 13, &quot;14:아래첨자 A\\x0b\\x0c\\x0d\\x0e&quot;); HanDraw.setFontSize(16); // 16:위첨자 M¹²³⁴ 라고 출력 HanDraw.drawString(1, 28, &quot;16:위첨자 M\\x15\\x16\\x17\\x18&quot;); HanDraw.display(); delay(3000); HanDraw.setFontSize(12); startTime = millis(); delay(1); Serial.println(&quot;Setup All done&quot;);}String getTime(unsigned long ttime) { int sec = ttime / 1000; int min = sec / 60; int hr = min / 60; String ts = &quot;&quot;; if (hr &lt; 10) ts += &quot;0&quot;; ts += hr; ts += &quot;:&quot;; if ((min % 60) &lt; 10) ts += &quot;0&quot;; ts += min % 60; ts += &quot;:&quot;; if ((sec % 60) &lt; 10) ts += &quot;0&quot;; ts += sec % 60; return (ts);}void loop() { unsigned long ttime = millis(); dtostrf(loopcnt * 1000.0 / (ttime - startTime), 5, 2, fpsbuf + 4); HanDraw.clear(); HanDraw.drawString(15, 2, &quot;[[ 화면 정보 ]]&quot;); HanDraw.drawString(2, 14, &quot;--------------------&quot;); HanDraw.drawString(2, 24, &quot;한글 출력 테스트&quot;); HanDraw.drawString(2, 38, fpsbuf); HanDraw.drawString(2, 51, getTime(ttime)); HanDraw.display(); loopcnt++; if (loopcnt % 100 == 0) { Oled.invertDisplay(invert); invert = !invert; }} OLED에 DS18b20 온도 출력하기schematic OLED (I2C) ESP32 DS18b20 4.7kΩ GND GND BLK VCC 3V3 SCL 33 SDA 32 5V RED O GPIO13 YELLOW O librarySketch&gt; Include Library&gt; Manage Libraries&gt; OneWire (by Jim Studt etc.) DallasTemperature (by Miles Burton) sketch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;Arduino.h&gt;#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;#define TEMP_PIN 13OneWire oneWire(TEMP_PIN);DallasTemperature sensors(&amp;oneWire);#include &quot;Display_SSD1306.h&quot;#include &quot;HanDraw.h&quot;#define OLED_RESET -1 // for S/W 리셋Display_SSD1306 Oled(OLED_RESET);/************************* Global variables *********************************/unsigned long startTime = 0;uint32_t loopcnt = 0;char fpsbuf[128] = &quot;FPS:&quot;;char tC[128];char tF[128];bool invert = true; // 화면을 역상으로 표시void setup() { Serial.begin(115200); delay(50); // Oled를 I2C 방식으로 연결하고, 그 주소는 0x3c Oled.begin(SSD1306_SWITCHCAPVCC, 0x3C, false); // Callback 함수를 설정해 주면 필요시 호출 하여 사용함. HanDraw.begin(12, // 화면 지우는 콜백함수 [](void) { Oled.clearDisplay(); }, // 1개 픽셀을 그리는 콜백 함수 [](int16_t x, int16_t y, uint16_t color) { Oled.drawPixel(x, y, color); }, // 메모리에서 Display 표시 버퍼까지 보내는 함수 [](void) { Oled.display(); } ); startTime = millis(); delay(1); // Start up the DS18b20 library sensors.begin();}void loop() { unsigned long ttime = millis(); dtostrf(loopcnt * 1000.0 / (ttime - startTime), 5, 2, fpsbuf + 4); sensors.requestTemperatures(); float temperatureC = sensors.getTempCByIndex(0); float temperatureF = sensors.getTempFByIndex(0); dtostrf(temperatureC, 6, 2, tC); String tempC = &quot;섭씨온도 * &quot; + (String)tC + &quot;\\x10&quot;; dtostrf(temperatureF, 6, 2, tF); String tempF = &quot;화씨온도 * &quot; + (String)tF + &quot;\\x0f&quot;; HanDraw.display(); HanDraw.clear(); HanDraw.setFontSize(12); HanDraw.drawString(15, 2, &quot;[[ 온도 측정 ]]&quot;); HanDraw.drawString(2, 14, &quot;--------------------&quot;); HanDraw.drawString(2, 24, getTime(ttime)); HanDraw.drawString(2, 38, tempC); HanDraw.drawString(2, 51, tempF); HanDraw.display();}String getTime(unsigned long ttime) { int sec = ttime / 1000; int min = sec / 60; int hr = min / 60; //String ts = &quot;&quot;; String ts = &quot;측정시간 * &quot;; if (hr &lt; 10) ts += &quot;0&quot;; ts += hr; ts += &quot;:&quot;; if ((min % 60) &lt; 10) ts += &quot;0&quot;; ts += min % 60; ts += &quot;:&quot;; if ((sec % 60) &lt; 10) ts += &quot;0&quot;; ts += sec % 60; return (ts);}","link":"/2021/09/26/ESP32-OLED/"},{"title":"알코올 램프 안전 손잡이 받침대 3D프린팅","text":"학교에서 알코올 램프를 사용할 때 겪는 불편한 문제 중 하나. 삼발이가 뜨거워져서 알코올 램프를 끌 때, 손 등 부분이 삼발이에 닿아서 데이기 쉽다는 것이다. 이 때문에 한국에서는 알코올 램프를 끼워 안전하게 쓸 수 있는 받침대를 구입하여 사용하곤 했다. 그런데 온갖 잡동사니를 다 팔고 있는 중국 타오바오를 아무리 뒤져보아도 막상 이런 형태의 알코올 램프 받침대를 찾을 수가 없었다. 그동안 사용했던 받침대들이 깨지고, 열에 의해 변형되어 새로 구입을 하기는 해야하는데, 어떻게 할까 생각하다가… STL파일 제작STEAM 활동을 하고 있는 학생을 통해 3d 프린팅을 하기로 했다. 아래 그림이 황정○ 학생이 설계한 STL파일이다. 구조 알코올 램프를 끼워 넣은 후, 손잡이를 통해 쉽게 옮길 수 있도록 되어 있다. 알코올 램프가 잘 빠지지 않는 경우, 밑면에 뚫려 있는 구멍을 통해 위쪽으로 램프를 밀어내어 뺄 수 있도록 하였고, 한쪽 옆면에는 렘프에 남아있는 알코올의 잔량을 쉽게 확인할 수 있도록 구멍을 만들어 놓았다. 3D 프린팅한 제품 영롱하다.","link":"/2021/11/15/STEM-%EC%95%8C%EC%BD%94%EC%98%AC-%EB%9E%A8%ED%94%84-%EB%B0%9B%EC%B9%A8%EB%8C%80/"},{"title":"ESP32, RC카","text":"샤시 조립샤시 부품 번호 부품 사진 수량 용도 및 참고사항 1 전륜 회전축 2 2 베어링(대) 2 3 스티어링 컵 2 4 커플러 고정핀 2 5 베어링(중) 2 6 (전륜) 육각 커플러 2 7 휠 4 8 나이록 너트(M4) 2 9 십자형 육각 복스 1 10 볼 조인트 커넥팅 로드 1 홀 간격 80.5mm 유지 11 볼 조인트 커넥팅 로드 1 홀 간격 51mm 유지 12 서보모터MG996R 1 13 ㄴ자 서보모터 브라켓 2 14 휠 베이스 고정판 2 15 서보 혼 1 (볼트 포함) 16 나이록 너트(M2.5) 1 17 샤시 하판 1 18 DC엔코더 모터 &amp; 커넥터 2 19 모터 브라켓 2 20 샤프트 2 21 써클립 2 22 샤프트 베어링 4 23 기어(무두볼트(Set Screw) 포함) 2 24 육각 샤프트 커플링 커넥터 2 25 범퍼 1 26 샤시 상판 1 27 락스위치 1 28 황동 육각 스터드(M3×22mm) 6 휠 베이스 고정용 4개, 상판 고정용 2개 29 황동 육각 스터드(M3×16mm) 2 범퍼 고정용 2개 30 볼트(Pan head, M4×6mm) 6 모터 브라켓과 샤시 하판 고정용 6개 31 볼트(Bind-Washer head, M3×6mm) 10 서보모터와 서보모터 브라켓 고정용 4개, 서보모터 브라켓과 샤시하판 고정용 4개, 범퍼 고정용 2개 32 볼트(Bind head, M3×8mm) ![`](/image/r/ESP32-RC-Car-30.png) 14 육각 스터드 고정용 12개, 범퍼 고정용 2개 33 볼트(Pan head, M2.5×10mm) 7 커넥팅 로드 연결용 3개, 휠 베이스 연결용 4개 34 볼트(Flat head, M2.5×5mm) 4 모터와 모터브라켓 고정 35 육각렌치 1 기어 무두볼트용 36 저항1K or 5.1K 2 (선택사항) 인코더 풀업저항 37 홀센서 칩SH41F(SOT-23타입) 2 (선택사항) 홀 센서를 이중채널로 사용할 필요가 있는 경우에, 각 모터마다 1개씩 추가함 총 36종 전륜 조향 휠 조립사진 오른쪽부터 차례대로 8개의 부품을 끼워 휠을 조립한다. (왼쪽휠/오른쪽휠 각각 1개씩, 총 2개 조립) 먼저 검은색의 스티어링 컵에 큰 베어링을 삽입한다. (상당히 뻑뻑하므로 힘을 강하게 주면서 스티어링컵 안쪽 끝까지 밀어넣어야 한다.) 베어링이 장착된 스티어링 컵에 회전축을 끼운다. 이때, 회전축 중앙에 있는 작은 구멍이 (고정쇠를 끼울 수 있도록) 보여야 하며, 만약 구멍이 보이지 않으면, 이전 과정에서 베어링을 더 밀어넣어 스티어링 컵에 완전히 밀착시켜야 한다. 회전축이 나온 스티어링컵 밑바닥에 중간 크기의 베어링을 끼운다. 역시 뻑뻑하므로 강한 힘을 주어 밀어넣어야 한다. 회전축 중앙의 작은 구멍에 커플러 고정핀를 끼워 넣는다. 커플러 고정핀 끼워 넣는 홈이 파인 육각 커플러를 준비한 뒤, 커플러 고정핀이 꼽혀있는 방향을 고려하여 스티어링컵에 끼운다. 스티어링컵에 끼운 육각 커플러를, 휠의 안쪽에 끼워 넣으면(이때, 육각 커플러가 휠의 육각 홈 안쪽까지 완전히 밀착되도록 강한 힘을 가하면서 끼운다.) 휠 바깥쪽면에 회전축의 나사산이 나온다. 바퀴 바깥쪽으로 빠져나온 회전축 나사를 나이록 너트(M4)를 끼워 고정한다. (십자형 육각 복스로 나이록 너트를 돌릴때 ‘딱딱’하는 소리가 몇번 날때까지 돌리면 고정이 된다.) 동일한 방법으로 하나를 더 만들어 2개의 휠을 완성한다. 짧은 커넥팅 로드 1개와 긴 커넥팅 로드 1개, M2.5*10mm 나사(Pan head) 3개를 준비한 뒤, 오른쪽 휠 컵 암(Arm)에 있는 구멍 2개 중, 끝부분의 구멍(빨간색으로 표시된 부분)에 준비한 볼트(M2.5*10mm (Pan head)) 1개를 이용하여 긴 커넥팅 로드를 고정한다. 이때, 볼트의 끝 부분을 구멍 아래쪽에서 윗쪽으로 넣듯이 하여 고정한다. ​ 또한, 볼트의 끝부분이 반대편 구멍 바깥쪽으로 튀어나오지 않도록 조임의 정도를 조절한다. 같은 방법으로 왼쪽 휠 컵의 구멍에 긴 커넥팅 로드의 반대편을 고정한다. (이때, 볼트의 끝부분이 반대편 구멍 바깥쪽으로 튀어나오지 않도록 조임의 정도를 조절한다. ) 오른쪽 휠 컵의 구멍 2개 중, 파란색으로 표시된 부분에는 동일한 볼트를 사용하여 짧은 커넥팅 로드를 연결한다. (이때, 볼트의 끝부분이 반대편 구멍 바깥쪽으로 튀어나오지 않도록 조임의 정도를 조절한다. ) 전륜 휠 베이스 완성된 모습 조향 서보모터 조립 MG996R 서보모터를 준비한 후, 아래 회로도와 스케치를 참고하여, 서보모터의 초기 위치를 90도 위치로 회전시켜 둔다. schematic MG996R 갈색 빨간색 주황색 ESP32 GND 5V GPIO 15 sketch 1234567891011121314151617181920const int ledPin = 15; // corresponds to GPIO 15// setting PWM propertiesconst int ledChannel = 0;const int freq = 50;const int resolution = 16;void setup(){ // PWM Setup ledcSetup(ledChannel, freq, resolution); // PWM CH0, Frequncy 50 Hz, 16bit resolution ledcAttachPin(ledPin, ledChannel); // PWM CH0을 GPIO 15번으로 출력}void loop(){ ledcWrite(ledChannel, 4910); // 1638 ~ 8192 (90degree = 4910) delay(500); }} ㄴ자 서보모터 브라켓, 브라켓 고정용 볼트(Pan-Washer head, M3×6mm) 8개, 서보 혼(고정용 볼트 1개 포함)를 준비한다. 와셔볼트 4개를 사용하여 ㄴ자 브라켓을 고정하고, 서버 혼도 고정용 볼트를 사용하여 장착한다. (아래 사진을 잘 보면서 MG996R 스티커의 글씨 방향, ㄴ자 브라켓이 고정된 방향, 서보 혼 방향(현재 사진에 보이는 서보 날개의 위치가 90도가 됨)에 유의하여 장착한다.) 샤시 하판에 와셔볼트 4개를 사용하여 서보모터를 고정한다. 샤시 하판에 휠 베이스 고정하기 준비물: 서보모터가 고정된 샤시 하판, 황동 육각 스터드 M3×22mm 4개, 볼트 M3*8mm 8개, M2.5×10mm 4개, 부채꼴 모양의 휠 베이스 고정판 2개 (위 1번 사진의) 빨간색으로 표시된 부분에 육각 스터드 4개를 고정한다. (위 1번 사진의) 파란색으로 표시된 부분의 구멍에는, 다음 그림과 같이 긴 커넥팅 로드가 붙어있는 쪽의 휠 컵 구멍(아래 사진에서 파란색으로 표시된 부분)을 맞추어 볼트(M2.5×10mm)로 고정시킨다. (이때, 양쪽 휠 컵의 암(Arm) 부분이 차량 전면을 향하도록 한 상태에서 연결해야 한다.) 고정이 완료된 상태에서 밑면을 보면 다음과 같으며, ​ 위에서 바라본 모습은 다음과 같다. (파란색 원으로 표시된 부분) 부채꼴 모양의 휠 베이스 고정판을 양쪽 휠에 있는 육각 스터드와 스티어링 컵의 구멍에 고정한다. (볼트 M3×8mm 8개, M2.5×10mm 4개 사용) (빨간색 원으로 표시된 부분) M2.5*10mm 나사와 나이록 너트(M2.5)를 사용하여, 짧은 커넥팅 로드를 서보 혼에 고정한다. 이때, 십자형 육각 복스로 나이록 너트를 돌릴때 ‘딱딱’하는 소리가 몇번 날때까지 돌리면 고정이 된다.) ​ 아래 사진은 완성된 전륜 조향 휠 부분을 정면에서 바라본 모습이다. 후륜 모터 파트 조립 25GA370 엔코더 모터에 모터 커넥터를 끼우고, 볼트 (Flat head, M2.5×5mm) 2개를 사용하여 모터 브라켓를 고정한다. 베어링 2개, 샤프트, 써클립, 기어, 육각 샤프트 커플링 커넥터, 써클립(Circlip)을 준비한다. 샤프트 끝부분에 있는 홈에 써클립을 끼운다. 모터 브라켓 양쪽 끝에 있는 구멍에 베어링을 끼우고, 써클립을 끼운 샤프트를 밀어넣는다. ​ 샤프트를 끼운 후, 모터를 앞쪽과 뒷쪽에서 보았을때의 모습 모터에 부착되어 있는 작은 황동 기어에 흰색 플라스틱으로 된 기어가 맞물려지도록 샤프트에 끼우고, 기어 측면에 있는 작은 무두볼트(Set Screw) 2개를 육각렌치를 사용하여 적절하게 분배하여 조여준다. 이때 한쪽 무두볼트만 조여서 고정하면 기어에서 무두볼트가 빠지거나 고정이 되지 않을 수 있다. 이를 고려하여 양쪽의 나사를 적절히 분배하여 조이도록 한다. 육각 샤프트 커플링 커넥터를 준비하여 샤프트에 끼운 후, 커넥터 측면의 볼트를 돌려 고정한다. 이때, 고정하는 볼트의 끝부분이 샤프트의 편평한 면에 닿도록 조여준다. 같은 방법으로 후면 왼쪽 모터도 조립한다. 샤시 하판 뒷편 양쪽에 있는 삼각형 형태로 위치한 구멍에, 모터 브라켓을 올려놓고 볼트(Pan head, M4×6mm)를 사용하여 고정한다. ​ 오른쪽 모터를 샤시 후면에 고정한 모습이다. 같은 방법으로 왼쪽 후면 모터도 고정한다. 범퍼 조립 육각 스터드(M3×16mm) 2개와 볼트 (Bind-Washer head, M3×6mm) 4개 준비 준비된 육각 스터드를 샤시 하판의 맨 앞쪽에 고정한다. 범퍼를 육각기둥에 끼운 후, 와셔볼트를 사용하여 고정한다. 샤시 상판 고정 육각 스터드(M3×22mm) 2개를 서보모터와 DC엔코더모터 사이에 있는 구멍에 볼트(M3.0×8mm)로 고정한다. ​ 육각 스터드를 고정한 모습이다. 샤시 상판의 보호필름을 떼어내고, 육각 스터드 홀에 맟춰 올린 뒤, 볼트(Bind head, M3.0×8mm) 2개를 사용하여 상판을 고정한다. ​ 상판의 오른쪽 하단에 락스위치를 꼽아 고정한 뒤에, 배터리의 (+)라인에 직렬로 배선할 수 있도록 준비한다. 후륜 휠 장착 육각 휠 너트 앞쪽에 있던 나사를 풀러낸 뒤, 바퀴를 끼우고, 풀러냈던 나사로 다시 고정한다. 샤시 완성 ESP32 Parts완성된 샤시의 상판과 하판을 이용하여 ESP32, 브레드보드, 모터드라이버, 배터리, 전원모듈 등을 장작한다. for RC Car (ESP32 + nRF24L01 + TB6612FNG + 25GA370 + MG996R)sketchRC Car에 장착하는 ESP32에 업로드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4, 5);long long address = 0x1234ABCDEFLL;struct Value{ uint16_t value_x; // servo motor pwm uint16_t value_y; // DC motor pwm};Value data;int angle_x = 90; // servo initial position (0~180)int velo_y = 0; // DC motor inital velocityint direction_y = 0; // DC motor directionint i = 0; // joystick center position calculation counterint center_x = 0; // joystick initial center_x int center_y = 0; // joystick initial center_yint ref_xl, ref_xr, ref_ya, ref_yb; // Servo &amp; DC rotation reference value from center position value//servo settingconst int PIN_SERVO = 15; // servo pwm pinconst int CH_SERVO = 2; // servo pwm channelconst int servoFrequency = 50; // servo pwm frequency (Hz)const int servoResolution = 16; // servo pwm resolution (bit) (12bit: 0~4095)// RecvTimeunsigned long lastRecvTime = 0;void centerData() { while(i &lt; 100) { if(radio.available()){ radio.read(&amp;data, sizeof(Value)); center_x = center_x + data.value_x; center_y = center_y + data.value_y; i++; } } center_x = center_x / 100; // x축 조이스틱 센터값 (평균) center_y = center_y / 100; // y축 조이스틱 센터값 (평균) ref_xl = center_x / 2; // 좌회전 동작 기준값 ref_xr = (4095 + center_x) / 2; // 우회전 동작 기준값 ref_ya = (4095 + center_y) / 2; // accelator 동작 기준값 ref_yb = center_y / 2; // brake 동작 기준값}void recvData(){ while(radio.available()){ radio.read(&amp;data, sizeof(Value)); lastRecvTime = millis(); }}/*// TB6612FNG right side &amp; ESP32-WROOM-32D DEVKIT_C V4 left side pin orderconst int PIN_PWMA = 32; const int PIN_INA1 = 33;const int PIN_INA2 = 25;const int PIN_STBY = 26;const int PIN_INB1 = 27;const int PIN_INB2 = 14;const int PIN_PWMB = 12;*/// TB6612FNG right side &amp; ESP32-WROOM-32 left side pin orderconst int PIN_PWMA = 33;const int PIN_AIN2 = 25;const int PIN_AIN1 = 26;const int PIN_STBY = 27;const int PIN_BIN1 = 14;const int PIN_BIN2 = 12;const int PIN_PWMB = 13;// channel setting (GPIO pin, channel)// if STBY(CH0) = LOW, Standby states.// if STBY(CH0) = HIGH, and INA1&amp;INA2 have different value// and PWMA has some value, CW or CCW rotation is made.// Channel CW CCW Stanby Stop Brake1 Brake2 Brake3// PIN_STBY (0) HIGH HIGH LOW HIGH HIGH HIGH HIGH// PIN_INA1 (1) HIGH LOW * LOW HIGH LOW HIGH// PIN_INA2 (2) LOW HIGH * LOW HIGH HIGH LOW// CH_PWMA (3) PWM PWM * HIGH * LOW LOW// PWM Channel setupconst int CH_PWMA = 0;const int CH_PWMB = 1;// PWM frequency and bit resolution setupconst int pwmFrequency = 10000; // Hzconst int bitResolution = 8; // pwm value: 0~255// led setupconst int PIN_LED = 2;int ledstate;void setup() { // put your setup code here, to run once: Serial.begin(115200); radio.begin(); radio.openReadingPipe(1, address); radio.setPALevel(RF24_PA_LOW); radio.startListening(); // Servo PWM Setup ledcSetup(CH_SERVO, servoFrequency, servoResolution); // PWM CH2, Frequncy 50 Hz, 12bit resolution ledcAttachPin(PIN_SERVO, CH_SERVO); // PWM CH2을 GPIO 15번으로 출력 // center value centerData(); pinMode(PIN_LED, OUTPUT); // tb6612fng setting pinMode(PIN_STBY, OUTPUT); pinMode(PIN_AIN1, OUTPUT); pinMode(PIN_AIN2, OUTPUT); pinMode(PIN_PWMA, OUTPUT); pinMode(PIN_BIN1, OUTPUT); pinMode(PIN_BIN2, OUTPUT); pinMode(PIN_PWMB, OUTPUT); // motor output(PWM) setting (channel, frequency, bit) ledcSetup(CH_PWMA, pwmFrequency, bitResolution); ledcSetup(CH_PWMB, pwmFrequency, bitResolution); ledcAttachPin(PIN_PWMA, CH_PWMA); ledcAttachPin(PIN_PWMB, CH_PWMB);}void loop() { ledstate = 0; unsigned long now = millis(); if( now - lastRecvTime &gt; 5){ // 5ms 마다 서보출력 recvData(); rotate_xy(); move(1, velo_y, direction_y); // motor A(right wheels), velo_y speed, moving direction move(2, velo_y, direction_y); // motor B(left wheels), velo_y speed, moving direction if(ledstate &gt; 0) { digitalWrite(PIN_LED, HIGH); } else { digitalWrite(PIN_LED, LOW); } }}void move(int motor, int speed, int direction) { //Move specific motor at speed and direction//motor: A(Right) -&gt; 1, B(Left) -&gt; 2//speed: 0 is off, and 255 is full speed//direction: 0 clockwise, 1 counter-clockwise digitalWrite(PIN_STBY, HIGH); // move boolean inPin1 = HIGH; // Defalut(direction=0) - Clockwise boolean inPin2 = LOW; if(direction == 1) { // Count-clockwise inPin1 = LOW; inPin2 = HIGH; } if(motor == 1){ // if motor == 1, right wheel digitalWrite(PIN_AIN1, inPin1); digitalWrite(PIN_AIN2, inPin2); ledcWrite(CH_PWMA, speed); } else { // if motor is not 1, left wheel digitalWrite(PIN_BIN1, inPin1); digitalWrite(PIN_BIN2, inPin2); ledcWrite(CH_PWMB, speed); }}void stop() { digitalWrite(PIN_STBY, LOW); // stand-by = stop}void rotate_xy() { Serial.print(&quot;x: &quot;); Serial.print(data.value_x); Serial.print(&quot;, y: &quot;); Serial.println(data.value_y); //x축 서보 구동 조건 설정 if(data.value_x &lt; ref_xl) { if(angle_x &gt; 55) { // servo 55~125 degree angle_x--; } else { angle_x = 55; } ledstate++; } else if(data.value_x &gt; ref_xr) { if(angle_x &lt; 125) { angle_x++; } else { angle_x = 125; } ledstate++; } else { if(angle_x &lt; 90) { angle_x++; } else if(angle_x &gt; 90) { angle_x--; } else { angle_x = 90; } } //servo_x.write(angle_x); servoWrite(CH_SERVO, angle_x); delay(5); // delay를 더 줄이면 서보 모터 기어에 무리가 감 //y축 DC 구동 조건 설정 if(data.value_y &gt; ref_ya) { if(direction_y == 0) { if(velo_y &lt; 255) { velo_y++; } else { velo_y = 255; } } if(direction_y == 1) { if(velo_y &gt; 0) { velo_y--; } else { direction_y = 0; velo_y = 0; } } ledstate++; } else if(data.value_y &lt; ref_yb) { if(direction_y == 1) { if(velo_y &lt; 255) { velo_y++; } else { velo_y = 255; } } if(direction_y == 0) { if(velo_y &gt; 0) { velo_y--; } else { direction_y = 1; velo_y = 0; } } ledstate++; } else { if(velo_y &gt; 0) { velo_y--; } else { velo_y = 0; } }}// deg는 0~180도 까지void servoWrite(int ch, int deg){ int servoPWM = map(deg, 0, 180, 2720, 8191); // 16bit (PWM 4.15% ~ 12.5%) ledcWrite(ch, servoPWM);} schematic 16P &amp; 4P jumper block 사용RC카를 제작해보면 프레임 조립 후 여러가지 구동을 위한 부품을 넣어야 하는데, 큰 브레드보드를 장착하기에는 공간이 좁아 조립이 어려울 수 있다. 그러므로 브레드보드를 제거하고 16P &amp; 4P의 점퍼 블록을 사용해 RC카에 장착해본다. 16P 점퍼블록과 4P 점퍼블록, 그리고 2개의 와이어핀을 준비한다. 2개의 와이어핀을 4P 점퍼블록의 중앙에 꼽아넣음으로써, 4개의 핀소켓이 모두 연결되어 있는 상태가 되도록 만든다. (1개의 와이어만 넣어도 연결은 되지만, 헐거워 고정이 안되기 때문에 2개를 사용하는 것임) 16P 점퍼블록을 사용하여 ESP32 DevkitC V4 보드와 TB6612FNG 모터드라이브를 다음과 같이 연결한다. 32 - PWMA33 - AIN225 - AIN126 - NC27 - BIN114 - BIN212 - PWMB GND - GND ESP32의 5V핀에는 4P 점퍼블록을 꼽아, 5V핀을 3개 사용할 수 있도록 만들어준다. 제작 후 위에서 바라본 모습은 다음과 같다. for Remote Controller (ESP32 + nRF24L01 + Dual Joystick)sketch 리모트 컨트롤러로 사용할 TTGO T-energy(ESP32)에 업로드한다. TTGO T-energy를 컴퓨터와 연결하여 사용할 경우에는 반드시 18650 배터리를 제거하거나 스위치를 OFF상태로 두어야 한다. 그러므로 스케치 업로드 시에는 안전한 사용을 위해 18650 배터리를 제거한 뒤 아래의 스케치를 업로드하도록 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;SPI.h&gt;#include &lt;RF24.h&gt;RF24 radio(4, 5);long long address = 0x1234ABCDEFLL;// for no interference, two joysticks must be used with each other ADC! // one joystick use ADC1: GPIO 36,39,32,33,34,35// the other must use ADC2: GPIO 4,0,2,15,13,12,14,27,25,26const int Jstick_x_pin = 25; // Left_Right GPIO25const int Jstick_y_pin = 32; // Forward_Back GPIO32struct Value{ uint16_t value_x; uint16_t value_y;};Value data;void setup() { Serial.begin(115200); radio.begin(); radio.openWritingPipe(address); radio.setPALevel(RF24_PA_MIN); radio.stopListening();}void loop() { data.value_x = Jstick(Jstick_x_pin); delay(10); data.value_y = Jstick(Jstick_y_pin); delay(10); radio.write(&amp;data, sizeof(Value)); //Serial.print(&quot;x: &quot;); Serial.print(data.value_x); //Serial.print(&quot;, y: &quot;); Serial.println(data.value_y);}uint16_t Jstick(int Jstick_Pin){ return analogRead(Jstick_Pin);} schematic TTGO T-energy 에는 5V 단자가 1개 있음. 2개의 조이스틱에 5V가 각각 입력되어야 하므로, TTGO T-energy의 5V 단자를 2개로 분기할 수 있는 Y자형 케이블을 제작하여 사용하도록 한다. ​ 위 형태는 (오른쪽) 1개의 (F)단자를 (왼쪽) 3개의 (F)단자로 분기하는 형태의 케이블이다. ​ 이를 참고하여 1개의 단자를 2개의 단자로 나눠주는 케이블을 제작하면 된다.","link":"/2021/12/02/ESP32-RC%EC%B9%B4/"}],"tags":[{"name":"rc","slug":"rc","link":"/tags/rc/"},{"name":"iot","slug":"iot","link":"/tags/iot/"},{"name":"3D","slug":"3d","link":"/tags/3d/"}],"categories":[{"name":"arduino","slug":"arduino","link":"/categories/arduino/"},{"name":"science","slug":"science","link":"/categories/science/"},{"name":"esp32","slug":"esp32","link":"/categories/esp32/"},{"name":"ESP32","slug":"esp32","link":"/categories/esp32/"},{"name":"Science","slug":"science","link":"/categories/science/"},{"name":"office","slug":"office","link":"/categories/office/"},{"name":"drone","slug":"drone","link":"/categories/drone/"},{"name":"diy","slug":"diy","link":"/categories/diy/"}]}